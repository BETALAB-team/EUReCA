<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pandas.core.frame &mdash; EUReCA 0.2 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            EUReCA
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Package:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">eureca-ubem</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">EUReCA</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pandas.core.frame</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pandas.core.frame</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">DataFrame</span>
<span class="sd">---------</span>
<span class="sd">An efficient 2D container for potentially mixed-type time series or other</span>
<span class="sd">labeled data series.</span>

<span class="sd">Similar to its R counterpart, data.frame, except providing automatic data</span>
<span class="sd">alignment and a host of useful data manipulation methods having to do with the</span>
<span class="sd">labeling information</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">abc</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">textwrap</span> <span class="kn">import</span> <span class="n">dedent</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">TYPE_CHECKING</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Hashable</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Iterator</span><span class="p">,</span>
    <span class="n">Literal</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">cast</span><span class="p">,</span>
    <span class="n">overload</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ma</span>

<span class="kn">from</span> <span class="nn">pandas._config</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_option</span><span class="p">,</span>
    <span class="n">using_copy_on_write</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">pandas._libs</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">algos</span> <span class="k">as</span> <span class="n">libalgos</span><span class="p">,</span>
    <span class="n">lib</span><span class="p">,</span>
    <span class="n">properties</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas._libs.hashtable</span> <span class="kn">import</span> <span class="n">duplicated</span>
<span class="kn">from</span> <span class="nn">pandas._libs.lib</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">NoDefault</span><span class="p">,</span>
    <span class="n">is_range_indexer</span><span class="p">,</span>
    <span class="n">no_default</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas._typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AggFuncType</span><span class="p">,</span>
    <span class="n">AlignJoin</span><span class="p">,</span>
    <span class="n">AnyAll</span><span class="p">,</span>
    <span class="n">AnyArrayLike</span><span class="p">,</span>
    <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">Axes</span><span class="p">,</span>
    <span class="n">Axis</span><span class="p">,</span>
    <span class="n">AxisInt</span><span class="p">,</span>
    <span class="n">ColspaceArgType</span><span class="p">,</span>
    <span class="n">CompressionOptions</span><span class="p">,</span>
    <span class="n">CorrelationMethod</span><span class="p">,</span>
    <span class="n">DropKeep</span><span class="p">,</span>
    <span class="n">Dtype</span><span class="p">,</span>
    <span class="n">DtypeObj</span><span class="p">,</span>
    <span class="n">FilePath</span><span class="p">,</span>
    <span class="n">FillnaOptions</span><span class="p">,</span>
    <span class="n">FloatFormatType</span><span class="p">,</span>
    <span class="n">FormattersType</span><span class="p">,</span>
    <span class="n">Frequency</span><span class="p">,</span>
    <span class="n">IgnoreRaise</span><span class="p">,</span>
    <span class="n">IndexKeyFunc</span><span class="p">,</span>
    <span class="n">IndexLabel</span><span class="p">,</span>
    <span class="n">Level</span><span class="p">,</span>
    <span class="n">MergeHow</span><span class="p">,</span>
    <span class="n">NaPosition</span><span class="p">,</span>
    <span class="n">PythonFuncType</span><span class="p">,</span>
    <span class="n">QuantileInterpolation</span><span class="p">,</span>
    <span class="n">ReadBuffer</span><span class="p">,</span>
    <span class="n">Renamer</span><span class="p">,</span>
    <span class="n">Scalar</span><span class="p">,</span>
    <span class="n">SortKind</span><span class="p">,</span>
    <span class="n">StorageOptions</span><span class="p">,</span>
    <span class="n">Suffixes</span><span class="p">,</span>
    <span class="n">TimedeltaConvertibleTypes</span><span class="p">,</span>
    <span class="n">TimestampConvertibleTypes</span><span class="p">,</span>
    <span class="n">ValueKeyFunc</span><span class="p">,</span>
    <span class="n">WriteBuffer</span><span class="p">,</span>
    <span class="n">npt</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.compat</span> <span class="kn">import</span> <span class="n">PYPY</span>
<span class="kn">from</span> <span class="nn">pandas.compat._optional</span> <span class="kn">import</span> <span class="n">import_optional_dependency</span>
<span class="kn">from</span> <span class="nn">pandas.compat.numpy</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">function</span> <span class="k">as</span> <span class="n">nv</span><span class="p">,</span>
    <span class="n">np_percentile_argname</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.errors</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ChainedAssignmentError</span><span class="p">,</span>
    <span class="n">InvalidIndexError</span><span class="p">,</span>
    <span class="n">_chained_assignment_msg</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.util._decorators</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Appender</span><span class="p">,</span>
    <span class="n">Substitution</span><span class="p">,</span>
    <span class="n">doc</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.util._exceptions</span> <span class="kn">import</span> <span class="n">find_stack_level</span>
<span class="kn">from</span> <span class="nn">pandas.util._validators</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">validate_ascending</span><span class="p">,</span>
    <span class="n">validate_bool_kwarg</span><span class="p">,</span>
    <span class="n">validate_percentile</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">pandas.core.dtypes.cast</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">LossySetitemError</span><span class="p">,</span>
    <span class="n">can_hold_element</span><span class="p">,</span>
    <span class="n">construct_1d_arraylike_from_scalar</span><span class="p">,</span>
    <span class="n">construct_2d_arraylike_from_scalar</span><span class="p">,</span>
    <span class="n">find_common_type</span><span class="p">,</span>
    <span class="n">infer_dtype_from_scalar</span><span class="p">,</span>
    <span class="n">invalidate_string_dtypes</span><span class="p">,</span>
    <span class="n">maybe_box_native</span><span class="p">,</span>
    <span class="n">maybe_downcast_to_dtype</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.common</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">infer_dtype_from_object</span><span class="p">,</span>
    <span class="n">is_1d_only_ea_dtype</span><span class="p">,</span>
    <span class="n">is_bool_dtype</span><span class="p">,</span>
    <span class="n">is_dataclass</span><span class="p">,</span>
    <span class="n">is_dict_like</span><span class="p">,</span>
    <span class="n">is_dtype_equal</span><span class="p">,</span>
    <span class="n">is_extension_array_dtype</span><span class="p">,</span>
    <span class="n">is_float</span><span class="p">,</span>
    <span class="n">is_float_dtype</span><span class="p">,</span>
    <span class="n">is_hashable</span><span class="p">,</span>
    <span class="n">is_integer</span><span class="p">,</span>
    <span class="n">is_integer_dtype</span><span class="p">,</span>
    <span class="n">is_iterator</span><span class="p">,</span>
    <span class="n">is_list_like</span><span class="p">,</span>
    <span class="n">is_scalar</span><span class="p">,</span>
    <span class="n">is_sequence</span><span class="p">,</span>
    <span class="n">needs_i8_conversion</span><span class="p">,</span>
    <span class="n">pandas_dtype</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.dtypes</span> <span class="kn">import</span> <span class="n">ExtensionDtype</span>
<span class="kn">from</span> <span class="nn">pandas.core.dtypes.missing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">isna</span><span class="p">,</span>
    <span class="n">notna</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">pandas.core</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">algorithms</span><span class="p">,</span>
    <span class="n">common</span> <span class="k">as</span> <span class="n">com</span><span class="p">,</span>
    <span class="n">nanops</span><span class="p">,</span>
    <span class="n">ops</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.accessor</span> <span class="kn">import</span> <span class="n">CachedAccessor</span>
<span class="kn">from</span> <span class="nn">pandas.core.apply</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">reconstruct_func</span><span class="p">,</span>
    <span class="n">relabel_result</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.array_algos.take</span> <span class="kn">import</span> <span class="n">take_2d_multi</span>
<span class="kn">from</span> <span class="nn">pandas.core.arraylike</span> <span class="kn">import</span> <span class="n">OpsMixin</span>
<span class="kn">from</span> <span class="nn">pandas.core.arrays</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DatetimeArray</span><span class="p">,</span>
    <span class="n">ExtensionArray</span><span class="p">,</span>
    <span class="n">PeriodArray</span><span class="p">,</span>
    <span class="n">TimedeltaArray</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.arrays.arrow</span> <span class="kn">import</span> <span class="n">ArrowDtype</span>
<span class="kn">from</span> <span class="nn">pandas.core.arrays.sparse</span> <span class="kn">import</span> <span class="n">SparseFrameAccessor</span>
<span class="kn">from</span> <span class="nn">pandas.core.construction</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ensure_wrapped_if_datetimelike</span><span class="p">,</span>
    <span class="n">extract_array</span><span class="p">,</span>
    <span class="n">sanitize_array</span><span class="p">,</span>
    <span class="n">sanitize_masked_array</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.generic</span> <span class="kn">import</span> <span class="n">NDFrame</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexers</span> <span class="kn">import</span> <span class="n">check_key_length</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.api</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DatetimeIndex</span><span class="p">,</span>
    <span class="n">Index</span><span class="p">,</span>
    <span class="n">PeriodIndex</span><span class="p">,</span>
    <span class="n">default_index</span><span class="p">,</span>
    <span class="n">ensure_index</span><span class="p">,</span>
    <span class="n">ensure_index_from_sequences</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexes.multi</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">MultiIndex</span><span class="p">,</span>
    <span class="n">maybe_droplevels</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.indexing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">check_bool_indexer</span><span class="p">,</span>
    <span class="n">check_dict_or_set_indexers</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.internals</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ArrayManager</span><span class="p">,</span>
    <span class="n">BlockManager</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.internals.construction</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">arrays_to_mgr</span><span class="p">,</span>
    <span class="n">dataclasses_to_dicts</span><span class="p">,</span>
    <span class="n">dict_to_mgr</span><span class="p">,</span>
    <span class="n">mgr_to_mgr</span><span class="p">,</span>
    <span class="n">ndarray_to_mgr</span><span class="p">,</span>
    <span class="n">nested_data_to_arrays</span><span class="p">,</span>
    <span class="n">rec_array_to_mgr</span><span class="p">,</span>
    <span class="n">reorder_arrays</span><span class="p">,</span>
    <span class="n">to_arrays</span><span class="p">,</span>
    <span class="n">treat_as_nested</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.methods</span> <span class="kn">import</span> <span class="n">selectn</span>
<span class="kn">from</span> <span class="nn">pandas.core.reshape.melt</span> <span class="kn">import</span> <span class="n">melt</span>
<span class="kn">from</span> <span class="nn">pandas.core.series</span> <span class="kn">import</span> <span class="n">Series</span>
<span class="kn">from</span> <span class="nn">pandas.core.shared_docs</span> <span class="kn">import</span> <span class="n">_shared_docs</span>
<span class="kn">from</span> <span class="nn">pandas.core.sorting</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">get_group_index</span><span class="p">,</span>
    <span class="n">lexsort_indexer</span><span class="p">,</span>
    <span class="n">nargsort</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">pandas.io.common</span> <span class="kn">import</span> <span class="n">get_handle</span>
<span class="kn">from</span> <span class="nn">pandas.io.formats</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">console</span><span class="p">,</span>
    <span class="nb">format</span> <span class="k">as</span> <span class="n">fmt</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.io.formats.info</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">INFO_DOCSTRING</span><span class="p">,</span>
    <span class="n">DataFrameInfo</span><span class="p">,</span>
    <span class="n">frame_sub_kwargs</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">pandas.plotting</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pandas.core.groupby.generic</span> <span class="kn">import</span> <span class="n">DataFrameGroupBy</span>
    <span class="kn">from</span> <span class="nn">pandas.core.interchange.dataframe_protocol</span> <span class="kn">import</span> <span class="n">DataFrame</span> <span class="k">as</span> <span class="n">DataFrameXchg</span>
    <span class="kn">from</span> <span class="nn">pandas.core.internals</span> <span class="kn">import</span> <span class="n">SingleDataManager</span>
    <span class="kn">from</span> <span class="nn">pandas.core.resample</span> <span class="kn">import</span> <span class="n">Resampler</span>

    <span class="kn">from</span> <span class="nn">pandas.io.formats.style</span> <span class="kn">import</span> <span class="n">Styler</span>

<span class="c1"># ---------------------------------------------------------------------</span>
<span class="c1"># Docstring templates</span>

<span class="n">_shared_doc_kwargs</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;axes&quot;</span><span class="p">:</span> <span class="s2">&quot;index, columns&quot;</span><span class="p">,</span>
    <span class="s2">&quot;klass&quot;</span><span class="p">:</span> <span class="s2">&quot;DataFrame&quot;</span><span class="p">,</span>
    <span class="s2">&quot;axes_single_arg&quot;</span><span class="p">:</span> <span class="s2">&quot;{0 or &#39;index&#39;, 1 or &#39;columns&#39;}&quot;</span><span class="p">,</span>
    <span class="s2">&quot;axis&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="s2">        If 0 or &#39;index&#39;: apply function to each column.</span>
<span class="s2">        If 1 or &#39;columns&#39;: apply function to each row.&quot;&quot;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;inplace&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    inplace : bool, default False</span>
<span class="s2">        Whether to modify the DataFrame rather than creating a new one.&quot;&quot;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;optional_by&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">by : str or list of str</span>
<span class="s2">    Name or list of names to sort by.</span>

<span class="s2">    - if `axis` is 0 or `&#39;index&#39;` then `by` may contain index</span>
<span class="s2">      levels and/or column labels.</span>
<span class="s2">    - if `axis` is 1 or `&#39;columns&#39;` then `by` may contain column</span>
<span class="s2">      levels and/or index labels.&quot;&quot;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;optional_reindex&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">labels : array-like, optional</span>
<span class="s2">    New labels / index to conform the axis specified by &#39;axis&#39; to.</span>
<span class="s2">index : array-like, optional</span>
<span class="s2">    New labels for the index. Preferably an Index object to avoid</span>
<span class="s2">    duplicating data.</span>
<span class="s2">columns : array-like, optional</span>
<span class="s2">    New labels for the columns. Preferably an Index object to avoid</span>
<span class="s2">    duplicating data.</span>
<span class="s2">axis : int or str, optional</span>
<span class="s2">    Axis to target. Can be either the axis name (&#39;index&#39;, &#39;columns&#39;)</span>
<span class="s2">    or number (0, 1).&quot;&quot;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;replace_iloc&quot;</span><span class="p">:</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    This differs from updating with ``.loc`` or ``.iloc``, which require</span>
<span class="s2">    you to specify a location to update with some value.&quot;&quot;&quot;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">_numeric_only_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;numeric_only : bool, default False</span>
<span class="s2">    Include only float, int, boolean data.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">_merge_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Merge DataFrame or named Series objects with a database-style join.</span>

<span class="s2">A named Series object is treated as a DataFrame with a single named column.</span>

<span class="s2">The join is done on columns or indexes. If joining columns on</span>
<span class="s2">columns, the DataFrame indexes *will be ignored*. Otherwise if joining indexes</span>
<span class="s2">on indexes or indexes on a column or columns, the index will be passed on.</span>
<span class="s2">When performing a cross merge, no column specifications to merge on are</span>
<span class="s2">allowed.</span>

<span class="s2">.. warning::</span>

<span class="s2">    If both key columns contain rows where the key is a null value, those</span>
<span class="s2">    rows will be matched against each other. This is different from usual SQL</span>
<span class="s2">    join behaviour and can lead to unexpected results.</span>

<span class="s2">Parameters</span>
<span class="s2">----------</span><span class="si">%s</span>
<span class="s2">right : DataFrame or named Series</span>
<span class="s2">    Object to merge with.</span>
<span class="s2">how : {&#39;left&#39;, &#39;right&#39;, &#39;outer&#39;, &#39;inner&#39;, &#39;cross&#39;}, default &#39;inner&#39;</span>
<span class="s2">    Type of merge to be performed.</span>

<span class="s2">    * left: use only keys from left frame, similar to a SQL left outer join;</span>
<span class="s2">      preserve key order.</span>
<span class="s2">    * right: use only keys from right frame, similar to a SQL right outer join;</span>
<span class="s2">      preserve key order.</span>
<span class="s2">    * outer: use union of keys from both frames, similar to a SQL full outer</span>
<span class="s2">      join; sort keys lexicographically.</span>
<span class="s2">    * inner: use intersection of keys from both frames, similar to a SQL inner</span>
<span class="s2">      join; preserve the order of the left keys.</span>
<span class="s2">    * cross: creates the cartesian product from both frames, preserves the order</span>
<span class="s2">      of the left keys.</span>

<span class="s2">      .. versionadded:: 1.2.0</span>

<span class="s2">on : label or list</span>
<span class="s2">    Column or index level names to join on. These must be found in both</span>
<span class="s2">    DataFrames. If `on` is None and not merging on indexes then this defaults</span>
<span class="s2">    to the intersection of the columns in both DataFrames.</span>
<span class="s2">left_on : label or list, or array-like</span>
<span class="s2">    Column or index level names to join on in the left DataFrame. Can also</span>
<span class="s2">    be an array or list of arrays of the length of the left DataFrame.</span>
<span class="s2">    These arrays are treated as if they are columns.</span>
<span class="s2">right_on : label or list, or array-like</span>
<span class="s2">    Column or index level names to join on in the right DataFrame. Can also</span>
<span class="s2">    be an array or list of arrays of the length of the right DataFrame.</span>
<span class="s2">    These arrays are treated as if they are columns.</span>
<span class="s2">left_index : bool, default False</span>
<span class="s2">    Use the index from the left DataFrame as the join key(s). If it is a</span>
<span class="s2">    MultiIndex, the number of keys in the other DataFrame (either the index</span>
<span class="s2">    or a number of columns) must match the number of levels.</span>
<span class="s2">right_index : bool, default False</span>
<span class="s2">    Use the index from the right DataFrame as the join key. Same caveats as</span>
<span class="s2">    left_index.</span>
<span class="s2">sort : bool, default False</span>
<span class="s2">    Sort the join keys lexicographically in the result DataFrame. If False,</span>
<span class="s2">    the order of the join keys depends on the join type (how keyword).</span>
<span class="s2">suffixes : list-like, default is (&quot;_x&quot;, &quot;_y&quot;)</span>
<span class="s2">    A length-2 sequence where each element is optionally a string</span>
<span class="s2">    indicating the suffix to add to overlapping column names in</span>
<span class="s2">    `left` and `right` respectively. Pass a value of `None` instead</span>
<span class="s2">    of a string to indicate that the column name from `left` or</span>
<span class="s2">    `right` should be left as-is, with no suffix. At least one of the</span>
<span class="s2">    values must not be None.</span>
<span class="s2">copy : bool, default True</span>
<span class="s2">    If False, avoid copy if possible.</span>
<span class="s2">indicator : bool or str, default False</span>
<span class="s2">    If True, adds a column to the output DataFrame called &quot;_merge&quot; with</span>
<span class="s2">    information on the source of each row. The column can be given a different</span>
<span class="s2">    name by providing a string argument. The column will have a Categorical</span>
<span class="s2">    type with the value of &quot;left_only&quot; for observations whose merge key only</span>
<span class="s2">    appears in the left DataFrame, &quot;right_only&quot; for observations</span>
<span class="s2">    whose merge key only appears in the right DataFrame, and &quot;both&quot;</span>
<span class="s2">    if the observation&#39;s merge key is found in both DataFrames.</span>

<span class="s2">validate : str, optional</span>
<span class="s2">    If specified, checks if merge is of specified type.</span>

<span class="s2">    * &quot;one_to_one&quot; or &quot;1:1&quot;: check if merge keys are unique in both</span>
<span class="s2">      left and right datasets.</span>
<span class="s2">    * &quot;one_to_many&quot; or &quot;1:m&quot;: check if merge keys are unique in left</span>
<span class="s2">      dataset.</span>
<span class="s2">    * &quot;many_to_one&quot; or &quot;m:1&quot;: check if merge keys are unique in right</span>
<span class="s2">      dataset.</span>
<span class="s2">    * &quot;many_to_many&quot; or &quot;m:m&quot;: allowed, but does not result in checks.</span>

<span class="s2">Returns</span>
<span class="s2">-------</span>
<span class="s2">DataFrame</span>
<span class="s2">    A DataFrame of the two merged objects.</span>

<span class="s2">See Also</span>
<span class="s2">--------</span>
<span class="s2">merge_ordered : Merge with optional filling/interpolation.</span>
<span class="s2">merge_asof : Merge on nearest keys.</span>
<span class="s2">DataFrame.join : Similar method using indices.</span>

<span class="s2">Notes</span>
<span class="s2">-----</span>
<span class="s2">Support for specifying index levels as the `on`, `left_on`, and</span>
<span class="s2">`right_on` parameters was added in version 0.23.0</span>
<span class="s2">Support for merging named Series objects was added in version 0.24.0</span>

<span class="s2">Examples</span>
<span class="s2">--------</span>
<span class="s2">&gt;&gt;&gt; df1 = pd.DataFrame({&#39;lkey&#39;: [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;, &#39;foo&#39;],</span>
<span class="s2">...                     &#39;value&#39;: [1, 2, 3, 5]})</span>
<span class="s2">&gt;&gt;&gt; df2 = pd.DataFrame({&#39;rkey&#39;: [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;, &#39;foo&#39;],</span>
<span class="s2">...                     &#39;value&#39;: [5, 6, 7, 8]})</span>
<span class="s2">&gt;&gt;&gt; df1</span>
<span class="s2">    lkey value</span>
<span class="s2">0   foo      1</span>
<span class="s2">1   bar      2</span>
<span class="s2">2   baz      3</span>
<span class="s2">3   foo      5</span>
<span class="s2">&gt;&gt;&gt; df2</span>
<span class="s2">    rkey value</span>
<span class="s2">0   foo      5</span>
<span class="s2">1   bar      6</span>
<span class="s2">2   baz      7</span>
<span class="s2">3   foo      8</span>

<span class="s2">Merge df1 and df2 on the lkey and rkey columns. The value columns have</span>
<span class="s2">the default suffixes, _x and _y, appended.</span>

<span class="s2">&gt;&gt;&gt; df1.merge(df2, left_on=&#39;lkey&#39;, right_on=&#39;rkey&#39;)</span>
<span class="s2">  lkey  value_x rkey  value_y</span>
<span class="s2">0  foo        1  foo        5</span>
<span class="s2">1  foo        1  foo        8</span>
<span class="s2">2  foo        5  foo        5</span>
<span class="s2">3  foo        5  foo        8</span>
<span class="s2">4  bar        2  bar        6</span>
<span class="s2">5  baz        3  baz        7</span>

<span class="s2">Merge DataFrames df1 and df2 with specified left and right suffixes</span>
<span class="s2">appended to any overlapping columns.</span>

<span class="s2">&gt;&gt;&gt; df1.merge(df2, left_on=&#39;lkey&#39;, right_on=&#39;rkey&#39;,</span>
<span class="s2">...           suffixes=(&#39;_left&#39;, &#39;_right&#39;))</span>
<span class="s2">  lkey  value_left rkey  value_right</span>
<span class="s2">0  foo           1  foo            5</span>
<span class="s2">1  foo           1  foo            8</span>
<span class="s2">2  foo           5  foo            5</span>
<span class="s2">3  foo           5  foo            8</span>
<span class="s2">4  bar           2  bar            6</span>
<span class="s2">5  baz           3  baz            7</span>

<span class="s2">Merge DataFrames df1 and df2, but raise an exception if the DataFrames have</span>
<span class="s2">any overlapping columns.</span>

<span class="s2">&gt;&gt;&gt; df1.merge(df2, left_on=&#39;lkey&#39;, right_on=&#39;rkey&#39;, suffixes=(False, False))</span>
<span class="s2">Traceback (most recent call last):</span>
<span class="s2">...</span>
<span class="s2">ValueError: columns overlap but no suffix specified:</span>
<span class="s2">    Index([&#39;value&#39;], dtype=&#39;object&#39;)</span>

<span class="s2">&gt;&gt;&gt; df1 = pd.DataFrame({&#39;a&#39;: [&#39;foo&#39;, &#39;bar&#39;], &#39;b&#39;: [1, 2]})</span>
<span class="s2">&gt;&gt;&gt; df2 = pd.DataFrame({&#39;a&#39;: [&#39;foo&#39;, &#39;baz&#39;], &#39;c&#39;: [3, 4]})</span>
<span class="s2">&gt;&gt;&gt; df1</span>
<span class="s2">      a  b</span>
<span class="s2">0   foo  1</span>
<span class="s2">1   bar  2</span>
<span class="s2">&gt;&gt;&gt; df2</span>
<span class="s2">      a  c</span>
<span class="s2">0   foo  3</span>
<span class="s2">1   baz  4</span>

<span class="s2">&gt;&gt;&gt; df1.merge(df2, how=&#39;inner&#39;, on=&#39;a&#39;)</span>
<span class="s2">      a  b  c</span>
<span class="s2">0   foo  1  3</span>

<span class="s2">&gt;&gt;&gt; df1.merge(df2, how=&#39;left&#39;, on=&#39;a&#39;)</span>
<span class="s2">      a  b  c</span>
<span class="s2">0   foo  1  3.0</span>
<span class="s2">1   bar  2  NaN</span>

<span class="s2">&gt;&gt;&gt; df1 = pd.DataFrame({&#39;left&#39;: [&#39;foo&#39;, &#39;bar&#39;]})</span>
<span class="s2">&gt;&gt;&gt; df2 = pd.DataFrame({&#39;right&#39;: [7, 8]})</span>
<span class="s2">&gt;&gt;&gt; df1</span>
<span class="s2">    left</span>
<span class="s2">0   foo</span>
<span class="s2">1   bar</span>
<span class="s2">&gt;&gt;&gt; df2</span>
<span class="s2">    right</span>
<span class="s2">0   7</span>
<span class="s2">1   8</span>

<span class="s2">&gt;&gt;&gt; df1.merge(df2, how=&#39;cross&#39;)</span>
<span class="s2">   left  right</span>
<span class="s2">0   foo      7</span>
<span class="s2">1   foo      8</span>
<span class="s2">2   bar      7</span>
<span class="s2">3   bar      8</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="c1"># -----------------------------------------------------------------------</span>
<span class="c1"># DataFrame class</span>


<span class="k">class</span> <span class="nc">DataFrame</span><span class="p">(</span><span class="n">NDFrame</span><span class="p">,</span> <span class="n">OpsMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Two-dimensional, size-mutable, potentially heterogeneous tabular data.</span>

<span class="sd">    Data structure also contains labeled axes (rows and columns).</span>
<span class="sd">    Arithmetic operations align on both row and column labels. Can be</span>
<span class="sd">    thought of as a dict-like container for Series objects. The primary</span>
<span class="sd">    pandas data structure.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : ndarray (structured or homogeneous), Iterable, dict, or DataFrame</span>
<span class="sd">        Dict can contain Series, arrays, constants, dataclass or list-like objects. If</span>
<span class="sd">        data is a dict, column order follows insertion-order. If a dict contains Series</span>
<span class="sd">        which have an index defined, it is aligned by its index. This alignment also</span>
<span class="sd">        occurs if data is a Series or a DataFrame itself. Alignment is done on</span>
<span class="sd">        Series/DataFrame inputs.</span>

<span class="sd">        If data is a list of dicts, column order follows insertion-order.</span>

<span class="sd">    index : Index or array-like</span>
<span class="sd">        Index to use for resulting frame. Will default to RangeIndex if</span>
<span class="sd">        no indexing information part of input data and no index provided.</span>
<span class="sd">    columns : Index or array-like</span>
<span class="sd">        Column labels to use for resulting frame when data does not have them,</span>
<span class="sd">        defaulting to RangeIndex(0, 1, 2, ..., n). If data contains column labels,</span>
<span class="sd">        will perform column selection instead.</span>
<span class="sd">    dtype : dtype, default None</span>
<span class="sd">        Data type to force. Only a single dtype is allowed. If None, infer.</span>
<span class="sd">    copy : bool or None, default None</span>
<span class="sd">        Copy data from inputs.</span>
<span class="sd">        For dict data, the default of None behaves like ``copy=True``.  For DataFrame</span>
<span class="sd">        or 2d ndarray input, the default of None behaves like ``copy=False``.</span>
<span class="sd">        If data is a dict containing one or more Series (possibly of different dtypes),</span>
<span class="sd">        ``copy=False`` will ensure that these inputs are not copied.</span>

<span class="sd">        .. versionchanged:: 1.3.0</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    DataFrame.from_records : Constructor from tuples, also record arrays.</span>
<span class="sd">    DataFrame.from_dict : From dicts of Series, arrays, or dicts.</span>
<span class="sd">    read_csv : Read a comma-separated values (csv) file into DataFrame.</span>
<span class="sd">    read_table : Read general delimited file into DataFrame.</span>
<span class="sd">    read_clipboard : Read text from clipboard into DataFrame.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Please reference the :ref:`User Guide &lt;basics.dataframe&gt;` for more information.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Constructing DataFrame from a dictionary.</span>

<span class="sd">    &gt;&gt;&gt; d = {&#39;col1&#39;: [1, 2], &#39;col2&#39;: [3, 4]}</span>
<span class="sd">    &gt;&gt;&gt; df = pd.DataFrame(data=d)</span>
<span class="sd">    &gt;&gt;&gt; df</span>
<span class="sd">       col1  col2</span>
<span class="sd">    0     1     3</span>
<span class="sd">    1     2     4</span>

<span class="sd">    Notice that the inferred dtype is int64.</span>

<span class="sd">    &gt;&gt;&gt; df.dtypes</span>
<span class="sd">    col1    int64</span>
<span class="sd">    col2    int64</span>
<span class="sd">    dtype: object</span>

<span class="sd">    To enforce a single dtype:</span>

<span class="sd">    &gt;&gt;&gt; df = pd.DataFrame(data=d, dtype=np.int8)</span>
<span class="sd">    &gt;&gt;&gt; df.dtypes</span>
<span class="sd">    col1    int8</span>
<span class="sd">    col2    int8</span>
<span class="sd">    dtype: object</span>

<span class="sd">    Constructing DataFrame from a dictionary including Series:</span>

<span class="sd">    &gt;&gt;&gt; d = {&#39;col1&#39;: [0, 1, 2, 3], &#39;col2&#39;: pd.Series([2, 3], index=[2, 3])}</span>
<span class="sd">    &gt;&gt;&gt; pd.DataFrame(data=d, index=[0, 1, 2, 3])</span>
<span class="sd">       col1  col2</span>
<span class="sd">    0     0   NaN</span>
<span class="sd">    1     1   NaN</span>
<span class="sd">    2     2   2.0</span>
<span class="sd">    3     3   3.0</span>

<span class="sd">    Constructing DataFrame from numpy ndarray:</span>

<span class="sd">    &gt;&gt;&gt; df2 = pd.DataFrame(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),</span>
<span class="sd">    ...                    columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">    &gt;&gt;&gt; df2</span>
<span class="sd">       a  b  c</span>
<span class="sd">    0  1  2  3</span>
<span class="sd">    1  4  5  6</span>
<span class="sd">    2  7  8  9</span>

<span class="sd">    Constructing DataFrame from a numpy ndarray that has labeled columns:</span>

<span class="sd">    &gt;&gt;&gt; data = np.array([(1, 2, 3), (4, 5, 6), (7, 8, 9)],</span>
<span class="sd">    ...                 dtype=[(&quot;a&quot;, &quot;i4&quot;), (&quot;b&quot;, &quot;i4&quot;), (&quot;c&quot;, &quot;i4&quot;)])</span>
<span class="sd">    &gt;&gt;&gt; df3 = pd.DataFrame(data, columns=[&#39;c&#39;, &#39;a&#39;])</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; df3</span>
<span class="sd">       c  a</span>
<span class="sd">    0  3  1</span>
<span class="sd">    1  6  4</span>
<span class="sd">    2  9  7</span>

<span class="sd">    Constructing DataFrame from dataclass:</span>

<span class="sd">    &gt;&gt;&gt; from dataclasses import make_dataclass</span>
<span class="sd">    &gt;&gt;&gt; Point = make_dataclass(&quot;Point&quot;, [(&quot;x&quot;, int), (&quot;y&quot;, int)])</span>
<span class="sd">    &gt;&gt;&gt; pd.DataFrame([Point(0, 0), Point(0, 3), Point(2, 3)])</span>
<span class="sd">       x  y</span>
<span class="sd">    0  0  0</span>
<span class="sd">    1  0  3</span>
<span class="sd">    2  2  3</span>

<span class="sd">    Constructing DataFrame from Series/DataFrame:</span>

<span class="sd">    &gt;&gt;&gt; ser = pd.Series([1, 2, 3], index=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])</span>
<span class="sd">    &gt;&gt;&gt; df = pd.DataFrame(data=ser, index=[&quot;a&quot;, &quot;c&quot;])</span>
<span class="sd">    &gt;&gt;&gt; df</span>
<span class="sd">       0</span>
<span class="sd">    a  1</span>
<span class="sd">    c  3</span>

<span class="sd">    &gt;&gt;&gt; df1 = pd.DataFrame([1, 2, 3], index=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], columns=[&quot;x&quot;])</span>
<span class="sd">    &gt;&gt;&gt; df2 = pd.DataFrame(data=df1, index=[&quot;a&quot;, &quot;c&quot;])</span>
<span class="sd">    &gt;&gt;&gt; df2</span>
<span class="sd">       x</span>
<span class="sd">    a  1</span>
<span class="sd">    c  3</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_internal_names_set</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;columns&quot;</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">}</span> <span class="o">|</span> <span class="n">NDFrame</span><span class="o">.</span><span class="n">_internal_names_set</span>
    <span class="n">_typ</span> <span class="o">=</span> <span class="s2">&quot;dataframe&quot;</span>
    <span class="n">_HANDLED_TYPES</span> <span class="o">=</span> <span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="n">Index</span><span class="p">,</span> <span class="n">ExtensionArray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="n">_accessors</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;sparse&quot;</span><span class="p">}</span>
    <span class="n">_hidden_attrs</span><span class="p">:</span> <span class="nb">frozenset</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">NDFrame</span><span class="o">.</span><span class="n">_hidden_attrs</span> <span class="o">|</span> <span class="nb">frozenset</span><span class="p">([])</span>
    <span class="n">_mgr</span><span class="p">:</span> <span class="n">BlockManager</span> <span class="o">|</span> <span class="n">ArrayManager</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">DataFrame</span>

    <span class="n">_constructor_sliced</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Series</span><span class="p">]</span> <span class="o">=</span> <span class="n">Series</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Constructors</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">Dtype</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_mgr</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">copy</span><span class="p">:</span>
                <span class="c1"># if not copying data, ensure to still return a shallow copy</span>
                <span class="c1"># to avoid the result sharing the same Manager</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">BlockManager</span><span class="p">,</span> <span class="n">ArrayManager</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">using_copy_on_write</span><span class="p">():</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># first check if a Manager is passed without any other arguments</span>
            <span class="c1"># -&gt; use fastpath (without checking Manager type)</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">copy</span><span class="p">:</span>
                <span class="c1"># GH#33357 fastpath</span>
                <span class="n">NDFrame</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="n">manager</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;mode.data_manager&quot;</span><span class="p">)</span>

        <span class="c1"># GH47215</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;index cannot be a set&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;columns cannot be a set&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">copy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="c1"># retain pre-GH#38939 default behavior</span>
                <span class="n">copy</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="p">(</span>
                <span class="n">manager</span> <span class="o">==</span> <span class="s2">&quot;array&quot;</span>
                <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ExtensionArray</span><span class="p">))</span>
                <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="p">):</span>
                <span class="c1"># INFO(ArrayManager) by default copy the 2D input array to get</span>
                <span class="c1"># contiguous 1D arrays</span>
                <span class="n">copy</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">using_copy_on_write</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">Index</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">Series</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">copy</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">index</span> <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">default_index</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span> <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">default_index</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pandas_dtype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">BlockManager</span><span class="p">,</span> <span class="n">ArrayManager</span><span class="p">)):</span>
            <span class="n">mgr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_init_mgr</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">index</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">:</span> <span class="n">columns</span><span class="p">},</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># GH#38939 de facto copy defaults to False only in non-dict cases</span>
            <span class="n">mgr</span> <span class="o">=</span> <span class="n">dict_to_mgr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">numpy.ma</span> <span class="kn">import</span> <span class="n">mrecords</span>

            <span class="c1"># masked recarray</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mrecords</span><span class="o">.</span><span class="n">MaskedRecords</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;MaskedRecords are not supported. Pass &quot;</span>
                    <span class="s2">&quot;{name: data[name] for name in data.dtype.names} &quot;</span>
                    <span class="s2">&quot;instead&quot;</span>
                <span class="p">)</span>

            <span class="c1"># a masked array</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">sanitize_masked_array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">mgr</span> <span class="o">=</span> <span class="n">ndarray_to_mgr</span><span class="p">(</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">index</span><span class="p">,</span>
                <span class="n">columns</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                <span class="n">typ</span><span class="o">=</span><span class="n">manager</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Series</span><span class="p">,</span> <span class="n">Index</span><span class="p">,</span> <span class="n">ExtensionArray</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="c1"># i.e. numpy structured array</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
                <span class="n">mgr</span> <span class="o">=</span> <span class="n">rec_array_to_mgr</span><span class="p">(</span>
                    <span class="n">data</span><span class="p">,</span>
                    <span class="n">index</span><span class="p">,</span>
                    <span class="n">columns</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="p">,</span>
                    <span class="n">copy</span><span class="p">,</span>
                    <span class="n">typ</span><span class="o">=</span><span class="n">manager</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># i.e. Series/Index with non-None name</span>
                <span class="n">_copy</span> <span class="o">=</span> <span class="n">copy</span> <span class="k">if</span> <span class="n">using_copy_on_write</span><span class="p">()</span> <span class="k">else</span> <span class="kc">True</span>
                <span class="n">mgr</span> <span class="o">=</span> <span class="n">dict_to_mgr</span><span class="p">(</span>
                    <span class="c1"># error: Item &quot;ndarray&quot; of &quot;Union[ndarray, Series, Index]&quot; has no</span>
                    <span class="c1"># attribute &quot;name&quot;</span>
                    <span class="p">{</span><span class="n">data</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">data</span><span class="p">},</span>  <span class="c1"># type: ignore[union-attr]</span>
                    <span class="n">index</span><span class="p">,</span>
                    <span class="n">columns</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                    <span class="n">typ</span><span class="o">=</span><span class="n">manager</span><span class="p">,</span>
                    <span class="n">copy</span><span class="o">=</span><span class="n">_copy</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mgr</span> <span class="o">=</span> <span class="n">ndarray_to_mgr</span><span class="p">(</span>
                    <span class="n">data</span><span class="p">,</span>
                    <span class="n">index</span><span class="p">,</span>
                    <span class="n">columns</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                    <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                    <span class="n">typ</span><span class="o">=</span><span class="n">manager</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="c1"># For data is list-like, or Iterable (will consume into list)</span>
        <span class="k">elif</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;__array__&quot;</span><span class="p">):</span>
                    <span class="c1"># GH#44616 big perf improvement for e.g. pytorch tensor</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_dataclass</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">dataclasses_to_dicts</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">treat_as_nested</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                    <span class="c1"># exclude ndarray as we may have cast it a few lines above</span>
                    <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">columns</span> <span class="o">=</span> <span class="n">ensure_index</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>
                    <span class="n">arrays</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">nested_data_to_arrays</span><span class="p">(</span>
                        <span class="c1"># error: Argument 3 to &quot;nested_data_to_arrays&quot; has incompatible</span>
                        <span class="c1"># type &quot;Optional[Collection[Any]]&quot;; expected &quot;Optional[Index]&quot;</span>
                        <span class="n">data</span><span class="p">,</span>
                        <span class="n">columns</span><span class="p">,</span>
                        <span class="n">index</span><span class="p">,</span>  <span class="c1"># type: ignore[arg-type]</span>
                        <span class="n">dtype</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">mgr</span> <span class="o">=</span> <span class="n">arrays_to_mgr</span><span class="p">(</span>
                        <span class="n">arrays</span><span class="p">,</span>
                        <span class="n">columns</span><span class="p">,</span>
                        <span class="n">index</span><span class="p">,</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                        <span class="n">typ</span><span class="o">=</span><span class="n">manager</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mgr</span> <span class="o">=</span> <span class="n">ndarray_to_mgr</span><span class="p">(</span>
                        <span class="n">data</span><span class="p">,</span>
                        <span class="n">index</span><span class="p">,</span>
                        <span class="n">columns</span><span class="p">,</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                        <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                        <span class="n">typ</span><span class="o">=</span><span class="n">manager</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mgr</span> <span class="o">=</span> <span class="n">dict_to_mgr</span><span class="p">(</span>
                    <span class="p">{},</span>
                    <span class="n">index</span><span class="p">,</span>
                    <span class="n">columns</span> <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">default_index</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                    <span class="n">typ</span><span class="o">=</span><span class="n">manager</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="c1"># For data is scalar</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DataFrame constructor not properly called!&quot;</span><span class="p">)</span>

            <span class="n">index</span> <span class="o">=</span> <span class="n">ensure_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="n">ensure_index</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">dtype</span><span class="p">:</span>
                <span class="n">dtype</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">infer_dtype_from_scalar</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">pandas_dtype</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># For data is a scalar extension dtype</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ExtensionDtype</span><span class="p">):</span>
                <span class="c1"># TODO(EA2D): special case not needed with 2D EAs</span>

                <span class="n">values</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">construct_1d_arraylike_from_scalar</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">dtype</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">))</span>
                <span class="p">]</span>
                <span class="n">mgr</span> <span class="o">=</span> <span class="n">arrays_to_mgr</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arr2d</span> <span class="o">=</span> <span class="n">construct_2d_arraylike_from_scalar</span><span class="p">(</span>
                    <span class="n">data</span><span class="p">,</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">),</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">),</span>
                    <span class="n">dtype</span><span class="p">,</span>
                    <span class="n">copy</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="n">mgr</span> <span class="o">=</span> <span class="n">ndarray_to_mgr</span><span class="p">(</span>
                    <span class="n">arr2d</span><span class="p">,</span>
                    <span class="n">index</span><span class="p">,</span>
                    <span class="n">columns</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">arr2d</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                    <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">typ</span><span class="o">=</span><span class="n">manager</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="c1"># ensure correct Manager type according to settings</span>
        <span class="n">mgr</span> <span class="o">=</span> <span class="n">mgr_to_mgr</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>

        <span class="n">NDFrame</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mgr</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">__dataframe__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">nan_as_null</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">allow_copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrameXchg</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the dataframe interchange object implementing the interchange protocol.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nan_as_null : bool, default False</span>
<span class="sd">            Whether to tell the DataFrame to overwrite null values in the data</span>
<span class="sd">            with ``NaN`` (or ``NaT``).</span>
<span class="sd">        allow_copy : bool, default True</span>
<span class="sd">            Whether to allow memory copying when exporting. If set to False</span>
<span class="sd">            it would cause non-zero-copy exports to fail.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame interchange object</span>
<span class="sd">            The object which consuming library can use to ingress the dataframe.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Details on the interchange protocol:</span>
<span class="sd">        https://data-apis.org/dataframe-protocol/latest/index.html</span>

<span class="sd">        `nan_as_null` currently has no effect; once support for nullable extension</span>
<span class="sd">        dtypes is added, this value should be propagated to columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">pandas.core.interchange.dataframe</span> <span class="kn">import</span> <span class="n">PandasDataFrameXchg</span>

        <span class="k">return</span> <span class="n">PandasDataFrameXchg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nan_as_null</span><span class="p">,</span> <span class="n">allow_copy</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">axes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Index</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list representing the axes of the DataFrame.</span>

<span class="sd">        It has the row axis labels and column axis labels as the only members.</span>
<span class="sd">        They are returned in that order.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;col1&#39;: [1, 2], &#39;col2&#39;: [3, 4]})</span>
<span class="sd">        &gt;&gt;&gt; df.axes</span>
<span class="sd">        [RangeIndex(start=0, stop=2, step=1), Index([&#39;col1&#39;, &#39;col2&#39;],</span>
<span class="sd">        dtype=&#39;object&#39;)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a tuple representing the dimensionality of the DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ndarray.shape : Tuple of array dimensions.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;col1&#39;: [1, 2], &#39;col2&#39;: [3, 4]})</span>
<span class="sd">        &gt;&gt;&gt; df.shape</span>
<span class="sd">        (2, 2)</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;col1&#39;: [1, 2], &#39;col2&#39;: [3, 4],</span>
<span class="sd">        ...                    &#39;col3&#39;: [5, 6]})</span>
<span class="sd">        &gt;&gt;&gt; df.shape</span>
<span class="sd">        (2, 3)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_homogeneous_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether all the columns in a DataFrame have the same type.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index._is_homogeneous_type : Whether the object has a single</span>
<span class="sd">            dtype.</span>
<span class="sd">        MultiIndex._is_homogeneous_type : Whether all the levels of a</span>
<span class="sd">            MultiIndex have the same dtype.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; DataFrame({&quot;A&quot;: [1, 2], &quot;B&quot;: [3, 4]})._is_homogeneous_type</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; DataFrame({&quot;A&quot;: [1, 2], &quot;B&quot;: [3.0, 4.0]})._is_homogeneous_type</span>
<span class="sd">        False</span>

<span class="sd">        Items with the same type but different sizes are considered</span>
<span class="sd">        different types.</span>

<span class="sd">        &gt;&gt;&gt; DataFrame({</span>
<span class="sd">        ...    &quot;A&quot;: np.array([1, 2], dtype=np.int32),</span>
<span class="sd">        ...    &quot;B&quot;: np.array([1, 2], dtype=np.int64)})._is_homogeneous_type</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="p">,</span> <span class="n">ArrayManager</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">({</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">arrays</span><span class="p">})</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">any_extension_types</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">({</span><span class="n">block</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">blocks</span><span class="p">})</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_mixed_type</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_can_fast_transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Can we transpose this DataFrame without creating any new array objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="p">,</span> <span class="n">ArrayManager</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">blocks</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span>
        <span class="c1"># TODO(EA2D) special case would be unnecessary with 2D EAs</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">is_1d_only_ea_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">DatetimeArray</span> <span class="o">|</span> <span class="n">TimedeltaArray</span> <span class="o">|</span> <span class="n">PeriodArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analogue to ._values that may return a 2D ExtensionArray.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mgr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="n">ArrayManager</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mgr</span><span class="o">.</span><span class="n">arrays</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_1d_only_ea_dtype</span><span class="p">(</span><span class="n">mgr</span><span class="o">.</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="c1"># error: Item &quot;ExtensionArray&quot; of &quot;Union[ndarray, ExtensionArray]&quot;</span>
                <span class="c1"># has no attribute &quot;reshape&quot;</span>
                <span class="k">return</span> <span class="n">mgr</span><span class="o">.</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># type: ignore[union-attr]</span>
            <span class="k">return</span> <span class="n">ensure_wrapped_if_datetimelike</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="n">blocks</span> <span class="o">=</span> <span class="n">mgr</span><span class="o">.</span><span class="n">blocks</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ensure_wrapped_if_datetimelike</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="n">arr</span> <span class="o">=</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># non-2D ExtensionArray</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># more generally, whatever we allow in NDArrayBackedExtensionBlock</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="s2">&quot;np.ndarray | DatetimeArray | TimedeltaArray | PeriodArray&quot;</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">T</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Rendering Methods</span>

    <span class="k">def</span> <span class="nf">_repr_fits_vertical_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check length against max_rows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_rows</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.max_rows&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_rows</span>

    <span class="k">def</span> <span class="nf">_repr_fits_horizontal_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore_width</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if full repr fits in horizontal boundaries imposed by the display</span>
<span class="sd">        options width and max_columns.</span>

<span class="sd">        In case of non-interactive session, no boundaries apply.</span>

<span class="sd">        `ignore_width` is here so ipynb+HTML output can behave the way</span>
<span class="sd">        users expect. display.max_columns remains in effect.</span>
<span class="sd">        GH3541, GH3573</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">console</span><span class="o">.</span><span class="n">get_console_size</span><span class="p">()</span>
        <span class="n">max_columns</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.max_columns&quot;</span><span class="p">)</span>
        <span class="n">nb_columns</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

        <span class="c1"># exceed max columns</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">max_columns</span> <span class="ow">and</span> <span class="n">nb_columns</span> <span class="o">&gt;</span> <span class="n">max_columns</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="p">(</span><span class="ow">not</span> <span class="n">ignore_width</span><span class="p">)</span> <span class="ow">and</span> <span class="n">width</span> <span class="ow">and</span> <span class="n">nb_columns</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">width</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># used by repr_html under IPython notebook or scripts ignore terminal</span>
        <span class="c1"># dims</span>
        <span class="k">if</span> <span class="n">ignore_width</span> <span class="ow">or</span> <span class="n">width</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">console</span><span class="o">.</span><span class="n">in_interactive_session</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.width&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">console</span><span class="o">.</span><span class="n">in_ipython_frontend</span><span class="p">():</span>
            <span class="c1"># check at least the column row for excessive width</span>
            <span class="n">max_rows</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_rows</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.max_rows&quot;</span><span class="p">)</span>

        <span class="c1"># when auto-detecting, so width=None and not in ipython front end</span>
        <span class="c1"># check whether repr fits horizontal by actually checking</span>
        <span class="c1"># the width of the rendered repr</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>

        <span class="c1"># only care about the stuff we&#39;ll actually print out</span>
        <span class="c1"># and to_string on entire frame may be expensive</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">max_rows</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># unlimited rows</span>
            <span class="c1"># min of two, where one may be None</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span> <span class="nb">min</span><span class="p">(</span><span class="n">max_rows</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">d</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">buf</span><span class="o">=</span><span class="n">buf</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">buf</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
        <span class="n">repr_width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">repr_width</span> <span class="o">&lt;</span> <span class="n">width</span>

    <span class="k">def</span> <span class="nf">_info_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        True if the repr should show the info view.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">info_repr_option</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.large_repr&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;info&quot;</span>
        <span class="k">return</span> <span class="n">info_repr_option</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_repr_fits_horizontal_</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repr_fits_vertical_</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string representation for a particular DataFrame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_repr</span><span class="p">():</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">buf</span><span class="o">=</span><span class="n">buf</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">buf</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>

        <span class="n">repr_params</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">get_dataframe_repr_params</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="o">**</span><span class="n">repr_params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_html_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a html representation for a particular DataFrame.</span>

<span class="sd">        Mainly for IPython notebook.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_repr</span><span class="p">():</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">buf</span><span class="o">=</span><span class="n">buf</span><span class="p">)</span>
            <span class="c1"># need to escape the &lt;class&gt;, should be the first line.</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">buf</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;&amp;lt;&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;&amp;gt;&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;pre&gt;</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&lt;/pre&gt;&quot;</span>

        <span class="k">if</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.notebook_repr_html&quot;</span><span class="p">):</span>
            <span class="n">max_rows</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.max_rows&quot;</span><span class="p">)</span>
            <span class="n">min_rows</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.min_rows&quot;</span><span class="p">)</span>
            <span class="n">max_cols</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.max_columns&quot;</span><span class="p">)</span>
            <span class="n">show_dimensions</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.show_dimensions&quot;</span><span class="p">)</span>

            <span class="n">formatter</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">DataFrameFormatter</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">col_space</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">na_rep</span><span class="o">=</span><span class="s2">&quot;NaN&quot;</span><span class="p">,</span>
                <span class="n">formatters</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">float_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">sparsify</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">justify</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">index_names</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">bold_rows</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">escape</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">max_rows</span><span class="o">=</span><span class="n">max_rows</span><span class="p">,</span>
                <span class="n">min_rows</span><span class="o">=</span><span class="n">min_rows</span><span class="p">,</span>
                <span class="n">max_cols</span><span class="o">=</span><span class="n">max_cols</span><span class="p">,</span>
                <span class="n">show_dimensions</span><span class="o">=</span><span class="n">show_dimensions</span><span class="p">,</span>
                <span class="n">decimal</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">DataFrameRenderer</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span><span class="o">.</span><span class="n">to_html</span><span class="p">(</span><span class="n">notebook</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">buf</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">col_space</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">header</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">na_rep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">formatters</span><span class="p">:</span> <span class="n">fmt</span><span class="o">.</span><span class="n">FormattersType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">float_format</span><span class="p">:</span> <span class="n">fmt</span><span class="o">.</span><span class="n">FloatFormatType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">sparsify</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">index_names</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">justify</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">max_rows</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">max_cols</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">show_dimensions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">decimal</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">line_width</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">min_rows</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">max_colwidth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">buf</span><span class="p">:</span> <span class="n">FilePath</span> <span class="o">|</span> <span class="n">WriteBuffer</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">col_space</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">header</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">na_rep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">formatters</span><span class="p">:</span> <span class="n">fmt</span><span class="o">.</span><span class="n">FormattersType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">float_format</span><span class="p">:</span> <span class="n">fmt</span><span class="o">.</span><span class="n">FloatFormatType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">sparsify</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">index_names</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">justify</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">max_rows</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">max_cols</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">show_dimensions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">decimal</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">line_width</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">min_rows</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">max_colwidth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@Substitution</span><span class="p">(</span>
        <span class="n">header_type</span><span class="o">=</span><span class="s2">&quot;bool or sequence of str&quot;</span><span class="p">,</span>
        <span class="n">header</span><span class="o">=</span><span class="s2">&quot;Write out the column names. If a list of strings &quot;</span>
        <span class="s2">&quot;is given, it is assumed to be aliases for the &quot;</span>
        <span class="s2">&quot;column names&quot;</span><span class="p">,</span>
        <span class="n">col_space_type</span><span class="o">=</span><span class="s2">&quot;int, list or dict of int&quot;</span><span class="p">,</span>
        <span class="n">col_space</span><span class="o">=</span><span class="s2">&quot;The minimum width of each column. If a list of ints is given &quot;</span>
        <span class="s2">&quot;every integers corresponds with one column. If a dict is given, the key &quot;</span>
        <span class="s2">&quot;references the column, while the value defines the space to use.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="nd">@Substitution</span><span class="p">(</span><span class="n">shared_params</span><span class="o">=</span><span class="n">fmt</span><span class="o">.</span><span class="n">common_docstring</span><span class="p">,</span> <span class="n">returns</span><span class="o">=</span><span class="n">fmt</span><span class="o">.</span><span class="n">return_docstring</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">buf</span><span class="p">:</span> <span class="n">FilePath</span> <span class="o">|</span> <span class="n">WriteBuffer</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">col_space</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">header</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">na_rep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NaN&quot;</span><span class="p">,</span>
        <span class="n">formatters</span><span class="p">:</span> <span class="n">fmt</span><span class="o">.</span><span class="n">FormattersType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">float_format</span><span class="p">:</span> <span class="n">fmt</span><span class="o">.</span><span class="n">FloatFormatType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sparsify</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">index_names</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">justify</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_rows</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_cols</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">show_dimensions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">decimal</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span>
        <span class="n">line_width</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">min_rows</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_colwidth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Render a DataFrame to a console-friendly tabular output.</span>
<span class="sd">        %(shared_params)s</span>
<span class="sd">        line_width : int, optional</span>
<span class="sd">            Width to wrap a line in characters.</span>
<span class="sd">        min_rows : int, optional</span>
<span class="sd">            The number of rows to display in the console in a truncated repr</span>
<span class="sd">            (when number of rows is above `max_rows`).</span>
<span class="sd">        max_colwidth : int, optional</span>
<span class="sd">            Max width to truncate each column in characters. By default, no limit.</span>
<span class="sd">        encoding : str, default &quot;utf-8&quot;</span>
<span class="sd">            Set character encoding.</span>
<span class="sd">        %(returns)s</span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        to_html : Convert DataFrame to HTML.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; d = {&#39;col1&#39;: [1, 2, 3], &#39;col2&#39;: [4, 5, 6]}</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(d)</span>
<span class="sd">        &gt;&gt;&gt; print(df.to_string())</span>
<span class="sd">           col1  col2</span>
<span class="sd">        0     1     4</span>
<span class="sd">        1     2     5</span>
<span class="sd">        2     3     6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas</span> <span class="kn">import</span> <span class="n">option_context</span>

        <span class="k">with</span> <span class="n">option_context</span><span class="p">(</span><span class="s2">&quot;display.max_colwidth&quot;</span><span class="p">,</span> <span class="n">max_colwidth</span><span class="p">):</span>
            <span class="n">formatter</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">DataFrameFormatter</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
                <span class="n">col_space</span><span class="o">=</span><span class="n">col_space</span><span class="p">,</span>
                <span class="n">na_rep</span><span class="o">=</span><span class="n">na_rep</span><span class="p">,</span>
                <span class="n">formatters</span><span class="o">=</span><span class="n">formatters</span><span class="p">,</span>
                <span class="n">float_format</span><span class="o">=</span><span class="n">float_format</span><span class="p">,</span>
                <span class="n">sparsify</span><span class="o">=</span><span class="n">sparsify</span><span class="p">,</span>
                <span class="n">justify</span><span class="o">=</span><span class="n">justify</span><span class="p">,</span>
                <span class="n">index_names</span><span class="o">=</span><span class="n">index_names</span><span class="p">,</span>
                <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
                <span class="n">min_rows</span><span class="o">=</span><span class="n">min_rows</span><span class="p">,</span>
                <span class="n">max_rows</span><span class="o">=</span><span class="n">max_rows</span><span class="p">,</span>
                <span class="n">max_cols</span><span class="o">=</span><span class="n">max_cols</span><span class="p">,</span>
                <span class="n">show_dimensions</span><span class="o">=</span><span class="n">show_dimensions</span><span class="p">,</span>
                <span class="n">decimal</span><span class="o">=</span><span class="n">decimal</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">DataFrameRenderer</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span>
                <span class="n">buf</span><span class="o">=</span><span class="n">buf</span><span class="p">,</span>
                <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
                <span class="n">line_width</span><span class="o">=</span><span class="n">line_width</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">style</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Styler</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Styler object.</span>

<span class="sd">        Contains methods for building a styled HTML representation of the DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        io.formats.style.Styler : Helps style a DataFrame or Series according to the</span>
<span class="sd">            data with HTML and CSS.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io.formats.style</span> <span class="kn">import</span> <span class="n">Styler</span>

        <span class="k">return</span> <span class="n">Styler</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;items&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Iterate over (column name, Series) pairs.</span>

<span class="s2">        Iterates over the DataFrame columns, returning a tuple with</span>
<span class="s2">        the column name and the content as a Series.</span>

<span class="s2">        Yields</span>
<span class="s2">        ------</span>
<span class="s2">        label : object</span>
<span class="s2">            The column names for the DataFrame being iterated over.</span>
<span class="s2">        content : Series</span>
<span class="s2">            The column entries belonging to each label, as a Series.</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        DataFrame.iterrows : Iterate over DataFrame rows as</span>
<span class="s2">            (index, Series) pairs.</span>
<span class="s2">        DataFrame.itertuples : Iterate over DataFrame rows as namedtuples</span>
<span class="s2">            of the values.</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>
<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame({&#39;species&#39;: [&#39;bear&#39;, &#39;bear&#39;, &#39;marsupial&#39;],</span>
<span class="s2">        ...                   &#39;population&#39;: [1864, 22000, 80000]},</span>
<span class="s2">        ...                   index=[&#39;panda&#39;, &#39;polar&#39;, &#39;koala&#39;])</span>
<span class="s2">        &gt;&gt;&gt; df</span>
<span class="s2">                species   population</span>
<span class="s2">        panda   bear      1864</span>
<span class="s2">        polar   bear      22000</span>
<span class="s2">        koala   marsupial 80000</span>
<span class="s2">        &gt;&gt;&gt; for label, content in df.items():</span>
<span class="s2">        ...     print(f&#39;label: </span><span class="si">{label}</span><span class="s2">&#39;)</span>
<span class="s2">        ...     print(f&#39;content: </span><span class="si">{content}</span><span class="s2">&#39;, sep=&#39;\n&#39;)</span>
<span class="s2">        ...</span>
<span class="s2">        label: species</span>
<span class="s2">        content:</span>
<span class="s2">        panda         bear</span>
<span class="s2">        polar         bear</span>
<span class="s2">        koala    marsupial</span>
<span class="s2">        Name: species, dtype: object</span>
<span class="s2">        label: population</span>
<span class="s2">        content:</span>
<span class="s2">        panda     1864</span>
<span class="s2">        polar    22000</span>
<span class="s2">        koala    80000</span>
<span class="s2">        Name: population, dtype: int64</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;items&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Series</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">is_unique</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_item_cache&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_item_cache</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ixs</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iterrows</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="n">Series</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over DataFrame rows as (index, Series) pairs.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        index : label or tuple of label</span>
<span class="sd">            The index of the row. A tuple for a `MultiIndex`.</span>
<span class="sd">        data : Series</span>
<span class="sd">            The data of the row as a Series.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.itertuples : Iterate over DataFrame rows as namedtuples of the values.</span>
<span class="sd">        DataFrame.items : Iterate over (column name, Series) pairs.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        1. Because ``iterrows`` returns a Series for each row,</span>
<span class="sd">           it does **not** preserve dtypes across the rows (dtypes are</span>
<span class="sd">           preserved across columns for DataFrames). For example,</span>

<span class="sd">           &gt;&gt;&gt; df = pd.DataFrame([[1, 1.5]], columns=[&#39;int&#39;, &#39;float&#39;])</span>
<span class="sd">           &gt;&gt;&gt; row = next(df.iterrows())[1]</span>
<span class="sd">           &gt;&gt;&gt; row</span>
<span class="sd">           int      1.0</span>
<span class="sd">           float    1.5</span>
<span class="sd">           Name: 0, dtype: float64</span>
<span class="sd">           &gt;&gt;&gt; print(row[&#39;int&#39;].dtype)</span>
<span class="sd">           float64</span>
<span class="sd">           &gt;&gt;&gt; print(df[&#39;int&#39;].dtype)</span>
<span class="sd">           int64</span>

<span class="sd">           To preserve dtypes while iterating over the rows, it is better</span>
<span class="sd">           to use :meth:`itertuples` which returns namedtuples of the values</span>
<span class="sd">           and which is generally faster than ``iterrows``.</span>

<span class="sd">        2. You should **never modify** something you are iterating over.</span>
<span class="sd">           This is not guaranteed to work in all cases. Depending on the</span>
<span class="sd">           data types, the iterator returns a copy and not a view, and writing</span>
<span class="sd">           to it will have no effect.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">klass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span>
        <span class="n">using_cow</span> <span class="o">=</span> <span class="n">using_copy_on_write</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">klass</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">using_cow</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">is_single_block</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">add_references</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
            <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">itertuples</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="s2">&quot;Pandas&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over DataFrame rows as namedtuples.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : bool, default True</span>
<span class="sd">            If True, return the index as the first element of the tuple.</span>
<span class="sd">        name : str or None, default &quot;Pandas&quot;</span>
<span class="sd">            The name of the returned namedtuples or None to return regular</span>
<span class="sd">            tuples.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        iterator</span>
<span class="sd">            An object to iterate over namedtuples for each row in the</span>
<span class="sd">            DataFrame with the first field possibly being the index and</span>
<span class="sd">            following fields being the column values.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.iterrows : Iterate over DataFrame rows as (index, Series)</span>
<span class="sd">            pairs.</span>
<span class="sd">        DataFrame.items : Iterate over (column name, Series) pairs.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The column names will be renamed to positional names if they are</span>
<span class="sd">        invalid Python identifiers, repeated, or start with an underscore.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;num_legs&#39;: [4, 2], &#39;num_wings&#39;: [0, 2]},</span>
<span class="sd">        ...                   index=[&#39;dog&#39;, &#39;hawk&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">              num_legs  num_wings</span>
<span class="sd">        dog          4          0</span>
<span class="sd">        hawk         2          2</span>
<span class="sd">        &gt;&gt;&gt; for row in df.itertuples():</span>
<span class="sd">        ...     print(row)</span>
<span class="sd">        ...</span>
<span class="sd">        Pandas(Index=&#39;dog&#39;, num_legs=4, num_wings=0)</span>
<span class="sd">        Pandas(Index=&#39;hawk&#39;, num_legs=2, num_wings=2)</span>

<span class="sd">        By setting the `index` parameter to False we can remove the index</span>
<span class="sd">        as the first element of the tuple:</span>

<span class="sd">        &gt;&gt;&gt; for row in df.itertuples(index=False):</span>
<span class="sd">        ...     print(row)</span>
<span class="sd">        ...</span>
<span class="sd">        Pandas(num_legs=4, num_wings=0)</span>
<span class="sd">        Pandas(num_legs=2, num_wings=2)</span>

<span class="sd">        With the `name` parameter set we set a custom name for the yielded</span>
<span class="sd">        namedtuples:</span>

<span class="sd">        &gt;&gt;&gt; for row in df.itertuples(name=&#39;Animal&#39;):</span>
<span class="sd">        ...     print(row)</span>
<span class="sd">        ...</span>
<span class="sd">        Animal(Index=&#39;dog&#39;, num_legs=4, num_wings=0)</span>
<span class="sd">        Animal(Index=&#39;hawk&#39;, num_legs=2, num_wings=2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span><span class="p">:</span>
            <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="n">fields</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Index&quot;</span><span class="p">)</span>

        <span class="c1"># use integer indexing because of possible duplicate column names</span>
        <span class="n">arrays</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># https://github.com/python/mypy/issues/9046</span>
            <span class="c1"># error: namedtuple() expects a string literal as the first argument</span>
            <span class="n">itertuple</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span>  <span class="c1"># type: ignore[misc]</span>
                <span class="n">name</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">rename</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="n">itertuple</span><span class="o">.</span><span class="n">_make</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">))</span>

        <span class="c1"># fallback to regular tuples</span>
        <span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns length of info axis, but here we use the index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Series</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Index</span> <span class="o">|</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">AnyArrayLike</span> <span class="o">|</span> <span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the matrix multiplication between the DataFrame and other.</span>

<span class="sd">        This method computes the matrix product between the DataFrame and the</span>
<span class="sd">        values of an other Series, DataFrame or a numpy array.</span>

<span class="sd">        It can also be called using ``self @ other`` in Python &gt;= 3.5.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Series, DataFrame or array-like</span>
<span class="sd">            The other object to compute the matrix product with.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            If other is a Series, return the matrix product between self and</span>
<span class="sd">            other as a Series. If other is a DataFrame or a numpy.array, return</span>
<span class="sd">            the matrix product of self and other in a DataFrame of a np.array.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.dot: Similar method for Series.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The dimensions of DataFrame and other must be compatible in order to</span>
<span class="sd">        compute the matrix multiplication. In addition, the column names of</span>
<span class="sd">        DataFrame and the index of other must contain the same values, as they</span>
<span class="sd">        will be aligned prior to the multiplication.</span>

<span class="sd">        The dot method for Series computes the inner product, instead of the</span>
<span class="sd">        matrix product here.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Here we multiply a DataFrame with a Series.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([[0, 1, -2, -1], [1, 1, 1, 1]])</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 1, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; df.dot(s)</span>
<span class="sd">        0    -4</span>
<span class="sd">        1     5</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Here we multiply a DataFrame with another DataFrame.</span>

<span class="sd">        &gt;&gt;&gt; other = pd.DataFrame([[0, 1], [1, 2], [-1, -1], [2, 0]])</span>
<span class="sd">        &gt;&gt;&gt; df.dot(other)</span>
<span class="sd">            0   1</span>
<span class="sd">        0   1   4</span>
<span class="sd">        1   2   2</span>

<span class="sd">        Note that the dot method give the same result as @</span>

<span class="sd">        &gt;&gt;&gt; df @ other</span>
<span class="sd">            0   1</span>
<span class="sd">        0   1   4</span>
<span class="sd">        1   2   2</span>

<span class="sd">        The dot method works also if other is an np.array.</span>

<span class="sd">        &gt;&gt;&gt; arr = np.array([[0, 1], [1, 2], [-1, -1], [2, 0]])</span>
<span class="sd">        &gt;&gt;&gt; df.dot(arr)</span>
<span class="sd">            0   1</span>
<span class="sd">        0   1   4</span>
<span class="sd">        1   2   2</span>

<span class="sd">        Note how shuffling of the objects does not change the result.</span>

<span class="sd">        &gt;&gt;&gt; s2 = s.reindex([1, 0, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; df.dot(s2)</span>
<span class="sd">        0    -4</span>
<span class="sd">        1     5</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">)):</span>
            <span class="n">common</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">common</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;matrices are not aligned&quot;</span><span class="p">)</span>

            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">common</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">common</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">lvals</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">values</span>
            <span class="n">rvals</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">_values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">lvals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>
            <span class="n">rvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">lvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">rvals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Dot product shape mismatch, </span><span class="si">{</span><span class="n">lvals</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> vs </span><span class="si">{</span><span class="n">rvals</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lvals</span><span class="p">,</span> <span class="n">rvals</span><span class="p">),</span>
                <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
                <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lvals</span><span class="p">,</span> <span class="n">rvals</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rvals</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Index</span><span class="p">)):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lvals</span><span class="p">,</span> <span class="n">rvals</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unsupported type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="fm">__matmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Series</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="fm">__matmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">AnyArrayLike</span> <span class="o">|</span> <span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Series</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="fm">__matmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">AnyArrayLike</span> <span class="o">|</span> <span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Matrix multiplication using binary `@` operator in Python&gt;=3.5.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmatmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Matrix multiplication using binary `@` operator in Python&gt;=3.5.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">other</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;shape mismatch&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">):</span>
                <span class="k">raise</span>
            <span class="c1"># GH#21581 give exception message for original shapes</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;shapes </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> not aligned&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># IO methods (to / from other formats)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">orient</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;columns&quot;</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">Dtype</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Axes</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct DataFrame from dict of array-like or dicts.</span>

<span class="sd">        Creates DataFrame object from dictionary by columns or by index</span>
<span class="sd">        allowing dtype specification.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : dict</span>
<span class="sd">            Of the form {field : array-like} or {field : dict}.</span>
<span class="sd">        orient : {&#39;columns&#39;, &#39;index&#39;, &#39;tight&#39;}, default &#39;columns&#39;</span>
<span class="sd">            The &quot;orientation&quot; of the data. If the keys of the passed dict</span>
<span class="sd">            should be the columns of the resulting DataFrame, pass &#39;columns&#39;</span>
<span class="sd">            (default). Otherwise if the keys should be rows, pass &#39;index&#39;.</span>
<span class="sd">            If &#39;tight&#39;, assume a dict with keys [&#39;index&#39;, &#39;columns&#39;, &#39;data&#39;,</span>
<span class="sd">            &#39;index_names&#39;, &#39;column_names&#39;].</span>

<span class="sd">            .. versionadded:: 1.4.0</span>
<span class="sd">               &#39;tight&#39; as an allowed value for the ``orient`` argument</span>

<span class="sd">        dtype : dtype, default None</span>
<span class="sd">            Data type to force after DataFrame construction, otherwise infer.</span>
<span class="sd">        columns : list, default None</span>
<span class="sd">            Column labels to use when ``orient=&#39;index&#39;``. Raises a ValueError</span>
<span class="sd">            if used with ``orient=&#39;columns&#39;`` or ``orient=&#39;tight&#39;``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.from_records : DataFrame from structured ndarray, sequence</span>
<span class="sd">            of tuples or dicts, or DataFrame.</span>
<span class="sd">        DataFrame : DataFrame object creation using constructor.</span>
<span class="sd">        DataFrame.to_dict : Convert the DataFrame to a dictionary.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        By default the keys of the dict become the DataFrame columns:</span>

<span class="sd">        &gt;&gt;&gt; data = {&#39;col_1&#39;: [3, 2, 1, 0], &#39;col_2&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]}</span>
<span class="sd">        &gt;&gt;&gt; pd.DataFrame.from_dict(data)</span>
<span class="sd">           col_1 col_2</span>
<span class="sd">        0      3     a</span>
<span class="sd">        1      2     b</span>
<span class="sd">        2      1     c</span>
<span class="sd">        3      0     d</span>

<span class="sd">        Specify ``orient=&#39;index&#39;`` to create the DataFrame using dictionary</span>
<span class="sd">        keys as rows:</span>

<span class="sd">        &gt;&gt;&gt; data = {&#39;row_1&#39;: [3, 2, 1, 0], &#39;row_2&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]}</span>
<span class="sd">        &gt;&gt;&gt; pd.DataFrame.from_dict(data, orient=&#39;index&#39;)</span>
<span class="sd">               0  1  2  3</span>
<span class="sd">        row_1  3  2  1  0</span>
<span class="sd">        row_2  a  b  c  d</span>

<span class="sd">        When using the &#39;index&#39; orientation, the column names can be</span>
<span class="sd">        specified manually:</span>

<span class="sd">        &gt;&gt;&gt; pd.DataFrame.from_dict(data, orient=&#39;index&#39;,</span>
<span class="sd">        ...                        columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])</span>
<span class="sd">               A  B  C  D</span>
<span class="sd">        row_1  3  2  1  0</span>
<span class="sd">        row_2  a  b  c  d</span>

<span class="sd">        Specify ``orient=&#39;tight&#39;`` to create the DataFrame using a &#39;tight&#39;</span>
<span class="sd">        format:</span>

<span class="sd">        &gt;&gt;&gt; data = {&#39;index&#39;: [(&#39;a&#39;, &#39;b&#39;), (&#39;a&#39;, &#39;c&#39;)],</span>
<span class="sd">        ...         &#39;columns&#39;: [(&#39;x&#39;, 1), (&#39;y&#39;, 2)],</span>
<span class="sd">        ...         &#39;data&#39;: [[1, 3], [2, 4]],</span>
<span class="sd">        ...         &#39;index_names&#39;: [&#39;n1&#39;, &#39;n2&#39;],</span>
<span class="sd">        ...         &#39;column_names&#39;: [&#39;z1&#39;, &#39;z2&#39;]}</span>
<span class="sd">        &gt;&gt;&gt; pd.DataFrame.from_dict(data, orient=&#39;tight&#39;)</span>
<span class="sd">        z1     x  y</span>
<span class="sd">        z2     1  2</span>
<span class="sd">        n1 n2</span>
<span class="sd">        a  b   1  3</span>
<span class="sd">           c   2  4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">orient</span> <span class="o">=</span> <span class="n">orient</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">orient</span> <span class="o">==</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># TODO speed up Series case</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">_from_nested_dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                    <span class="c1"># error: Incompatible types in assignment (expression has type</span>
                    <span class="c1"># &quot;List[Any]&quot;, variable has type &quot;Dict[Any, Any]&quot;)</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>  <span class="c1"># type: ignore[assignment]</span>
        <span class="k">elif</span> <span class="n">orient</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;columns&quot;</span><span class="p">,</span> <span class="s2">&quot;tight&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use columns parameter with orient=&#39;</span><span class="si">{</span><span class="n">orient</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected &#39;index&#39;, &#39;columns&#39; or &#39;tight&#39; for orient parameter. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Got &#39;</span><span class="si">{</span><span class="n">orient</span><span class="si">}</span><span class="s2">&#39; instead&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">orient</span> <span class="o">!=</span> <span class="s2">&quot;tight&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">realdata</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]</span>

            <span class="k">def</span> <span class="nf">create_index</span><span class="p">(</span><span class="n">indexlist</span><span class="p">,</span> <span class="n">namelist</span><span class="p">):</span>
                <span class="n">index</span><span class="p">:</span> <span class="n">Index</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">namelist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">indexlist</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">namelist</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">indexlist</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">namelist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">return</span> <span class="n">index</span>

            <span class="n">index</span> <span class="o">=</span> <span class="n">create_index</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;index_names&quot;</span><span class="p">])</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="n">create_index</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;columns&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;column_names&quot;</span><span class="p">])</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">realdata</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_numpy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">na_value</span><span class="p">:</span> <span class="nb">object</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the DataFrame to a NumPy array.</span>

<span class="sd">        By default, the dtype of the returned array will be the common NumPy</span>
<span class="sd">        dtype of all types in the DataFrame. For example, if the dtypes are</span>
<span class="sd">        ``float16`` and ``float32``, the results dtype will be ``float32``.</span>
<span class="sd">        This may require copying data and coercing values, which may be</span>
<span class="sd">        expensive.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : str or numpy.dtype, optional</span>
<span class="sd">            The dtype to pass to :meth:`numpy.asarray`.</span>
<span class="sd">        copy : bool, default False</span>
<span class="sd">            Whether to ensure that the returned value is not a view on</span>
<span class="sd">            another array. Note that ``copy=False`` does not *ensure* that</span>
<span class="sd">            ``to_numpy()`` is no-copy. Rather, ``copy=True`` ensure that</span>
<span class="sd">            a copy is made, even if not strictly necessary.</span>
<span class="sd">        na_value : Any, optional</span>
<span class="sd">            The value to use for missing values. The default value depends</span>
<span class="sd">            on `dtype` and the dtypes of the DataFrame columns.</span>

<span class="sd">            .. versionadded:: 1.1.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.to_numpy : Similar method for Series.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; pd.DataFrame({&quot;A&quot;: [1, 2], &quot;B&quot;: [3, 4]}).to_numpy()</span>
<span class="sd">        array([[1, 3],</span>
<span class="sd">               [2, 4]])</span>

<span class="sd">        With heterogeneous data, the lowest common type will have to</span>
<span class="sd">        be used.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [1, 2], &quot;B&quot;: [3.0, 4.5]})</span>
<span class="sd">        &gt;&gt;&gt; df.to_numpy()</span>
<span class="sd">        array([[1. , 3. ],</span>
<span class="sd">               [2. , 4.5]])</span>

<span class="sd">        For a mix of numeric and non-numeric types, the output array will</span>
<span class="sd">        have object dtype.</span>

<span class="sd">        &gt;&gt;&gt; df[&#39;C&#39;] = pd.date_range(&#39;2000&#39;, periods=2)</span>
<span class="sd">        &gt;&gt;&gt; df.to_numpy()</span>
<span class="sd">        array([[1, 3.0, Timestamp(&#39;2000-01-01 00:00:00&#39;)],</span>
<span class="sd">               [2, 4.5, Timestamp(&#39;2000-01-02 00:00:00&#39;)]], dtype=object)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">as_array</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">na_value</span><span class="o">=</span><span class="n">na_value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">dtype</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_create_data_for_split_and_tight_to_dict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">are_all_object_dtype_cols</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">object_dtype_indices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simple helper method to create data for to ``to_dict(orient=&quot;split&quot;)`` and</span>
<span class="sd">        ``to_dict(orient=&quot;tight&quot;)`` to create the main output data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">are_all_object_dtype_cols</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">maybe_box_native</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itertuples</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">itertuples</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">object_dtype_indices</span><span class="p">:</span>
                <span class="c1"># If we have object_dtype_cols, apply maybe_box_naive after list</span>
                <span class="c1"># comprehension for perf</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">object_dtype_indices</span><span class="p">:</span>
                        <span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">maybe_box_native</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">orient</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;dict&quot;</span><span class="p">,</span> <span class="s2">&quot;list&quot;</span><span class="p">,</span> <span class="s2">&quot;series&quot;</span><span class="p">,</span> <span class="s2">&quot;split&quot;</span><span class="p">,</span> <span class="s2">&quot;tight&quot;</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">into</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orient</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;records&quot;</span><span class="p">],</span> <span class="n">into</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">orient</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span>
            <span class="s2">&quot;dict&quot;</span><span class="p">,</span> <span class="s2">&quot;list&quot;</span><span class="p">,</span> <span class="s2">&quot;series&quot;</span><span class="p">,</span> <span class="s2">&quot;split&quot;</span><span class="p">,</span> <span class="s2">&quot;tight&quot;</span><span class="p">,</span> <span class="s2">&quot;records&quot;</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span>
        <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;dict&quot;</span><span class="p">,</span>
        <span class="n">into</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the DataFrame to a dictionary.</span>

<span class="sd">        The type of the key-value pairs can be customized with the parameters</span>
<span class="sd">        (see below).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orient : str {&#39;dict&#39;, &#39;list&#39;, &#39;series&#39;, &#39;split&#39;, &#39;tight&#39;, &#39;records&#39;, &#39;index&#39;}</span>
<span class="sd">            Determines the type of the values of the dictionary.</span>

<span class="sd">            - &#39;dict&#39; (default) : dict like {column -&gt; {index -&gt; value}}</span>
<span class="sd">            - &#39;list&#39; : dict like {column -&gt; [values]}</span>
<span class="sd">            - &#39;series&#39; : dict like {column -&gt; Series(values)}</span>
<span class="sd">            - &#39;split&#39; : dict like</span>
<span class="sd">              {&#39;index&#39; -&gt; [index], &#39;columns&#39; -&gt; [columns], &#39;data&#39; -&gt; [values]}</span>
<span class="sd">            - &#39;tight&#39; : dict like</span>
<span class="sd">              {&#39;index&#39; -&gt; [index], &#39;columns&#39; -&gt; [columns], &#39;data&#39; -&gt; [values],</span>
<span class="sd">              &#39;index_names&#39; -&gt; [index.names], &#39;column_names&#39; -&gt; [column.names]}</span>
<span class="sd">            - &#39;records&#39; : list like</span>
<span class="sd">              [{column -&gt; value}, ... , {column -&gt; value}]</span>
<span class="sd">            - &#39;index&#39; : dict like {index -&gt; {column -&gt; value}}</span>

<span class="sd">            .. versionadded:: 1.4.0</span>
<span class="sd">                &#39;tight&#39; as an allowed value for the ``orient`` argument</span>

<span class="sd">        into : class, default dict</span>
<span class="sd">            The collections.abc.Mapping subclass used for all Mappings</span>
<span class="sd">            in the return value.  Can be the actual class or an empty</span>
<span class="sd">            instance of the mapping type you want.  If you want a</span>
<span class="sd">            collections.defaultdict, you must pass it initialized.</span>

<span class="sd">        index : bool, default True</span>
<span class="sd">            Whether to include the index item (and index_names item if `orient`</span>
<span class="sd">            is &#39;tight&#39;) in the returned dictionary. Can only be ``False``</span>
<span class="sd">            when `orient` is &#39;split&#39; or &#39;tight&#39;.</span>

<span class="sd">            .. versionadded:: 2.0.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict, list or collections.abc.Mapping</span>
<span class="sd">            Return a collections.abc.Mapping object representing the DataFrame.</span>
<span class="sd">            The resulting transformation depends on the `orient` parameter.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.from_dict: Create a DataFrame from a dictionary.</span>
<span class="sd">        DataFrame.to_json: Convert a DataFrame to JSON format.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;col1&#39;: [1, 2],</span>
<span class="sd">        ...                    &#39;col2&#39;: [0.5, 0.75]},</span>
<span class="sd">        ...                   index=[&#39;row1&#39;, &#39;row2&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">              col1  col2</span>
<span class="sd">        row1     1  0.50</span>
<span class="sd">        row2     2  0.75</span>
<span class="sd">        &gt;&gt;&gt; df.to_dict()</span>
<span class="sd">        {&#39;col1&#39;: {&#39;row1&#39;: 1, &#39;row2&#39;: 2}, &#39;col2&#39;: {&#39;row1&#39;: 0.5, &#39;row2&#39;: 0.75}}</span>

<span class="sd">        You can specify the return orientation.</span>

<span class="sd">        &gt;&gt;&gt; df.to_dict(&#39;series&#39;)</span>
<span class="sd">        {&#39;col1&#39;: row1    1</span>
<span class="sd">                 row2    2</span>
<span class="sd">        Name: col1, dtype: int64,</span>
<span class="sd">        &#39;col2&#39;: row1    0.50</span>
<span class="sd">                row2    0.75</span>
<span class="sd">        Name: col2, dtype: float64}</span>

<span class="sd">        &gt;&gt;&gt; df.to_dict(&#39;split&#39;)</span>
<span class="sd">        {&#39;index&#39;: [&#39;row1&#39;, &#39;row2&#39;], &#39;columns&#39;: [&#39;col1&#39;, &#39;col2&#39;],</span>
<span class="sd">         &#39;data&#39;: [[1, 0.5], [2, 0.75]]}</span>

<span class="sd">        &gt;&gt;&gt; df.to_dict(&#39;records&#39;)</span>
<span class="sd">        [{&#39;col1&#39;: 1, &#39;col2&#39;: 0.5}, {&#39;col1&#39;: 2, &#39;col2&#39;: 0.75}]</span>

<span class="sd">        &gt;&gt;&gt; df.to_dict(&#39;index&#39;)</span>
<span class="sd">        {&#39;row1&#39;: {&#39;col1&#39;: 1, &#39;col2&#39;: 0.5}, &#39;row2&#39;: {&#39;col1&#39;: 2, &#39;col2&#39;: 0.75}}</span>

<span class="sd">        &gt;&gt;&gt; df.to_dict(&#39;tight&#39;)</span>
<span class="sd">        {&#39;index&#39;: [&#39;row1&#39;, &#39;row2&#39;], &#39;columns&#39;: [&#39;col1&#39;, &#39;col2&#39;],</span>
<span class="sd">         &#39;data&#39;: [[1, 0.5], [2, 0.75]], &#39;index_names&#39;: [None], &#39;column_names&#39;: [None]}</span>

<span class="sd">        You can also specify the mapping type.</span>

<span class="sd">        &gt;&gt;&gt; from collections import OrderedDict, defaultdict</span>
<span class="sd">        &gt;&gt;&gt; df.to_dict(into=OrderedDict)</span>
<span class="sd">        OrderedDict([(&#39;col1&#39;, OrderedDict([(&#39;row1&#39;, 1), (&#39;row2&#39;, 2)])),</span>
<span class="sd">                     (&#39;col2&#39;, OrderedDict([(&#39;row1&#39;, 0.5), (&#39;row2&#39;, 0.75)]))])</span>

<span class="sd">        If you want a `defaultdict`, you need to initialize it:</span>

<span class="sd">        &gt;&gt;&gt; dd = defaultdict(list)</span>
<span class="sd">        &gt;&gt;&gt; df.to_dict(&#39;records&#39;, into=dd)</span>
<span class="sd">        [defaultdict(&lt;class &#39;list&#39;&gt;, {&#39;col1&#39;: 1, &#39;col2&#39;: 0.5}),</span>
<span class="sd">         defaultdict(&lt;class &#39;list&#39;&gt;, {&#39;col1&#39;: 2, &#39;col2&#39;: 0.75})]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.methods.to_dict</span> <span class="kn">import</span> <span class="n">to_dict</span>

        <span class="k">return</span> <span class="n">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orient</span><span class="p">,</span> <span class="n">into</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_gbq</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">destination_table</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">project_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">chunksize</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">reauth</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">if_exists</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;fail&quot;</span><span class="p">,</span>
        <span class="n">auth_local_webserver</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">table_schema</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">location</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">progress_bar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">credentials</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write a DataFrame to a Google BigQuery table.</span>

<span class="sd">        This function requires the `pandas-gbq package</span>
<span class="sd">        &lt;https://pandas-gbq.readthedocs.io&gt;`__.</span>

<span class="sd">        See the `How to authenticate with Google BigQuery</span>
<span class="sd">        &lt;https://pandas-gbq.readthedocs.io/en/latest/howto/authentication.html&gt;`__</span>
<span class="sd">        guide for authentication instructions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        destination_table : str</span>
<span class="sd">            Name of table to be written, in the form ``dataset.tablename``.</span>
<span class="sd">        project_id : str, optional</span>
<span class="sd">            Google BigQuery Account project ID. Optional when available from</span>
<span class="sd">            the environment.</span>
<span class="sd">        chunksize : int, optional</span>
<span class="sd">            Number of rows to be inserted in each chunk from the dataframe.</span>
<span class="sd">            Set to ``None`` to load the whole dataframe at once.</span>
<span class="sd">        reauth : bool, default False</span>
<span class="sd">            Force Google BigQuery to re-authenticate the user. This is useful</span>
<span class="sd">            if multiple accounts are used.</span>
<span class="sd">        if_exists : str, default &#39;fail&#39;</span>
<span class="sd">            Behavior when the destination table exists. Value can be one of:</span>

<span class="sd">            ``&#39;fail&#39;``</span>
<span class="sd">                If table exists raise pandas_gbq.gbq.TableCreationError.</span>
<span class="sd">            ``&#39;replace&#39;``</span>
<span class="sd">                If table exists, drop it, recreate it, and insert data.</span>
<span class="sd">            ``&#39;append&#39;``</span>
<span class="sd">                If table exists, insert data. Create if does not exist.</span>
<span class="sd">        auth_local_webserver : bool, default True</span>
<span class="sd">            Use the `local webserver flow`_ instead of the `console flow`_</span>
<span class="sd">            when getting user credentials.</span>

<span class="sd">            .. _local webserver flow:</span>
<span class="sd">                https://google-auth-oauthlib.readthedocs.io/en/latest/reference/google_auth_oauthlib.flow.html#google_auth_oauthlib.flow.InstalledAppFlow.run_local_server</span>
<span class="sd">            .. _console flow:</span>
<span class="sd">                https://google-auth-oauthlib.readthedocs.io/en/latest/reference/google_auth_oauthlib.flow.html#google_auth_oauthlib.flow.InstalledAppFlow.run_console</span>

<span class="sd">            *New in version 0.2.0 of pandas-gbq*.</span>

<span class="sd">            .. versionchanged:: 1.5.0</span>
<span class="sd">               Default value is changed to ``True``. Google has deprecated the</span>
<span class="sd">               ``auth_local_webserver = False`` `&quot;out of band&quot; (copy-paste)</span>
<span class="sd">               flow</span>
<span class="sd">               &lt;https://developers.googleblog.com/2022/02/making-oauth-flows-safer.html?m=1#disallowed-oob&gt;`_.</span>
<span class="sd">        table_schema : list of dicts, optional</span>
<span class="sd">            List of BigQuery table fields to which according DataFrame</span>
<span class="sd">            columns conform to, e.g. ``[{&#39;name&#39;: &#39;col1&#39;, &#39;type&#39;:</span>
<span class="sd">            &#39;STRING&#39;},...]``. If schema is not provided, it will be</span>
<span class="sd">            generated according to dtypes of DataFrame columns. See</span>
<span class="sd">            BigQuery API documentation on available names of a field.</span>

<span class="sd">            *New in version 0.3.1 of pandas-gbq*.</span>
<span class="sd">        location : str, optional</span>
<span class="sd">            Location where the load job should run. See the `BigQuery locations</span>
<span class="sd">            documentation</span>
<span class="sd">            &lt;https://cloud.google.com/bigquery/docs/dataset-locations&gt;`__ for a</span>
<span class="sd">            list of available locations. The location must match that of the</span>
<span class="sd">            target dataset.</span>

<span class="sd">            *New in version 0.5.0 of pandas-gbq*.</span>
<span class="sd">        progress_bar : bool, default True</span>
<span class="sd">            Use the library `tqdm` to show the progress bar for the upload,</span>
<span class="sd">            chunk by chunk.</span>

<span class="sd">            *New in version 0.5.0 of pandas-gbq*.</span>
<span class="sd">        credentials : google.auth.credentials.Credentials, optional</span>
<span class="sd">            Credentials for accessing Google APIs. Use this parameter to</span>
<span class="sd">            override default credentials, such as to use Compute Engine</span>
<span class="sd">            :class:`google.auth.compute_engine.Credentials` or Service</span>
<span class="sd">            Account :class:`google.oauth2.service_account.Credentials`</span>
<span class="sd">            directly.</span>

<span class="sd">            *New in version 0.8.0 of pandas-gbq*.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pandas_gbq.to_gbq : This function in the pandas-gbq library.</span>
<span class="sd">        read_gbq : Read a DataFrame from Google BigQuery.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io</span> <span class="kn">import</span> <span class="n">gbq</span>

        <span class="n">gbq</span><span class="o">.</span><span class="n">to_gbq</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">destination_table</span><span class="p">,</span>
            <span class="n">project_id</span><span class="o">=</span><span class="n">project_id</span><span class="p">,</span>
            <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span>
            <span class="n">reauth</span><span class="o">=</span><span class="n">reauth</span><span class="p">,</span>
            <span class="n">if_exists</span><span class="o">=</span><span class="n">if_exists</span><span class="p">,</span>
            <span class="n">auth_local_webserver</span><span class="o">=</span><span class="n">auth_local_webserver</span><span class="p">,</span>
            <span class="n">table_schema</span><span class="o">=</span><span class="n">table_schema</span><span class="p">,</span>
            <span class="n">location</span><span class="o">=</span><span class="n">location</span><span class="p">,</span>
            <span class="n">progress_bar</span><span class="o">=</span><span class="n">progress_bar</span><span class="p">,</span>
            <span class="n">credentials</span><span class="o">=</span><span class="n">credentials</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_records</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">coerce_float</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">nrows</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert structured or record ndarray to DataFrame.</span>

<span class="sd">        Creates a DataFrame object from a structured ndarray, sequence of</span>
<span class="sd">        tuples or dicts, or DataFrame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : structured ndarray, sequence of tuples or dicts, or DataFrame</span>
<span class="sd">            Structured input data.</span>
<span class="sd">        index : str, list of fields, array-like</span>
<span class="sd">            Field of array to use as the index, alternately a specific set of</span>
<span class="sd">            input labels to use.</span>
<span class="sd">        exclude : sequence, default None</span>
<span class="sd">            Columns or fields to exclude.</span>
<span class="sd">        columns : sequence, default None</span>
<span class="sd">            Column names to use. If the passed data do not have names</span>
<span class="sd">            associated with them, this argument provides names for the</span>
<span class="sd">            columns. Otherwise this argument indicates the order of the columns</span>
<span class="sd">            in the result (any names not found in the data will become all-NA</span>
<span class="sd">            columns).</span>
<span class="sd">        coerce_float : bool, default False</span>
<span class="sd">            Attempt to convert values of non-string, non-numeric objects (like</span>
<span class="sd">            decimal.Decimal) to floating point, useful for SQL result sets.</span>
<span class="sd">        nrows : int, default None</span>
<span class="sd">            Number of rows to read if data is an iterator.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.from_dict : DataFrame from dict of array-like or dicts.</span>
<span class="sd">        DataFrame : DataFrame object creation using constructor.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Data can be provided as a structured ndarray:</span>

<span class="sd">        &gt;&gt;&gt; data = np.array([(3, &#39;a&#39;), (2, &#39;b&#39;), (1, &#39;c&#39;), (0, &#39;d&#39;)],</span>
<span class="sd">        ...                 dtype=[(&#39;col_1&#39;, &#39;i4&#39;), (&#39;col_2&#39;, &#39;U1&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; pd.DataFrame.from_records(data)</span>
<span class="sd">           col_1 col_2</span>
<span class="sd">        0      3     a</span>
<span class="sd">        1      2     b</span>
<span class="sd">        2      1     c</span>
<span class="sd">        3      0     d</span>

<span class="sd">        Data can be provided as a list of dicts:</span>

<span class="sd">        &gt;&gt;&gt; data = [{&#39;col_1&#39;: 3, &#39;col_2&#39;: &#39;a&#39;},</span>
<span class="sd">        ...         {&#39;col_1&#39;: 2, &#39;col_2&#39;: &#39;b&#39;},</span>
<span class="sd">        ...         {&#39;col_1&#39;: 1, &#39;col_2&#39;: &#39;c&#39;},</span>
<span class="sd">        ...         {&#39;col_1&#39;: 0, &#39;col_2&#39;: &#39;d&#39;}]</span>
<span class="sd">        &gt;&gt;&gt; pd.DataFrame.from_records(data)</span>
<span class="sd">           col_1 col_2</span>
<span class="sd">        0      3     a</span>
<span class="sd">        1      2     b</span>
<span class="sd">        2      1     c</span>
<span class="sd">        3      0     d</span>

<span class="sd">        Data can be provided as a list of tuples with corresponding columns:</span>

<span class="sd">        &gt;&gt;&gt; data = [(3, &#39;a&#39;), (2, &#39;b&#39;), (1, &#39;c&#39;), (0, &#39;d&#39;)]</span>
<span class="sd">        &gt;&gt;&gt; pd.DataFrame.from_records(data, columns=[&#39;col_1&#39;, &#39;col_2&#39;])</span>
<span class="sd">           col_1 col_2</span>
<span class="sd">        0      3     a</span>
<span class="sd">        1      2     b</span>
<span class="sd">        2      1     c</span>
<span class="sd">        3      0     d</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">columns</span><span class="p">):</span>
                    <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">columns</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">exclude</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">result_index</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Make a copy of the input columns so we can modify it</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="n">ensure_index</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">maybe_reorder</span><span class="p">(</span>
            <span class="n">arrays</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">],</span> <span class="n">arr_columns</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">columns</span><span class="p">:</span> <span class="n">Index</span><span class="p">,</span> <span class="n">index</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">],</span> <span class="n">Index</span><span class="p">,</span> <span class="n">Index</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            If our desired &#39;columns&#39; do not match the data&#39;s pre-existing &#39;arr_columns&#39;,</span>
<span class="sd">            we re-order our arrays.  This is like a pre-emptive (cheap) reindex.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
                <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">result_index</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">result_index</span> <span class="o">=</span> <span class="n">default_index</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">arrays</span><span class="p">,</span> <span class="n">arr_columns</span> <span class="o">=</span> <span class="n">reorder_arrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">arr_columns</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">arrays</span><span class="p">,</span> <span class="n">arr_columns</span><span class="p">,</span> <span class="n">result_index</span>

        <span class="k">if</span> <span class="n">is_iterator</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nrows</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="p">()</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">first_row</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>

            <span class="n">dtype</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">first_row</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">first_row</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">first_row</span><span class="o">.</span><span class="n">dtype</span>

            <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">first_row</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">nrows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">+=</span> <span class="n">data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nrows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">values</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="n">arr_columns</span> <span class="o">=</span> <span class="n">ensure_index</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
                <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arrays</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">arr_columns_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
                        <span class="n">arr_columns_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                        <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

                <span class="n">arr_columns</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">arr_columns_list</span><span class="p">)</span>
                <span class="n">arrays</span><span class="p">,</span> <span class="n">arr_columns</span><span class="p">,</span> <span class="n">result_index</span> <span class="o">=</span> <span class="n">maybe_reorder</span><span class="p">(</span>
                    <span class="n">arrays</span><span class="p">,</span> <span class="n">arr_columns</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">index</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">)):</span>
            <span class="n">arrays</span><span class="p">,</span> <span class="n">columns</span> <span class="o">=</span> <span class="n">to_arrays</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
            <span class="n">arr_columns</span> <span class="o">=</span> <span class="n">columns</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arrays</span><span class="p">,</span> <span class="n">arr_columns</span> <span class="o">=</span> <span class="n">to_arrays</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">coerce_float</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">object</span><span class="p">:</span>
                        <span class="c1"># error: Argument 1 to &quot;maybe_convert_objects&quot; has</span>
                        <span class="c1"># incompatible type &quot;Union[ExtensionArray, ndarray]&quot;;</span>
                        <span class="c1"># expected &quot;ndarray&quot;</span>
                        <span class="n">arrays</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">maybe_convert_objects</span><span class="p">(</span>
                            <span class="n">arr</span><span class="p">,</span>  <span class="c1"># type: ignore[arg-type]</span>
                            <span class="n">try_float</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                        <span class="p">)</span>

            <span class="n">arr_columns</span> <span class="o">=</span> <span class="n">ensure_index</span><span class="p">(</span><span class="n">arr_columns</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="n">arr_columns</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arrays</span><span class="p">,</span> <span class="n">arr_columns</span><span class="p">,</span> <span class="n">result_index</span> <span class="o">=</span> <span class="n">maybe_reorder</span><span class="p">(</span>
                    <span class="n">arrays</span><span class="p">,</span> <span class="n">arr_columns</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">index</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exclude</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="s2">&quot;__iter__&quot;</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                <span class="n">exclude</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">result_index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result_index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">([],</span> <span class="n">name</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">index_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">arrays</span><span class="p">[</span><span class="n">arr_columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">field</span><span class="p">)]</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">index</span><span class="p">]</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                    <span class="c1"># raised by get_loc, see GH#29258</span>
                    <span class="n">result_index</span> <span class="o">=</span> <span class="n">index</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result_index</span> <span class="o">=</span> <span class="n">ensure_index_from_sequences</span><span class="p">(</span><span class="n">index_data</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
                    <span class="n">exclude</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">exclude</span><span class="p">):</span>
            <span class="n">arr_exclude</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">exclude</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr_columns</span><span class="p">]</span>
            <span class="n">to_remove</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr_columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">arr_exclude</span><span class="p">]</span>
            <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">to_remove</span><span class="p">]</span>

            <span class="n">columns</span> <span class="o">=</span> <span class="n">columns</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">exclude</span><span class="p">)</span>

        <span class="n">manager</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;mode.data_manager&quot;</span><span class="p">)</span>
        <span class="n">mgr</span> <span class="o">=</span> <span class="n">arrays_to_mgr</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">result_index</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="n">manager</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">mgr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_records</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">column_dtypes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">index_dtypes</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert DataFrame to a NumPy record array.</span>

<span class="sd">        Index will be included as the first field of the record array if</span>
<span class="sd">        requested.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : bool, default True</span>
<span class="sd">            Include index in resulting record array, stored in &#39;index&#39;</span>
<span class="sd">            field or using the index label, if set.</span>
<span class="sd">        column_dtypes : str, type, dict, default None</span>
<span class="sd">            If a string or type, the data type to store all columns. If</span>
<span class="sd">            a dictionary, a mapping of column names and indices (zero-indexed)</span>
<span class="sd">            to specific data types.</span>
<span class="sd">        index_dtypes : str, type, dict, default None</span>
<span class="sd">            If a string or type, the data type to store all index levels. If</span>
<span class="sd">            a dictionary, a mapping of index level names and indices</span>
<span class="sd">            (zero-indexed) to specific data types.</span>

<span class="sd">            This mapping is applied only if `index=True`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.recarray</span>
<span class="sd">            NumPy ndarray with the DataFrame labels as fields and each row</span>
<span class="sd">            of the DataFrame as entries.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.from_records: Convert structured or record ndarray</span>
<span class="sd">            to DataFrame.</span>
<span class="sd">        numpy.recarray: An ndarray that allows field access using</span>
<span class="sd">            attributes, analogous to typed columns in a</span>
<span class="sd">            spreadsheet.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [1, 2], &#39;B&#39;: [0.5, 0.75]},</span>
<span class="sd">        ...                   index=[&#39;a&#39;, &#39;b&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A     B</span>
<span class="sd">        a  1  0.50</span>
<span class="sd">        b  2  0.75</span>
<span class="sd">        &gt;&gt;&gt; df.to_records()</span>
<span class="sd">        rec.array([(&#39;a&#39;, 1, 0.5 ), (&#39;b&#39;, 2, 0.75)],</span>
<span class="sd">                  dtype=[(&#39;index&#39;, &#39;O&#39;), (&#39;A&#39;, &#39;&lt;i8&#39;), (&#39;B&#39;, &#39;&lt;f8&#39;)])</span>

<span class="sd">        If the DataFrame index has no label then the recarray field name</span>
<span class="sd">        is set to &#39;index&#39;. If the index has a label then this is used as the</span>
<span class="sd">        field name:</span>

<span class="sd">        &gt;&gt;&gt; df.index = df.index.rename(&quot;I&quot;)</span>
<span class="sd">        &gt;&gt;&gt; df.to_records()</span>
<span class="sd">        rec.array([(&#39;a&#39;, 1, 0.5 ), (&#39;b&#39;, 2, 0.75)],</span>
<span class="sd">                  dtype=[(&#39;I&#39;, &#39;O&#39;), (&#39;A&#39;, &#39;&lt;i8&#39;), (&#39;B&#39;, &#39;&lt;f8&#39;)])</span>

<span class="sd">        The index can be excluded from the record array:</span>

<span class="sd">        &gt;&gt;&gt; df.to_records(index=False)</span>
<span class="sd">        rec.array([(1, 0.5 ), (2, 0.75)],</span>
<span class="sd">                  dtype=[(&#39;A&#39;, &#39;&lt;i8&#39;), (&#39;B&#39;, &#39;&lt;f8&#39;)])</span>

<span class="sd">        Data types can be specified for the columns:</span>

<span class="sd">        &gt;&gt;&gt; df.to_records(column_dtypes={&quot;A&quot;: &quot;int32&quot;})</span>
<span class="sd">        rec.array([(&#39;a&#39;, 1, 0.5 ), (&#39;b&#39;, 2, 0.75)],</span>
<span class="sd">                  dtype=[(&#39;I&#39;, &#39;O&#39;), (&#39;A&#39;, &#39;&lt;i4&#39;), (&#39;B&#39;, &#39;&lt;f8&#39;)])</span>

<span class="sd">        As well as for the index:</span>

<span class="sd">        &gt;&gt;&gt; df.to_records(index_dtypes=&quot;&lt;S2&quot;)</span>
<span class="sd">        rec.array([(b&#39;a&#39;, 1, 0.5 ), (b&#39;b&#39;, 2, 0.75)],</span>
<span class="sd">                  dtype=[(&#39;I&#39;, &#39;S2&#39;), (&#39;A&#39;, &#39;&lt;i8&#39;), (&#39;B&#39;, &#39;&lt;f8&#39;)])</span>

<span class="sd">        &gt;&gt;&gt; index_dtypes = f&quot;&lt;S{df.index.str.len().max()}&quot;</span>
<span class="sd">        &gt;&gt;&gt; df.to_records(index_dtypes=index_dtypes)</span>
<span class="sd">        rec.array([(b&#39;a&#39;, 1, 0.5 ), (b&#39;b&#39;, 2, 0.75)],</span>
<span class="sd">                  dtype=[(&#39;I&#39;, &#39;S1&#39;), (&#39;A&#39;, &#39;&lt;i8&#39;), (&#39;B&#39;, &#39;&lt;f8&#39;)])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span><span class="p">:</span>
            <span class="n">ix_vals</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">nlevels</span><span class="p">)</span>
            <span class="p">]</span>

            <span class="n">arrays</span> <span class="o">=</span> <span class="n">ix_vals</span> <span class="o">+</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>
            <span class="p">]</span>

            <span class="n">index_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                <span class="n">index_names</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">fill_missing_names</span><span class="p">(</span><span class="n">index_names</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">index_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">index_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]</span>

            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">index_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">))]</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
            <span class="n">index_names</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">index_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_names</span><span class="p">)</span>
        <span class="n">formats</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
            <span class="n">index_int</span> <span class="o">=</span> <span class="n">i</span>

            <span class="c1"># When the names and arrays are collected, we</span>
            <span class="c1"># first collect those in the DataFrame&#39;s index,</span>
            <span class="c1"># followed by those in its columns.</span>
            <span class="c1">#</span>
            <span class="c1"># Thus, the total length of the array is:</span>
            <span class="c1"># len(index_names) + len(DataFrame.columns).</span>
            <span class="c1">#</span>
            <span class="c1"># This check allows us to see whether we are</span>
            <span class="c1"># handling a name / array in the index or column.</span>
            <span class="k">if</span> <span class="n">index_int</span> <span class="o">&lt;</span> <span class="n">index_len</span><span class="p">:</span>
                <span class="n">dtype_mapping</span> <span class="o">=</span> <span class="n">index_dtypes</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">index_names</span><span class="p">[</span><span class="n">index_int</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">index_int</span> <span class="o">-=</span> <span class="n">index_len</span>
                <span class="n">dtype_mapping</span> <span class="o">=</span> <span class="n">column_dtypes</span>
                <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">index_int</span><span class="p">]</span>

            <span class="c1"># We have a dictionary, so we get the data type</span>
            <span class="c1"># associated with the index or column (which can</span>
            <span class="c1"># be denoted by its name in the DataFrame or its</span>
            <span class="c1"># position in DataFrame&#39;s array of indices or</span>
            <span class="c1"># columns, whichever is applicable.</span>
            <span class="k">if</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">dtype_mapping</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">dtype_mapping</span><span class="p">:</span>
                    <span class="n">dtype_mapping</span> <span class="o">=</span> <span class="n">dtype_mapping</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">index_int</span> <span class="ow">in</span> <span class="n">dtype_mapping</span><span class="p">:</span>
                    <span class="n">dtype_mapping</span> <span class="o">=</span> <span class="n">dtype_mapping</span><span class="p">[</span><span class="n">index_int</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dtype_mapping</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># If no mapping can be found, use the array&#39;s</span>
            <span class="c1"># dtype attribute for formatting.</span>
            <span class="c1">#</span>
            <span class="c1"># A valid dtype must either be a type or</span>
            <span class="c1"># string naming a type.</span>
            <span class="k">if</span> <span class="n">dtype_mapping</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">formats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype_mapping</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
                <span class="c1"># error: Argument 1 to &quot;append&quot; of &quot;list&quot; has incompatible</span>
                <span class="c1"># type &quot;Union[type, dtype[Any], str]&quot;; expected &quot;dtype[Any]&quot;</span>
                <span class="n">formats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dtype_mapping</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">element</span> <span class="o">=</span> <span class="s2">&quot;row&quot;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">index_len</span> <span class="k">else</span> <span class="s2">&quot;column&quot;</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Invalid dtype </span><span class="si">{</span><span class="n">dtype_mapping</span><span class="si">}</span><span class="s2"> specified for </span><span class="si">{</span><span class="n">element</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">fromarrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;names&quot;</span><span class="p">:</span> <span class="n">names</span><span class="p">,</span> <span class="s2">&quot;formats&quot;</span><span class="p">:</span> <span class="n">formats</span><span class="p">})</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_from_arrays</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">arrays</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">,</span>
        <span class="n">index</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">Dtype</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">verify_integrity</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create DataFrame from a list of arrays corresponding to the columns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arrays : list-like of arrays</span>
<span class="sd">            Each array in the list corresponds to one column, in order.</span>
<span class="sd">        columns : list-like, Index</span>
<span class="sd">            The column names for the resulting DataFrame.</span>
<span class="sd">        index : list-like, Index</span>
<span class="sd">            The rows labels for the resulting DataFrame.</span>
<span class="sd">        dtype : dtype, optional</span>
<span class="sd">            Optional dtype to enforce for all arrays.</span>
<span class="sd">        verify_integrity : bool, default True</span>
<span class="sd">            Validate and homogenize all input. If set to False, it is assumed</span>
<span class="sd">            that all elements of `arrays` are actual arrays how they will be</span>
<span class="sd">            stored in a block (numpy ndarray or ExtensionArray), have the same</span>
<span class="sd">            length as and are aligned with the index, and that `columns` and</span>
<span class="sd">            `index` are ensured to be an Index object.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">pandas_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">manager</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;mode.data_manager&quot;</span><span class="p">)</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">ensure_index</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;len(columns) must match len(arrays)&quot;</span><span class="p">)</span>
        <span class="n">mgr</span> <span class="o">=</span> <span class="n">arrays_to_mgr</span><span class="p">(</span>
            <span class="n">arrays</span><span class="p">,</span>
            <span class="n">columns</span><span class="p">,</span>
            <span class="n">index</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">verify_integrity</span><span class="o">=</span><span class="n">verify_integrity</span><span class="p">,</span>
            <span class="n">typ</span><span class="o">=</span><span class="n">manager</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">mgr</span><span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span>
        <span class="n">storage_options</span><span class="o">=</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;storage_options&quot;</span><span class="p">],</span>
        <span class="n">compression_options</span><span class="o">=</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;compression_options&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="s2">&quot;path&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_stata</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="n">FilePath</span> <span class="o">|</span> <span class="n">WriteBuffer</span><span class="p">[</span><span class="nb">bytes</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">convert_dates</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">write_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">byteorder</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">time_stamp</span><span class="p">:</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">data_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">variable_labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">version</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">114</span><span class="p">,</span>
        <span class="n">convert_strl</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">compression</span><span class="p">:</span> <span class="n">CompressionOptions</span> <span class="o">=</span> <span class="s2">&quot;infer&quot;</span><span class="p">,</span>
        <span class="n">storage_options</span><span class="p">:</span> <span class="n">StorageOptions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">value_labels</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Export DataFrame object to Stata dta format.</span>

<span class="sd">        Writes the DataFrame to a Stata dataset file.</span>
<span class="sd">        &quot;dta&quot; files contain a Stata dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str, path object, or buffer</span>
<span class="sd">            String, path object (implementing ``os.PathLike[str]``), or file-like</span>
<span class="sd">            object implementing a binary ``write()`` function.</span>

<span class="sd">        convert_dates : dict</span>
<span class="sd">            Dictionary mapping columns containing datetime types to stata</span>
<span class="sd">            internal format to use when writing the dates. Options are &#39;tc&#39;,</span>
<span class="sd">            &#39;td&#39;, &#39;tm&#39;, &#39;tw&#39;, &#39;th&#39;, &#39;tq&#39;, &#39;ty&#39;. Column can be either an integer</span>
<span class="sd">            or a name. Datetime columns that do not have a conversion type</span>
<span class="sd">            specified will be converted to &#39;tc&#39;. Raises NotImplementedError if</span>
<span class="sd">            a datetime column has timezone information.</span>
<span class="sd">        write_index : bool</span>
<span class="sd">            Write the index to Stata dataset.</span>
<span class="sd">        byteorder : str</span>
<span class="sd">            Can be &quot;&gt;&quot;, &quot;&lt;&quot;, &quot;little&quot;, or &quot;big&quot;. default is `sys.byteorder`.</span>
<span class="sd">        time_stamp : datetime</span>
<span class="sd">            A datetime to use as file creation date.  Default is the current</span>
<span class="sd">            time.</span>
<span class="sd">        data_label : str, optional</span>
<span class="sd">            A label for the data set.  Must be 80 characters or smaller.</span>
<span class="sd">        variable_labels : dict</span>
<span class="sd">            Dictionary containing columns as keys and variable labels as</span>
<span class="sd">            values. Each label must be 80 characters or smaller.</span>
<span class="sd">        version : {{114, 117, 118, 119, None}}, default 114</span>
<span class="sd">            Version to use in the output dta file. Set to None to let pandas</span>
<span class="sd">            decide between 118 or 119 formats depending on the number of</span>
<span class="sd">            columns in the frame. Version 114 can be read by Stata 10 and</span>
<span class="sd">            later. Version 117 can be read by Stata 13 or later. Version 118</span>
<span class="sd">            is supported in Stata 14 and later. Version 119 is supported in</span>
<span class="sd">            Stata 15 and later. Version 114 limits string variables to 244</span>
<span class="sd">            characters or fewer while versions 117 and later allow strings</span>
<span class="sd">            with lengths up to 2,000,000 characters. Versions 118 and 119</span>
<span class="sd">            support Unicode characters, and version 119 supports more than</span>
<span class="sd">            32,767 variables.</span>

<span class="sd">            Version 119 should usually only be used when the number of</span>
<span class="sd">            variables exceeds the capacity of dta format 118. Exporting</span>
<span class="sd">            smaller datasets in format 119 may have unintended consequences,</span>
<span class="sd">            and, as of November 2020, Stata SE cannot read version 119 files.</span>

<span class="sd">        convert_strl : list, optional</span>
<span class="sd">            List of column names to convert to string columns to Stata StrL</span>
<span class="sd">            format. Only available if version is 117.  Storing strings in the</span>
<span class="sd">            StrL format can produce smaller dta files if strings have more than</span>
<span class="sd">            8 characters and values are repeated.</span>
<span class="sd">        {compression_options}</span>

<span class="sd">            .. versionadded:: 1.1.0</span>

<span class="sd">            .. versionchanged:: 1.4.0 Zstandard support.</span>

<span class="sd">        {storage_options}</span>

<span class="sd">            .. versionadded:: 1.2.0</span>

<span class="sd">        value_labels : dict of dicts</span>
<span class="sd">            Dictionary containing columns as keys and dictionaries of column value</span>
<span class="sd">            to labels as values. Labels for a single variable must be 32,000</span>
<span class="sd">            characters or smaller.</span>

<span class="sd">            .. versionadded:: 1.4.0</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            * If datetimes contain timezone information</span>
<span class="sd">            * Column dtype is not representable in Stata</span>
<span class="sd">        ValueError</span>
<span class="sd">            * Columns listed in convert_dates are neither datetime64[ns]</span>
<span class="sd">              or datetime.datetime</span>
<span class="sd">            * Column listed in convert_dates is not in DataFrame</span>
<span class="sd">            * Categorical label contains more than 32,000 characters</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        read_stata : Import Stata data files.</span>
<span class="sd">        io.stata.StataWriter : Low-level writer for Stata data files.</span>
<span class="sd">        io.stata.StataWriter117 : Low-level writer for version 117 files.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({{&#39;animal&#39;: [&#39;falcon&#39;, &#39;parrot&#39;, &#39;falcon&#39;,</span>
<span class="sd">        ...                               &#39;parrot&#39;],</span>
<span class="sd">        ...                    &#39;speed&#39;: [350, 18, 361, 15]}})</span>
<span class="sd">        &gt;&gt;&gt; df.to_stata(&#39;animals.dta&#39;)  # doctest: +SKIP</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">version</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">114</span><span class="p">,</span> <span class="mi">117</span><span class="p">,</span> <span class="mi">118</span><span class="p">,</span> <span class="mi">119</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only formats 114, 117, 118 and 119 are supported.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="mi">114</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">convert_strl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;strl is not supported in format 114&quot;</span><span class="p">)</span>
            <span class="kn">from</span> <span class="nn">pandas.io.stata</span> <span class="kn">import</span> <span class="n">StataWriter</span> <span class="k">as</span> <span class="n">statawriter</span>
        <span class="k">elif</span> <span class="n">version</span> <span class="o">==</span> <span class="mi">117</span><span class="p">:</span>
            <span class="c1"># Incompatible import of &quot;statawriter&quot; (imported name has type</span>
            <span class="c1"># &quot;Type[StataWriter117]&quot;, local name has type &quot;Type[StataWriter]&quot;)</span>
            <span class="kn">from</span> <span class="nn">pandas.io.stata</span> <span class="kn">import</span> <span class="p">(</span>  <span class="c1"># type: ignore[assignment]</span>
                <span class="n">StataWriter117</span> <span class="k">as</span> <span class="n">statawriter</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># versions 118 and 119</span>
            <span class="c1"># Incompatible import of &quot;statawriter&quot; (imported name has type</span>
            <span class="c1"># &quot;Type[StataWriter117]&quot;, local name has type &quot;Type[StataWriter]&quot;)</span>
            <span class="kn">from</span> <span class="nn">pandas.io.stata</span> <span class="kn">import</span> <span class="p">(</span>  <span class="c1"># type: ignore[assignment]</span>
                <span class="n">StataWriterUTF8</span> <span class="k">as</span> <span class="n">statawriter</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">version</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">version</span> <span class="o">&gt;=</span> <span class="mi">117</span><span class="p">:</span>
            <span class="c1"># strl conversion is only supported &gt;= 117</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;convert_strl&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_strl</span>
        <span class="k">if</span> <span class="n">version</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">version</span> <span class="o">&gt;=</span> <span class="mi">118</span><span class="p">:</span>
            <span class="c1"># Specifying the version is only supported for UTF8 (118 or 119)</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;version&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">version</span>

        <span class="n">writer</span> <span class="o">=</span> <span class="n">statawriter</span><span class="p">(</span>
            <span class="n">path</span><span class="p">,</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">convert_dates</span><span class="o">=</span><span class="n">convert_dates</span><span class="p">,</span>
            <span class="n">byteorder</span><span class="o">=</span><span class="n">byteorder</span><span class="p">,</span>
            <span class="n">time_stamp</span><span class="o">=</span><span class="n">time_stamp</span><span class="p">,</span>
            <span class="n">data_label</span><span class="o">=</span><span class="n">data_label</span><span class="p">,</span>
            <span class="n">write_index</span><span class="o">=</span><span class="n">write_index</span><span class="p">,</span>
            <span class="n">variable_labels</span><span class="o">=</span><span class="n">variable_labels</span><span class="p">,</span>
            <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span>
            <span class="n">storage_options</span><span class="o">=</span><span class="n">storage_options</span><span class="p">,</span>
            <span class="n">value_labels</span><span class="o">=</span><span class="n">value_labels</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">writer</span><span class="o">.</span><span class="n">write_file</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">to_feather</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="n">FilePath</span> <span class="o">|</span> <span class="n">WriteBuffer</span><span class="p">[</span><span class="nb">bytes</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write a DataFrame to the binary Feather format.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str, path object, file-like object</span>
<span class="sd">            String, path object (implementing ``os.PathLike[str]``), or file-like</span>
<span class="sd">            object implementing a binary ``write()`` function. If a string or a path,</span>
<span class="sd">            it will be used as Root Directory path when writing a partitioned dataset.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Additional keywords passed to :func:`pyarrow.feather.write_feather`.</span>
<span class="sd">            Starting with pyarrow 0.17, this includes the `compression`,</span>
<span class="sd">            `compression_level`, `chunksize` and `version` keywords.</span>

<span class="sd">            .. versionadded:: 1.1.0</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function writes the dataframe as a `feather file</span>
<span class="sd">        &lt;https://arrow.apache.org/docs/python/feather.html&gt;`_. Requires a default</span>
<span class="sd">        index. For saving the DataFrame with your custom index use a method that</span>
<span class="sd">        supports custom indices e.g. `to_parquet`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io.feather_format</span> <span class="kn">import</span> <span class="n">to_feather</span>

        <span class="n">to_feather</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span>
        <span class="n">Series</span><span class="o">.</span><span class="n">to_markdown</span><span class="p">,</span>
        <span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">],</span>
        <span class="n">storage_options</span><span class="o">=</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;storage_options&quot;</span><span class="p">],</span>
        <span class="n">examples</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Examples</span>
<span class="s2">        --------</span>
<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame(</span>
<span class="s2">        ...     data={&quot;animal_1&quot;: [&quot;elk&quot;, &quot;pig&quot;], &quot;animal_2&quot;: [&quot;dog&quot;, &quot;quetzal&quot;]}</span>
<span class="s2">        ... )</span>
<span class="s2">        &gt;&gt;&gt; print(df.to_markdown())</span>
<span class="s2">        |    | animal_1   | animal_2   |</span>
<span class="s2">        |---:|:-----------|:-----------|</span>
<span class="s2">        |  0 | elk        | dog        |</span>
<span class="s2">        |  1 | pig        | quetzal    |</span>

<span class="s2">        Output markdown with a tabulate option.</span>

<span class="s2">        &gt;&gt;&gt; print(df.to_markdown(tablefmt=&quot;grid&quot;))</span>
<span class="s2">        +----+------------+------------+</span>
<span class="s2">        |    | animal_1   | animal_2   |</span>
<span class="s2">        +====+============+============+</span>
<span class="s2">        |  0 | elk        | dog        |</span>
<span class="s2">        +----+------------+------------+</span>
<span class="s2">        |  1 | pig        | quetzal    |</span>
<span class="s2">        +----+------------+------------+&quot;&quot;&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_markdown</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">buf</span><span class="p">:</span> <span class="n">FilePath</span> <span class="o">|</span> <span class="n">WriteBuffer</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;wt&quot;</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">storage_options</span><span class="p">:</span> <span class="n">StorageOptions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="s2">&quot;showindex&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Pass &#39;index&#39; instead of &#39;showindex&quot;</span><span class="p">)</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;headers&quot;</span><span class="p">,</span> <span class="s2">&quot;keys&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;tablefmt&quot;</span><span class="p">,</span> <span class="s2">&quot;pipe&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;showindex&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="n">tabulate</span> <span class="o">=</span> <span class="n">import_optional_dependency</span><span class="p">(</span><span class="s2">&quot;tabulate&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">tabulate</span><span class="o">.</span><span class="n">tabulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">buf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">with</span> <span class="n">get_handle</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">storage_options</span><span class="o">=</span><span class="n">storage_options</span><span class="p">)</span> <span class="k">as</span> <span class="n">handles</span><span class="p">:</span>
            <span class="n">handles</span><span class="o">.</span><span class="n">handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">to_parquet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">engine</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">compression</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">partition_cols</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">storage_options</span><span class="p">:</span> <span class="n">StorageOptions</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">to_parquet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="n">FilePath</span> <span class="o">|</span> <span class="n">WriteBuffer</span><span class="p">[</span><span class="nb">bytes</span><span class="p">],</span>
        <span class="n">engine</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">compression</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">partition_cols</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">storage_options</span><span class="p">:</span> <span class="n">StorageOptions</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">storage_options</span><span class="o">=</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;storage_options&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">to_parquet</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="n">FilePath</span> <span class="o">|</span> <span class="n">WriteBuffer</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">engine</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">compression</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="s2">&quot;snappy&quot;</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">partition_cols</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">storage_options</span><span class="p">:</span> <span class="n">StorageOptions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write a DataFrame to the binary parquet format.</span>

<span class="sd">        This function writes the dataframe as a `parquet file</span>
<span class="sd">        &lt;https://parquet.apache.org/&gt;`_. You can choose different parquet</span>
<span class="sd">        backends, and have the option of compression. See</span>
<span class="sd">        :ref:`the user guide &lt;io.parquet&gt;` for more details.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str, path object, file-like object, or None, default None</span>
<span class="sd">            String, path object (implementing ``os.PathLike[str]``), or file-like</span>
<span class="sd">            object implementing a binary ``write()`` function. If None, the result is</span>
<span class="sd">            returned as bytes. If a string or path, it will be used as Root Directory</span>
<span class="sd">            path when writing a partitioned dataset.</span>

<span class="sd">            .. versionchanged:: 1.2.0</span>

<span class="sd">            Previously this was &quot;fname&quot;</span>

<span class="sd">        engine : {{&#39;auto&#39;, &#39;pyarrow&#39;, &#39;fastparquet&#39;}}, default &#39;auto&#39;</span>
<span class="sd">            Parquet library to use. If &#39;auto&#39;, then the option</span>
<span class="sd">            ``io.parquet.engine`` is used. The default ``io.parquet.engine``</span>
<span class="sd">            behavior is to try &#39;pyarrow&#39;, falling back to &#39;fastparquet&#39; if</span>
<span class="sd">            &#39;pyarrow&#39; is unavailable.</span>
<span class="sd">        compression : {{&#39;snappy&#39;, &#39;gzip&#39;, &#39;brotli&#39;, None}}, default &#39;snappy&#39;</span>
<span class="sd">            Name of the compression to use. Use ``None`` for no compression.</span>
<span class="sd">        index : bool, default None</span>
<span class="sd">            If ``True``, include the dataframe&#39;s index(es) in the file output.</span>
<span class="sd">            If ``False``, they will not be written to the file.</span>
<span class="sd">            If ``None``, similar to ``True`` the dataframe&#39;s index(es)</span>
<span class="sd">            will be saved. However, instead of being saved as values,</span>
<span class="sd">            the RangeIndex will be stored as a range in the metadata so it</span>
<span class="sd">            doesn&#39;t require much space and is faster. Other indexes will</span>
<span class="sd">            be included as columns in the file output.</span>
<span class="sd">        partition_cols : list, optional, default None</span>
<span class="sd">            Column names by which to partition the dataset.</span>
<span class="sd">            Columns are partitioned in the order they are given.</span>
<span class="sd">            Must be None if path is not a string.</span>
<span class="sd">        {storage_options}</span>

<span class="sd">            .. versionadded:: 1.2.0</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Additional arguments passed to the parquet library. See</span>
<span class="sd">            :ref:`pandas io &lt;io.parquet&gt;` for more details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bytes if no path argument is provided else None</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        read_parquet : Read a parquet file.</span>
<span class="sd">        DataFrame.to_orc : Write an orc file.</span>
<span class="sd">        DataFrame.to_csv : Write a csv file.</span>
<span class="sd">        DataFrame.to_sql : Write to a sql table.</span>
<span class="sd">        DataFrame.to_hdf : Write to hdf.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function requires either the `fastparquet</span>
<span class="sd">        &lt;https://pypi.org/project/fastparquet&gt;`_ or `pyarrow</span>
<span class="sd">        &lt;https://arrow.apache.org/docs/python/&gt;`_ library.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(data={{&#39;col1&#39;: [1, 2], &#39;col2&#39;: [3, 4]}})</span>
<span class="sd">        &gt;&gt;&gt; df.to_parquet(&#39;df.parquet.gzip&#39;,</span>
<span class="sd">        ...               compression=&#39;gzip&#39;)  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; pd.read_parquet(&#39;df.parquet.gzip&#39;)  # doctest: +SKIP</span>
<span class="sd">           col1  col2</span>
<span class="sd">        0     1     3</span>
<span class="sd">        1     2     4</span>

<span class="sd">        If you want to get a buffer to the parquet content you can use a io.BytesIO</span>
<span class="sd">        object, as long as you don&#39;t use partition_cols, which creates multiple files.</span>

<span class="sd">        &gt;&gt;&gt; import io</span>
<span class="sd">        &gt;&gt;&gt; f = io.BytesIO()</span>
<span class="sd">        &gt;&gt;&gt; df.to_parquet(f)</span>
<span class="sd">        &gt;&gt;&gt; f.seek(0)</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; content = f.read()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io.parquet</span> <span class="kn">import</span> <span class="n">to_parquet</span>

        <span class="k">return</span> <span class="n">to_parquet</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">path</span><span class="p">,</span>
            <span class="n">engine</span><span class="p">,</span>
            <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">partition_cols</span><span class="o">=</span><span class="n">partition_cols</span><span class="p">,</span>
            <span class="n">storage_options</span><span class="o">=</span><span class="n">storage_options</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_orc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="n">FilePath</span> <span class="o">|</span> <span class="n">WriteBuffer</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">engine</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;pyarrow&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;pyarrow&quot;</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">engine_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bytes</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write a DataFrame to the ORC format.</span>

<span class="sd">        .. versionadded:: 1.5.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str, file-like object or None, default None</span>
<span class="sd">            If a string, it will be used as Root Directory path</span>
<span class="sd">            when writing a partitioned dataset. By file-like object,</span>
<span class="sd">            we refer to objects with a write() method, such as a file handle</span>
<span class="sd">            (e.g. via builtin open function). If path is None,</span>
<span class="sd">            a bytes object is returned.</span>
<span class="sd">        engine : str, default &#39;pyarrow&#39;</span>
<span class="sd">            ORC library to use. Pyarrow must be &gt;= 7.0.0.</span>
<span class="sd">        index : bool, optional</span>
<span class="sd">            If ``True``, include the dataframe&#39;s index(es) in the file output.</span>
<span class="sd">            If ``False``, they will not be written to the file.</span>
<span class="sd">            If ``None``, similar to ``infer`` the dataframe&#39;s index(es)</span>
<span class="sd">            will be saved. However, instead of being saved as values,</span>
<span class="sd">            the RangeIndex will be stored as a range in the metadata so it</span>
<span class="sd">            doesn&#39;t require much space and is faster. Other indexes will</span>
<span class="sd">            be included as columns in the file output.</span>
<span class="sd">        engine_kwargs : dict[str, Any] or None, default None</span>
<span class="sd">            Additional keyword arguments passed to :func:`pyarrow.orc.write_table`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bytes if no path argument is provided else None</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            Dtype of one or more columns is category, unsigned integers, interval,</span>
<span class="sd">            period or sparse.</span>
<span class="sd">        ValueError</span>
<span class="sd">            engine is not pyarrow.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        read_orc : Read a ORC file.</span>
<span class="sd">        DataFrame.to_parquet : Write a parquet file.</span>
<span class="sd">        DataFrame.to_csv : Write a csv file.</span>
<span class="sd">        DataFrame.to_sql : Write to a sql table.</span>
<span class="sd">        DataFrame.to_hdf : Write to hdf.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        * Before using this function you should read the :ref:`user guide about</span>
<span class="sd">          ORC &lt;io.orc&gt;` and :ref:`install optional dependencies &lt;install.warn_orc&gt;`.</span>
<span class="sd">        * This function requires `pyarrow &lt;https://arrow.apache.org/docs/python/&gt;`_</span>
<span class="sd">          library.</span>
<span class="sd">        * For supported dtypes please refer to `supported ORC features in Arrow</span>
<span class="sd">          &lt;https://arrow.apache.org/docs/cpp/orc.html#data-types&gt;`__.</span>
<span class="sd">        * Currently timezones in datetime columns are not preserved when a</span>
<span class="sd">          dataframe is converted into ORC files.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(data={&#39;col1&#39;: [1, 2], &#39;col2&#39;: [4, 3]})</span>
<span class="sd">        &gt;&gt;&gt; df.to_orc(&#39;df.orc&#39;)  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; pd.read_orc(&#39;df.orc&#39;)  # doctest: +SKIP</span>
<span class="sd">           col1  col2</span>
<span class="sd">        0     1     4</span>
<span class="sd">        1     2     3</span>

<span class="sd">        If you want to get a buffer to the orc content you can write it to io.BytesIO</span>
<span class="sd">        &gt;&gt;&gt; import io</span>
<span class="sd">        &gt;&gt;&gt; b = io.BytesIO(df.to_orc())  # doctest: +SKIP</span>
<span class="sd">        &gt;&gt;&gt; b.seek(0)  # doctest: +SKIP</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; content = b.read()  # doctest: +SKIP</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.io.orc</span> <span class="kn">import</span> <span class="n">to_orc</span>

        <span class="k">return</span> <span class="n">to_orc</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="n">engine</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">engine_kwargs</span><span class="o">=</span><span class="n">engine_kwargs</span>
        <span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">to_html</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">buf</span><span class="p">:</span> <span class="n">FilePath</span> <span class="o">|</span> <span class="n">WriteBuffer</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Level</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">col_space</span><span class="p">:</span> <span class="n">ColspaceArgType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">header</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">na_rep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">formatters</span><span class="p">:</span> <span class="n">FormattersType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">float_format</span><span class="p">:</span> <span class="n">FloatFormatType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">sparsify</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">index_names</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">justify</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">max_rows</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">max_cols</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">show_dimensions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">decimal</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">bold_rows</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">classes</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">escape</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">notebook</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">border</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">table_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">render_links</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">to_html</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">buf</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Level</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">col_space</span><span class="p">:</span> <span class="n">ColspaceArgType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">header</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">na_rep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">formatters</span><span class="p">:</span> <span class="n">FormattersType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">float_format</span><span class="p">:</span> <span class="n">FloatFormatType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">sparsify</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">index_names</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">justify</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">max_rows</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">max_cols</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">show_dimensions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">decimal</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">bold_rows</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">classes</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">escape</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">notebook</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">border</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">table_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">render_links</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@Substitution</span><span class="p">(</span>
        <span class="n">header_type</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">,</span>
        <span class="n">header</span><span class="o">=</span><span class="s2">&quot;Whether to print column labels, default True&quot;</span><span class="p">,</span>
        <span class="n">col_space_type</span><span class="o">=</span><span class="s2">&quot;str or int, list or dict of int or str&quot;</span><span class="p">,</span>
        <span class="n">col_space</span><span class="o">=</span><span class="s2">&quot;The minimum width of each column in CSS length &quot;</span>
        <span class="s2">&quot;units.  An int is assumed to be px units.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="nd">@Substitution</span><span class="p">(</span><span class="n">shared_params</span><span class="o">=</span><span class="n">fmt</span><span class="o">.</span><span class="n">common_docstring</span><span class="p">,</span> <span class="n">returns</span><span class="o">=</span><span class="n">fmt</span><span class="o">.</span><span class="n">return_docstring</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_html</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">buf</span><span class="p">:</span> <span class="n">FilePath</span> <span class="o">|</span> <span class="n">WriteBuffer</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Level</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">col_space</span><span class="p">:</span> <span class="n">ColspaceArgType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">header</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">na_rep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;NaN&quot;</span><span class="p">,</span>
        <span class="n">formatters</span><span class="p">:</span> <span class="n">FormattersType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">float_format</span><span class="p">:</span> <span class="n">FloatFormatType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sparsify</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">index_names</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">justify</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_rows</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_cols</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">show_dimensions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">decimal</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span>
        <span class="n">bold_rows</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">classes</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">|</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">escape</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">notebook</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">border</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">table_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">render_links</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Render a DataFrame as an HTML table.</span>
<span class="sd">        %(shared_params)s</span>
<span class="sd">        bold_rows : bool, default True</span>
<span class="sd">            Make the row labels bold in the output.</span>
<span class="sd">        classes : str or list or tuple, default None</span>
<span class="sd">            CSS class(es) to apply to the resulting html table.</span>
<span class="sd">        escape : bool, default True</span>
<span class="sd">            Convert the characters &lt;, &gt;, and &amp; to HTML-safe sequences.</span>
<span class="sd">        notebook : {True, False}, default False</span>
<span class="sd">            Whether the generated HTML is for IPython Notebook.</span>
<span class="sd">        border : int</span>
<span class="sd">            A ``border=border`` attribute is included in the opening</span>
<span class="sd">            `&lt;table&gt;` tag. Default ``pd.options.display.html.border``.</span>
<span class="sd">        table_id : str, optional</span>
<span class="sd">            A css id is included in the opening `&lt;table&gt;` tag if specified.</span>
<span class="sd">        render_links : bool, default False</span>
<span class="sd">            Convert URLs to HTML links.</span>
<span class="sd">        encoding : str, default &quot;utf-8&quot;</span>
<span class="sd">            Set character encoding.</span>

<span class="sd">            .. versionadded:: 1.0</span>
<span class="sd">        %(returns)s</span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        to_string : Convert DataFrame to a string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">justify</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">justify</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fmt</span><span class="o">.</span><span class="n">_VALID_JUSTIFY_PARAMETERS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid value for justify parameter&quot;</span><span class="p">)</span>

        <span class="n">formatter</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">DataFrameFormatter</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">col_space</span><span class="o">=</span><span class="n">col_space</span><span class="p">,</span>
            <span class="n">na_rep</span><span class="o">=</span><span class="n">na_rep</span><span class="p">,</span>
            <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">formatters</span><span class="o">=</span><span class="n">formatters</span><span class="p">,</span>
            <span class="n">float_format</span><span class="o">=</span><span class="n">float_format</span><span class="p">,</span>
            <span class="n">bold_rows</span><span class="o">=</span><span class="n">bold_rows</span><span class="p">,</span>
            <span class="n">sparsify</span><span class="o">=</span><span class="n">sparsify</span><span class="p">,</span>
            <span class="n">justify</span><span class="o">=</span><span class="n">justify</span><span class="p">,</span>
            <span class="n">index_names</span><span class="o">=</span><span class="n">index_names</span><span class="p">,</span>
            <span class="n">escape</span><span class="o">=</span><span class="n">escape</span><span class="p">,</span>
            <span class="n">decimal</span><span class="o">=</span><span class="n">decimal</span><span class="p">,</span>
            <span class="n">max_rows</span><span class="o">=</span><span class="n">max_rows</span><span class="p">,</span>
            <span class="n">max_cols</span><span class="o">=</span><span class="n">max_cols</span><span class="p">,</span>
            <span class="n">show_dimensions</span><span class="o">=</span><span class="n">show_dimensions</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># TODO: a generic formatter wld b in DataFrameFormatter</span>
        <span class="k">return</span> <span class="n">fmt</span><span class="o">.</span><span class="n">DataFrameRenderer</span><span class="p">(</span><span class="n">formatter</span><span class="p">)</span><span class="o">.</span><span class="n">to_html</span><span class="p">(</span>
            <span class="n">buf</span><span class="o">=</span><span class="n">buf</span><span class="p">,</span>
            <span class="n">classes</span><span class="o">=</span><span class="n">classes</span><span class="p">,</span>
            <span class="n">notebook</span><span class="o">=</span><span class="n">notebook</span><span class="p">,</span>
            <span class="n">border</span><span class="o">=</span><span class="n">border</span><span class="p">,</span>
            <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
            <span class="n">table_id</span><span class="o">=</span><span class="n">table_id</span><span class="p">,</span>
            <span class="n">render_links</span><span class="o">=</span><span class="n">render_links</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span>
        <span class="n">storage_options</span><span class="o">=</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;storage_options&quot;</span><span class="p">],</span>
        <span class="n">compression_options</span><span class="o">=</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;compression_options&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="s2">&quot;path_or_buffer&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">to_xml</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">path_or_buffer</span><span class="p">:</span> <span class="n">FilePath</span> <span class="o">|</span> <span class="n">WriteBuffer</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]</span> <span class="o">|</span> <span class="n">WriteBuffer</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">root_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="s2">&quot;data&quot;</span><span class="p">,</span>
        <span class="n">row_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="s2">&quot;row&quot;</span><span class="p">,</span>
        <span class="n">na_rep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">attr_cols</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">elem_cols</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">namespaces</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">encoding</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;utf-8&quot;</span><span class="p">,</span>
        <span class="n">xml_declaration</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pretty_print</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">parser</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="s2">&quot;lxml&quot;</span><span class="p">,</span>
        <span class="n">stylesheet</span><span class="p">:</span> <span class="n">FilePath</span> <span class="o">|</span> <span class="n">ReadBuffer</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="n">ReadBuffer</span><span class="p">[</span><span class="nb">bytes</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">compression</span><span class="p">:</span> <span class="n">CompressionOptions</span> <span class="o">=</span> <span class="s2">&quot;infer&quot;</span><span class="p">,</span>
        <span class="n">storage_options</span><span class="p">:</span> <span class="n">StorageOptions</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Render a DataFrame to an XML document.</span>

<span class="sd">        .. versionadded:: 1.3.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path_or_buffer : str, path object, file-like object, or None, default None</span>
<span class="sd">            String, path object (implementing ``os.PathLike[str]``), or file-like</span>
<span class="sd">            object implementing a ``write()`` function. If None, the result is returned</span>
<span class="sd">            as a string.</span>
<span class="sd">        index : bool, default True</span>
<span class="sd">            Whether to include index in XML document.</span>
<span class="sd">        root_name : str, default &#39;data&#39;</span>
<span class="sd">            The name of root element in XML document.</span>
<span class="sd">        row_name : str, default &#39;row&#39;</span>
<span class="sd">            The name of row element in XML document.</span>
<span class="sd">        na_rep : str, optional</span>
<span class="sd">            Missing data representation.</span>
<span class="sd">        attr_cols : list-like, optional</span>
<span class="sd">            List of columns to write as attributes in row element.</span>
<span class="sd">            Hierarchical columns will be flattened with underscore</span>
<span class="sd">            delimiting the different levels.</span>
<span class="sd">        elem_cols : list-like, optional</span>
<span class="sd">            List of columns to write as children in row element. By default,</span>
<span class="sd">            all columns output as children of row element. Hierarchical</span>
<span class="sd">            columns will be flattened with underscore delimiting the</span>
<span class="sd">            different levels.</span>
<span class="sd">        namespaces : dict, optional</span>
<span class="sd">            All namespaces to be defined in root element. Keys of dict</span>
<span class="sd">            should be prefix names and values of dict corresponding URIs.</span>
<span class="sd">            Default namespaces should be given empty string key. For</span>
<span class="sd">            example, ::</span>

<span class="sd">                namespaces = {{&quot;&quot;: &quot;https://example.com&quot;}}</span>

<span class="sd">        prefix : str, optional</span>
<span class="sd">            Namespace prefix to be used for every element and/or attribute</span>
<span class="sd">            in document. This should be one of the keys in ``namespaces``</span>
<span class="sd">            dict.</span>
<span class="sd">        encoding : str, default &#39;utf-8&#39;</span>
<span class="sd">            Encoding of the resulting document.</span>
<span class="sd">        xml_declaration : bool, default True</span>
<span class="sd">            Whether to include the XML declaration at start of document.</span>
<span class="sd">        pretty_print : bool, default True</span>
<span class="sd">            Whether output should be pretty printed with indentation and</span>
<span class="sd">            line breaks.</span>
<span class="sd">        parser : {{&#39;lxml&#39;,&#39;etree&#39;}}, default &#39;lxml&#39;</span>
<span class="sd">            Parser module to use for building of tree. Only &#39;lxml&#39; and</span>
<span class="sd">            &#39;etree&#39; are supported. With &#39;lxml&#39;, the ability to use XSLT</span>
<span class="sd">            stylesheet is supported.</span>
<span class="sd">        stylesheet : str, path object or file-like object, optional</span>
<span class="sd">            A URL, file-like object, or a raw string containing an XSLT</span>
<span class="sd">            script used to transform the raw XML output. Script should use</span>
<span class="sd">            layout of elements and attributes from original output. This</span>
<span class="sd">            argument requires ``lxml`` to be installed. Only XSLT 1.0</span>
<span class="sd">            scripts and not later versions is currently supported.</span>
<span class="sd">        {compression_options}</span>

<span class="sd">            .. versionchanged:: 1.4.0 Zstandard support.</span>

<span class="sd">        {storage_options}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None or str</span>
<span class="sd">            If ``io`` is None, returns the resulting XML format as a</span>
<span class="sd">            string. Otherwise returns None.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        to_json : Convert the pandas object to a JSON string.</span>
<span class="sd">        to_html : Convert DataFrame to a html.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({{&#39;shape&#39;: [&#39;square&#39;, &#39;circle&#39;, &#39;triangle&#39;],</span>
<span class="sd">        ...                    &#39;degrees&#39;: [360, 360, 180],</span>
<span class="sd">        ...                    &#39;sides&#39;: [4, np.nan, 3]}})</span>

<span class="sd">        &gt;&gt;&gt; df.to_xml()  # doctest: +SKIP</span>
<span class="sd">        &lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;</span>
<span class="sd">        &lt;data&gt;</span>
<span class="sd">          &lt;row&gt;</span>
<span class="sd">            &lt;index&gt;0&lt;/index&gt;</span>
<span class="sd">            &lt;shape&gt;square&lt;/shape&gt;</span>
<span class="sd">            &lt;degrees&gt;360&lt;/degrees&gt;</span>
<span class="sd">            &lt;sides&gt;4.0&lt;/sides&gt;</span>
<span class="sd">          &lt;/row&gt;</span>
<span class="sd">          &lt;row&gt;</span>
<span class="sd">            &lt;index&gt;1&lt;/index&gt;</span>
<span class="sd">            &lt;shape&gt;circle&lt;/shape&gt;</span>
<span class="sd">            &lt;degrees&gt;360&lt;/degrees&gt;</span>
<span class="sd">            &lt;sides/&gt;</span>
<span class="sd">          &lt;/row&gt;</span>
<span class="sd">          &lt;row&gt;</span>
<span class="sd">            &lt;index&gt;2&lt;/index&gt;</span>
<span class="sd">            &lt;shape&gt;triangle&lt;/shape&gt;</span>
<span class="sd">            &lt;degrees&gt;180&lt;/degrees&gt;</span>
<span class="sd">            &lt;sides&gt;3.0&lt;/sides&gt;</span>
<span class="sd">          &lt;/row&gt;</span>
<span class="sd">        &lt;/data&gt;</span>

<span class="sd">        &gt;&gt;&gt; df.to_xml(attr_cols=[</span>
<span class="sd">        ...           &#39;index&#39;, &#39;shape&#39;, &#39;degrees&#39;, &#39;sides&#39;</span>
<span class="sd">        ...           ])  # doctest: +SKIP</span>
<span class="sd">        &lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;</span>
<span class="sd">        &lt;data&gt;</span>
<span class="sd">          &lt;row index=&quot;0&quot; shape=&quot;square&quot; degrees=&quot;360&quot; sides=&quot;4.0&quot;/&gt;</span>
<span class="sd">          &lt;row index=&quot;1&quot; shape=&quot;circle&quot; degrees=&quot;360&quot;/&gt;</span>
<span class="sd">          &lt;row index=&quot;2&quot; shape=&quot;triangle&quot; degrees=&quot;180&quot; sides=&quot;3.0&quot;/&gt;</span>
<span class="sd">        &lt;/data&gt;</span>

<span class="sd">        &gt;&gt;&gt; df.to_xml(namespaces={{&quot;doc&quot;: &quot;https://example.com&quot;}},</span>
<span class="sd">        ...           prefix=&quot;doc&quot;)  # doctest: +SKIP</span>
<span class="sd">        &lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;</span>
<span class="sd">        &lt;doc:data xmlns:doc=&quot;https://example.com&quot;&gt;</span>
<span class="sd">          &lt;doc:row&gt;</span>
<span class="sd">            &lt;doc:index&gt;0&lt;/doc:index&gt;</span>
<span class="sd">            &lt;doc:shape&gt;square&lt;/doc:shape&gt;</span>
<span class="sd">            &lt;doc:degrees&gt;360&lt;/doc:degrees&gt;</span>
<span class="sd">            &lt;doc:sides&gt;4.0&lt;/doc:sides&gt;</span>
<span class="sd">          &lt;/doc:row&gt;</span>
<span class="sd">          &lt;doc:row&gt;</span>
<span class="sd">            &lt;doc:index&gt;1&lt;/doc:index&gt;</span>
<span class="sd">            &lt;doc:shape&gt;circle&lt;/doc:shape&gt;</span>
<span class="sd">            &lt;doc:degrees&gt;360&lt;/doc:degrees&gt;</span>
<span class="sd">            &lt;doc:sides/&gt;</span>
<span class="sd">          &lt;/doc:row&gt;</span>
<span class="sd">          &lt;doc:row&gt;</span>
<span class="sd">            &lt;doc:index&gt;2&lt;/doc:index&gt;</span>
<span class="sd">            &lt;doc:shape&gt;triangle&lt;/doc:shape&gt;</span>
<span class="sd">            &lt;doc:degrees&gt;180&lt;/doc:degrees&gt;</span>
<span class="sd">            &lt;doc:sides&gt;3.0&lt;/doc:sides&gt;</span>
<span class="sd">          &lt;/doc:row&gt;</span>
<span class="sd">        &lt;/doc:data&gt;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">pandas.io.formats.xml</span> <span class="kn">import</span> <span class="p">(</span>
            <span class="n">EtreeXMLFormatter</span><span class="p">,</span>
            <span class="n">LxmlXMLFormatter</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">lxml</span> <span class="o">=</span> <span class="n">import_optional_dependency</span><span class="p">(</span><span class="s2">&quot;lxml.etree&quot;</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

        <span class="n">TreeBuilder</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">EtreeXMLFormatter</span><span class="p">]</span> <span class="o">|</span> <span class="nb">type</span><span class="p">[</span><span class="n">LxmlXMLFormatter</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">parser</span> <span class="o">==</span> <span class="s2">&quot;lxml&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lxml</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">TreeBuilder</span> <span class="o">=</span> <span class="n">LxmlXMLFormatter</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                    <span class="s2">&quot;lxml not found, please install or use the etree parser.&quot;</span>
                <span class="p">)</span>

        <span class="k">elif</span> <span class="n">parser</span> <span class="o">==</span> <span class="s2">&quot;etree&quot;</span><span class="p">:</span>
            <span class="n">TreeBuilder</span> <span class="o">=</span> <span class="n">EtreeXMLFormatter</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Values for parser can only be lxml or etree.&quot;</span><span class="p">)</span>

        <span class="n">xml_formatter</span> <span class="o">=</span> <span class="n">TreeBuilder</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">path_or_buffer</span><span class="o">=</span><span class="n">path_or_buffer</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">root_name</span><span class="o">=</span><span class="n">root_name</span><span class="p">,</span>
            <span class="n">row_name</span><span class="o">=</span><span class="n">row_name</span><span class="p">,</span>
            <span class="n">na_rep</span><span class="o">=</span><span class="n">na_rep</span><span class="p">,</span>
            <span class="n">attr_cols</span><span class="o">=</span><span class="n">attr_cols</span><span class="p">,</span>
            <span class="n">elem_cols</span><span class="o">=</span><span class="n">elem_cols</span><span class="p">,</span>
            <span class="n">namespaces</span><span class="o">=</span><span class="n">namespaces</span><span class="p">,</span>
            <span class="n">prefix</span><span class="o">=</span><span class="n">prefix</span><span class="p">,</span>
            <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
            <span class="n">xml_declaration</span><span class="o">=</span><span class="n">xml_declaration</span><span class="p">,</span>
            <span class="n">pretty_print</span><span class="o">=</span><span class="n">pretty_print</span><span class="p">,</span>
            <span class="n">stylesheet</span><span class="o">=</span><span class="n">stylesheet</span><span class="p">,</span>
            <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">,</span>
            <span class="n">storage_options</span><span class="o">=</span><span class="n">storage_options</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">xml_formatter</span><span class="o">.</span><span class="n">write_output</span><span class="p">()</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="nd">@doc</span><span class="p">(</span><span class="n">INFO_DOCSTRING</span><span class="p">,</span> <span class="o">**</span><span class="n">frame_sub_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">buf</span><span class="p">:</span> <span class="n">WriteBuffer</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_cols</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">memory_usage</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">show_counts</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">DataFrameInfo</span><span class="p">(</span>
            <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">memory_usage</span><span class="o">=</span><span class="n">memory_usage</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">info</span><span class="o">.</span><span class="n">render</span><span class="p">(</span>
            <span class="n">buf</span><span class="o">=</span><span class="n">buf</span><span class="p">,</span>
            <span class="n">max_cols</span><span class="o">=</span><span class="n">max_cols</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span>
            <span class="n">show_counts</span><span class="o">=</span><span class="n">show_counts</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">memory_usage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">deep</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the memory usage of each column in bytes.</span>

<span class="sd">        The memory usage can optionally include the contribution of</span>
<span class="sd">        the index and elements of `object` dtype.</span>

<span class="sd">        This value is displayed in `DataFrame.info` by default. This can be</span>
<span class="sd">        suppressed by setting ``pandas.options.display.memory_usage`` to False.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : bool, default True</span>
<span class="sd">            Specifies whether to include the memory usage of the DataFrame&#39;s</span>
<span class="sd">            index in returned Series. If ``index=True``, the memory usage of</span>
<span class="sd">            the index is the first item in the output.</span>
<span class="sd">        deep : bool, default False</span>
<span class="sd">            If True, introspect the data deeply by interrogating</span>
<span class="sd">            `object` dtypes for system-level memory consumption, and include</span>
<span class="sd">            it in the returned values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            A Series whose index is the original column names and whose values</span>
<span class="sd">            is the memory usage of each column in bytes.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.ndarray.nbytes : Total bytes consumed by the elements of an</span>
<span class="sd">            ndarray.</span>
<span class="sd">        Series.memory_usage : Bytes consumed by a Series.</span>
<span class="sd">        Categorical : Memory-efficient array for string values with</span>
<span class="sd">            many repeated values.</span>
<span class="sd">        DataFrame.info : Concise summary of a DataFrame.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        See the :ref:`Frequently Asked Questions &lt;df-memory-usage&gt;` for more</span>
<span class="sd">        details.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; dtypes = [&#39;int64&#39;, &#39;float64&#39;, &#39;complex128&#39;, &#39;object&#39;, &#39;bool&#39;]</span>
<span class="sd">        &gt;&gt;&gt; data = dict([(t, np.ones(shape=5000, dtype=int).astype(t))</span>
<span class="sd">        ...              for t in dtypes])</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(data)</span>
<span class="sd">        &gt;&gt;&gt; df.head()</span>
<span class="sd">           int64  float64            complex128  object  bool</span>
<span class="sd">        0      1      1.0              1.0+0.0j       1  True</span>
<span class="sd">        1      1      1.0              1.0+0.0j       1  True</span>
<span class="sd">        2      1      1.0              1.0+0.0j       1  True</span>
<span class="sd">        3      1      1.0              1.0+0.0j       1  True</span>
<span class="sd">        4      1      1.0              1.0+0.0j       1  True</span>

<span class="sd">        &gt;&gt;&gt; df.memory_usage()</span>
<span class="sd">        Index           128</span>
<span class="sd">        int64         40000</span>
<span class="sd">        float64       40000</span>
<span class="sd">        complex128    80000</span>
<span class="sd">        object        40000</span>
<span class="sd">        bool           5000</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; df.memory_usage(index=False)</span>
<span class="sd">        int64         40000</span>
<span class="sd">        float64       40000</span>
<span class="sd">        complex128    80000</span>
<span class="sd">        object        40000</span>
<span class="sd">        bool           5000</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        The memory footprint of `object` dtype columns is ignored by default:</span>

<span class="sd">        &gt;&gt;&gt; df.memory_usage(deep=True)</span>
<span class="sd">        Index            128</span>
<span class="sd">        int64          40000</span>
<span class="sd">        float64        40000</span>
<span class="sd">        complex128     80000</span>
<span class="sd">        object        180000</span>
<span class="sd">        bool            5000</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Use a Categorical for efficient storage of an object-dtype column with</span>
<span class="sd">        many repeated values.</span>

<span class="sd">        &gt;&gt;&gt; df[&#39;object&#39;].astype(&#39;category&#39;).memory_usage(deep=True)</span>
<span class="sd">        5244</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span>
            <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">memory_usage</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()],</span>
            <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">index</span><span class="p">:</span>
            <span class="n">index_memory_usage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">memory_usage</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">deep</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Index&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">index_memory_usage</span><span class="o">.</span><span class="n">_append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transpose index and columns.</span>

<span class="sd">        Reflect the DataFrame over its main diagonal by writing rows as columns</span>
<span class="sd">        and vice-versa. The property :attr:`.T` is an accessor to the method</span>
<span class="sd">        :meth:`transpose`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args : tuple, optional</span>
<span class="sd">            Accepted for compatibility with NumPy.</span>
<span class="sd">        copy : bool, default False</span>
<span class="sd">            Whether to copy the data after transposing, even for DataFrames</span>
<span class="sd">            with a single dtype.</span>

<span class="sd">            Note that a copy is always required for mixed dtype DataFrames,</span>
<span class="sd">            or for DataFrames with any extension types.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            The transposed DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.transpose : Permute the dimensions of a given array.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Transposing a DataFrame with mixed dtypes will result in a homogeneous</span>
<span class="sd">        DataFrame with the `object` dtype. In such a case, a copy of the data</span>
<span class="sd">        is always made.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        **Square DataFrame with homogeneous dtype**</span>

<span class="sd">        &gt;&gt;&gt; d1 = {&#39;col1&#39;: [1, 2], &#39;col2&#39;: [3, 4]}</span>
<span class="sd">        &gt;&gt;&gt; df1 = pd.DataFrame(data=d1)</span>
<span class="sd">        &gt;&gt;&gt; df1</span>
<span class="sd">           col1  col2</span>
<span class="sd">        0     1     3</span>
<span class="sd">        1     2     4</span>

<span class="sd">        &gt;&gt;&gt; df1_transposed = df1.T  # or df1.transpose()</span>
<span class="sd">        &gt;&gt;&gt; df1_transposed</span>
<span class="sd">              0  1</span>
<span class="sd">        col1  1  2</span>
<span class="sd">        col2  3  4</span>

<span class="sd">        When the dtype is homogeneous in the original DataFrame, we get a</span>
<span class="sd">        transposed DataFrame with the same dtype:</span>

<span class="sd">        &gt;&gt;&gt; df1.dtypes</span>
<span class="sd">        col1    int64</span>
<span class="sd">        col2    int64</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &gt;&gt;&gt; df1_transposed.dtypes</span>
<span class="sd">        0    int64</span>
<span class="sd">        1    int64</span>
<span class="sd">        dtype: object</span>

<span class="sd">        **Non-square DataFrame with mixed dtypes**</span>

<span class="sd">        &gt;&gt;&gt; d2 = {&#39;name&#39;: [&#39;Alice&#39;, &#39;Bob&#39;],</span>
<span class="sd">        ...       &#39;score&#39;: [9.5, 8],</span>
<span class="sd">        ...       &#39;employed&#39;: [False, True],</span>
<span class="sd">        ...       &#39;kids&#39;: [0, 0]}</span>
<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame(data=d2)</span>
<span class="sd">        &gt;&gt;&gt; df2</span>
<span class="sd">            name  score  employed  kids</span>
<span class="sd">        0  Alice    9.5     False     0</span>
<span class="sd">        1    Bob    8.0      True     0</span>

<span class="sd">        &gt;&gt;&gt; df2_transposed = df2.T  # or df2.transpose()</span>
<span class="sd">        &gt;&gt;&gt; df2_transposed</span>
<span class="sd">                      0     1</span>
<span class="sd">        name      Alice   Bob</span>
<span class="sd">        score       9.5   8.0</span>
<span class="sd">        employed  False  True</span>
<span class="sd">        kids          0     0</span>

<span class="sd">        When the DataFrame has mixed dtypes, we get a transposed DataFrame with</span>
<span class="sd">        the `object` dtype:</span>

<span class="sd">        &gt;&gt;&gt; df2.dtypes</span>
<span class="sd">        name         object</span>
<span class="sd">        score       float64</span>
<span class="sd">        employed       bool</span>
<span class="sd">        kids          int64</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &gt;&gt;&gt; df2_transposed.dtypes</span>
<span class="sd">        0    object</span>
<span class="sd">        1    object</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nv</span><span class="o">.</span><span class="n">validate_transpose</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">{})</span>
        <span class="c1"># construct the args</span>

        <span class="n">dtypes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_can_fast_transpose</span><span class="p">:</span>
            <span class="c1"># Note: tests pass without this, but this improves perf quite a bit.</span>
            <span class="n">new_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">T</span>
            <span class="k">if</span> <span class="n">copy</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">using_copy_on_write</span><span class="p">():</span>
                <span class="n">new_vals</span> <span class="o">=</span> <span class="n">new_vals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                <span class="n">new_vals</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">using_copy_on_write</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">add_references</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>

        <span class="k">elif</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_homogeneous_type</span> <span class="ow">and</span> <span class="n">dtypes</span> <span class="ow">and</span> <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="n">dtypes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">):</span>
            <span class="c1"># We have EAs with the same dtype. We can preserve that dtype in transpose.</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">arr_type</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">construct_array_type</span><span class="p">()</span>
            <span class="n">values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span>

            <span class="n">new_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr_type</span><span class="o">.</span><span class="n">_from_sequence</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_from_arrays</span><span class="p">(</span>
                <span class="n">new_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span>
            <span class="k">if</span> <span class="n">copy</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">using_copy_on_write</span><span class="p">():</span>
                <span class="n">new_arr</span> <span class="o">=</span> <span class="n">new_arr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                <span class="n">new_arr</span><span class="p">,</span>
                <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
                <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                <span class="c1"># We already made a copy (more than one block)</span>
                <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;transpose&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">T</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The transpose of the DataFrame.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            The transposed DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.transpose : Transpose index and columns.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;col1&#39;: [1, 2], &#39;col2&#39;: [3, 4]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           col1  col2</span>
<span class="sd">        0     1     3</span>
<span class="sd">        1     2     4</span>

<span class="sd">        &gt;&gt;&gt; df.T</span>
<span class="sd">              0  1</span>
<span class="sd">        col1  1  2</span>
<span class="sd">        col2  3  4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Indexing Methods</span>

    <span class="k">def</span> <span class="nf">_ixs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">AxisInt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i : int</span>
<span class="sd">        axis : int</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># irow</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_mgr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">fast_xs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="c1"># if we are a copy, mark as such</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_mgr</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">new_mgr</span><span class="o">.</span><span class="n">array</span><span class="o">.</span><span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span><span class="n">new_mgr</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span>
                <span class="bp">self</span>
            <span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_set_is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="c1"># icol</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="n">col_mgr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">iget</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_box_col_values</span><span class="p">(</span><span class="n">col_mgr</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

            <span class="c1"># this is a cached value, mark it so</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_set_as_cached</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_get_column_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the values of the i&#39;th column (ndarray or ExtensionArray, as stored</span>
<span class="sd">        in the Block)</span>

<span class="sd">        Warning! The returned array is a view but doesn&#39;t handle Copy-on-Write,</span>
<span class="sd">        so this should be used with caution (for read-only purposes).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">iget_values</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_iter_column_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the arrays of all columns in order.</span>
<span class="sd">        This returns the values as stored in the Block (ndarray or ExtensionArray).</span>

<span class="sd">        Warning! The returned array is a view but doesn&#39;t handle Copy-on-Write,</span>
<span class="sd">        so this should be used with caution (for read-only purposes).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_column_array</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_getitem_nocopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Behaves like __getitem__, but returns a view in cases where __getitem__</span>
<span class="sd">        would make a copy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO(CoW): can be removed if/when we are always Copy-on-Write</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_get_indexer_strict</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">new_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span>

        <span class="n">new_mgr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">reindex_indexer</span><span class="p">(</span>
            <span class="n">new_axis</span><span class="p">,</span>
            <span class="n">indexer</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">allow_dups</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">only_slice</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_mgr</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">check_dict_or_set_indexers</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">item_from_zerodim</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">apply_if_callable</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_hashable</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_iterator</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="c1"># is_iterator to exclude generator e.g. test_getitem_listlike</span>
            <span class="c1"># shortcut if the key is in columns</span>
            <span class="n">is_mi</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span>
            <span class="c1"># GH#45316 Return view if key is not duplicated</span>
            <span class="c1"># Only use drop_duplicates with duplicates for performance</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_mi</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">is_unique</span>
                <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
                <span class="ow">or</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_item_cache</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">is_mi</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">is_unique</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem_multilevel</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="c1"># Do we have a slicer (on rows)?</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_convert_slice_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;getitem&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="c1"># reachable with DatetimeIndex</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">maybe_indices_to_slice</span><span class="p">(</span>
                    <span class="n">indexer</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                    <span class="c1"># GH#43223 If we can not convert, use take</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Do we have a (boolean) DataFrame?</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="c1"># Do we have a (boolean) 1d indexer?</span>
        <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">is_bool_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem_bool_array</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="c1"># We are left with two options: a single key, and a collection of keys,</span>
        <span class="c1"># We interpret tuples as collections only for non-MultiIndex</span>
        <span class="n">is_single_key</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_single_key</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem_multilevel</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">indexer</span><span class="p">):</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="p">[</span><span class="n">indexer</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_iterator</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_get_indexer_strict</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># take() does not accept boolean indexers</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">indexer</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_take_with_is_copy</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_single_key</span><span class="p">:</span>
            <span class="c1"># What does looking for a single key in a non-unique index return?</span>
            <span class="c1"># The behavior is inconsistent. It returns a Series, except when</span>
            <span class="c1"># - the key itself is repeated (test on data.shape, #9519), or</span>
            <span class="c1"># - we have a MultiIndex on columns (test on self.columns, #21309)</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                <span class="c1"># GH#26490 using data[key] can cause RecursionError</span>
                <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">_get_item_cache</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">_getitem_bool_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># also raises Exception if object array with NA values</span>
        <span class="c1"># warning here just in case -- previously __setitem__ was</span>
        <span class="c1"># reindexing but __getitem__ was not; it seems more reasonable to</span>
        <span class="c1"># go with the __setitem__ behavior since that is more consistent</span>
        <span class="c1"># with all other indexing behavior</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">Series</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">key</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Boolean Series key will be reindexed to match DataFrame index.&quot;</span><span class="p">,</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
                <span class="n">stacklevel</span><span class="o">=</span><span class="n">find_stack_level</span><span class="p">(),</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Item wrong length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="si">}</span><span class="s2"> instead of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># check_bool_indexer will throw exception if Series key cannot</span>
        <span class="c1"># be reindexed to match DataFrame rows</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">check_bool_indexer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">indexer</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_take_with_is_copy</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_getitem_multilevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># self.columns is a MultiIndex</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="p">(</span><span class="nb">slice</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
            <span class="n">new_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>
            <span class="n">result_columns</span> <span class="o">=</span> <span class="n">maybe_droplevels</span><span class="p">(</span><span class="n">new_columns</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">loc</span><span class="p">]</span>
            <span class="n">result</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">result_columns</span>

            <span class="c1"># If there is only one column being returned, and its name is</span>
            <span class="c1"># either an empty string, or a tuple with an empty string as its</span>
            <span class="c1"># first element, then treat the empty string as a placeholder</span>
            <span class="c1"># and return the column as if the user had provided that empty</span>
            <span class="c1"># string in the key. If the result is a Series, exclude the</span>
            <span class="c1"># implied empty string from its name.</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># e.g. test_frame_getitem_multicolumn_empty_level,</span>
                <span class="c1">#  test_frame_mixed_depth_get, test_loc_setitem_single_column_slice</span>
                <span class="n">top</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">top</span> <span class="o">=</span> <span class="n">top</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">top</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span>
                            <span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">key</span>
                        <span class="p">)</span>

            <span class="n">result</span><span class="o">.</span><span class="n">_set_is_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># loc is neither a slice nor ndarray, so must be an int</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ixs</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">takeable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Scalar</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Quickly retrieve single value at passed column and index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : row label</span>
<span class="sd">        col : column label</span>
<span class="sd">        takeable : interpret the index/col as indexers, default False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scalar</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Assumes that both `self.index._index_as_unique` and</span>
<span class="sd">        `self.columns._index_as_unique`; Caller is responsible for checking.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">takeable</span><span class="p">:</span>
            <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ixs</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">series</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

        <span class="n">series</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_item_cache</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="n">engine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_engine</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="c1"># CategoricalIndex: Trying to use the engine fastpath may give incorrect</span>
            <span class="c1">#  results if our categories are integers that dont match our codes</span>
            <span class="c1"># IntervalIndex: IntervalTree has no get_loc</span>
            <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">series</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">row</span><span class="p">]</span>

        <span class="c1"># For MultiIndex going through engine effectively restricts us to</span>
        <span class="c1">#  same-length tuples; see test_get_set_value_no_partial_indexing</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">series</span><span class="o">.</span><span class="n">_values</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">isetitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the given value in the column with position `loc`.</span>

<span class="sd">        This is a positional analogue to ``__setitem__``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loc : int or sequence of ints</span>
<span class="sd">            Index position for the column.</span>
<span class="sd">        value : scalar or arraylike</span>
<span class="sd">            Value(s) for the column.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        ``frame.isetitem(loc, value)`` is an in-place method as it will</span>
<span class="sd">        modify the DataFrame in place (not returning a new object). In contrast to</span>
<span class="sd">        ``frame.iloc[:, i] = value`` which will try to update the existing values in</span>
<span class="sd">        place, ``frame.isetitem(loc, value)`` will not update the values of the column</span>
<span class="sd">        itself in place, it will instead insert a new array.</span>

<span class="sd">        In cases where ``frame.columns`` is unique, this is equivalent to</span>
<span class="sd">        ``frame[frame.columns[i]] = value``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">loc</span><span class="p">):</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="p">[</span><span class="n">loc</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">loc</span><span class="p">):</span>
                <span class="n">arraylike</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_column</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_iset_item_mgr</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">arraylike</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">arraylike</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_column</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_iset_item_mgr</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">arraylike</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">PYPY</span> <span class="ow">and</span> <span class="n">using_copy_on_write</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">getrefcount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="n">_chained_assignment_msg</span><span class="p">,</span> <span class="n">ChainedAssignmentError</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span>
                <span class="p">)</span>

        <span class="n">key</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">apply_if_callable</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c1"># see if we can slice the rows</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">slc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_convert_slice_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s2">&quot;getitem&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setitem_slice</span><span class="p">(</span><span class="n">slc</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot;ndim&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_setitem_frame</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">Index</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_setitem_array</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_item_frame_value</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">is_unique</span>
            <span class="ow">and</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_indexer_for</span><span class="p">([</span><span class="n">key</span><span class="p">]))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># Column to set is duplicated</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_setitem_array</span><span class="p">([</span><span class="n">key</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># set column</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_item</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setitem_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">slice</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># NB: we can&#39;t just use self.loc[key] = value because that</span>
        <span class="c1">#  operates on labels and we need to operate positional for</span>
        <span class="c1">#  backwards-compat, xref GH#31469</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_setitem_copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_setitem_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># also raises Exception if object array with NA values</span>
        <span class="k">if</span> <span class="n">com</span><span class="o">.</span><span class="n">is_bool_indexer</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="c1"># bool indexer is indexing along rows</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Item wrong length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="si">}</span><span class="s2"> instead of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="si">}</span><span class="s2">!&quot;</span>
                <span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">check_bool_indexer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_setitem_copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
                <span class="c1"># GH#39931 reindex since iloc does not align</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexer</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">indexer</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Note: unlike self.iloc[:, indexer] = value, this will</span>
            <span class="c1">#  never try to overwrite values inplace</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
                <span class="n">check_key_length</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">k1</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">k2</span><span class="p">]</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">key</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_iset_not_inplace</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># list of lists</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_setitem_array</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_iset_not_inplace</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_iset_not_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># GH#39510 when setting with df[key] = obj with a list-like key and</span>
        <span class="c1">#  list-like value, we iterate over those listlikes and set columns</span>
        <span class="c1">#  one at a time.  This is different from dispatching to</span>
        <span class="c1">#  `self.loc[:, key]= value`  because loc.__setitem__ may overwrite</span>
        <span class="c1">#  data inplace, whereas this will insert new arrays.</span>

        <span class="k">def</span> <span class="nf">igetitem</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
            <span class="c1"># Note: we catch DataFrame obj before getting here, but</span>
            <span class="c1">#  hypothetically would return obj.iloc[:, i]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">obj</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">obj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">value</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Columns must be same length as key&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">igetitem</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">ilocs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_indexer_non_unique</span><span class="p">(</span><span class="n">key</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ilocs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="c1"># key entries not in self.columns</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">value</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ilocs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Columns must be same length as key&quot;</span><span class="p">)</span>

            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span>

            <span class="n">orig_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>

            <span class="c1"># Using self.iloc[:, i] = ... may set values inplace, which</span>
            <span class="c1">#  by convention we do not do in __setitem__</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">iloc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ilocs</span><span class="p">):</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">iloc</span><span class="p">]</span> <span class="o">=</span> <span class="n">igetitem</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">orig_columns</span>

    <span class="k">def</span> <span class="nf">_setitem_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># support boolean setting with DataFrame input, e.g.</span>
        <span class="c1"># df[df &gt; df2] = 0</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Array conditional must be same shape as self&quot;</span><span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_construct_axes_dict</span><span class="p">(),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="n">key</span><span class="o">.</span><span class="n">dtypes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;Must pass DataFrame or 2-d ndarray with boolean values only&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_inplace_setting</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_setitem_copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_where</span><span class="p">(</span><span class="o">-</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_item_frame_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_valid_index</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># align columns</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>
            <span class="n">len_cols</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">len_cols</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Columns must be same length as key&quot;</span><span class="p">)</span>

            <span class="c1"># align right-hand-side columns if self.columns</span>
            <span class="c1"># is multi-index and self[key] is a sub-frame</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">loc</span><span class="p">,</span> <span class="p">(</span><span class="nb">slice</span><span class="p">,</span> <span class="n">Series</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Index</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="n">cols_droplevel</span> <span class="o">=</span> <span class="n">maybe_droplevels</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols_droplevel</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cols_droplevel</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">cols_droplevel</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">col_droplevel</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">cols_droplevel</span><span class="p">):</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">col_droplevel</span><span class="p">]</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">value</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">return</span>

            <span class="c1"># now align rows</span>
            <span class="n">arraylike</span> <span class="o">=</span> <span class="n">_reindex_for_setitem</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_item_mgr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">arraylike</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot set a DataFrame with multiple columns to the single &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;column </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="n">value</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">_iset_item_mgr</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">slice</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># when called from _set_item_mgr loc can be anything returned from get_loc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">iset</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_set_item_mgr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># This item wasn&#39;t present, just insert at end</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="p">),</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_iset_item_mgr</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="c1"># check if we are modifying a copy</span>
        <span class="c1"># try to set first as we want an invalid</span>
        <span class="c1"># value exception to occur first</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_setitem_copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_iset_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">arraylike</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_column</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_iset_item_mgr</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">arraylike</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># check if we are modifying a copy</span>
        <span class="c1"># try to set first as we want an invalid</span>
        <span class="c1"># value exception to occur first</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_setitem_copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_set_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add series to DataFrame in specified column.</span>

<span class="sd">        If series is a numpy-array (not a Series/TimeSeries), it must be the</span>
<span class="sd">        same length as the DataFrames index or an error will be thrown.</span>

<span class="sd">        Series/TimeSeries will be conformed to the DataFrames index to</span>
<span class="sd">        ensure homogeneity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_column</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
            <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_extension_array_dtype</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="c1"># broadcast across multiple columns if necessary</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">is_unique</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                <span class="n">existing_piece</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">existing_piece</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">existing_piece</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_item_mgr</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_value</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="n">IndexLabel</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Scalar</span><span class="p">,</span> <span class="n">takeable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Put single value at passed column and index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : Label</span>
<span class="sd">            row label</span>
<span class="sd">        col : Label</span>
<span class="sd">            column label</span>
<span class="sd">        value : scalar</span>
<span class="sd">        takeable : bool, default False</span>
<span class="sd">            Sets whether or not index/col interpreted as indexers</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">takeable</span><span class="p">:</span>
                <span class="n">icol</span> <span class="o">=</span> <span class="n">col</span>
                <span class="n">iindex</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">icol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                <span class="n">iindex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">column_setitem</span><span class="p">(</span><span class="n">icol</span><span class="p">,</span> <span class="n">iindex</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">inplace_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_clear_item_cache</span><span class="p">()</span>

        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="n">LossySetitemError</span><span class="p">):</span>
            <span class="c1"># get_loc might raise a KeyError for missing labels (falling back</span>
            <span class="c1">#  to (i)loc will do expansion of the index)</span>
            <span class="c1"># column_setitem will do validation that may raise TypeError,</span>
            <span class="c1">#  ValueError, or LossySetitemError</span>
            <span class="c1"># set using a non-recursive method &amp; reset the cache</span>
            <span class="k">if</span> <span class="n">takeable</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_item_cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">except</span> <span class="n">InvalidIndexError</span> <span class="k">as</span> <span class="n">ii_err</span><span class="p">:</span>
            <span class="c1"># GH48729: Seems like you are trying to assign a value to a</span>
            <span class="c1"># row when only scalar options are permitted</span>
            <span class="k">raise</span> <span class="n">InvalidIndexError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;You can only assign a scalar value not a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span> <span class="kn">from</span> <span class="nn">ii_err</span>

    <span class="k">def</span> <span class="nf">_ensure_valid_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensure that if we don&#39;t have an index, that we can create one from the</span>
<span class="sd">        passed value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># GH5632, make sure that we are a Series convertible</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">NotImplementedError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Cannot set a frame with no defined index &quot;</span>
                        <span class="s2">&quot;and a value that cannot be converted to a Series&quot;</span>
                    <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

            <span class="c1"># GH31368 preserve name of index</span>
            <span class="n">index_copy</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">index_copy</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">reindex_axis</span><span class="p">(</span><span class="n">index_copy</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_box_col_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">SingleDataManager</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provide boxed values for a column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Lookup in columns so that if e.g. a str datetime was passed</span>
        <span class="c1">#  we attach the Timestamp object as the name.</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span>
        <span class="n">klass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span>
        <span class="c1"># We get index=self.index bc values is a SingleDataManager</span>
        <span class="k">return</span> <span class="n">klass</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Lookup Caching</span>

    <span class="k">def</span> <span class="nf">_clear_item_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_item_cache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_item_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the cached item, item represents a label indexer.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">using_copy_on_write</span><span class="p">():</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ixs</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_item_cache</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># All places that call _get_item_cache have unique columns,</span>
            <span class="c1">#  pending resolution of GH#33047</span>

            <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ixs</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">cache</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span>

            <span class="c1"># for a chain</span>
            <span class="n">res</span><span class="o">.</span><span class="n">_is_copy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_copy</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">_reset_cacher</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># no-op for DataFrame</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_maybe_cache_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Series</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The object has called back to us saying maybe it has changed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_info_axis</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="n">arraylike</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">_values</span>

        <span class="n">old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ixs</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">old</span><span class="o">.</span><span class="n">_values</span> <span class="ow">is</span> <span class="n">value</span><span class="o">.</span><span class="n">_values</span> <span class="ow">and</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="c1"># GH#46149 avoid making unnecessary copies/block-splitting</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">iset</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">arraylike</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Unsorted</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Query the columns of a DataFrame with a boolean expression.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expr : str</span>
<span class="sd">            The query string to evaluate.</span>

<span class="sd">            You can refer to variables</span>
<span class="sd">            in the environment by prefixing them with an &#39;@&#39; character like</span>
<span class="sd">            ``@a + b``.</span>

<span class="sd">            You can refer to column names that are not valid Python variable names</span>
<span class="sd">            by surrounding them in backticks. Thus, column names containing spaces</span>
<span class="sd">            or punctuations (besides underscores) or starting with digits must be</span>
<span class="sd">            surrounded by backticks. (For example, a column named &quot;Area (cm^2)&quot; would</span>
<span class="sd">            be referenced as ```Area (cm^2)```). Column names which are Python keywords</span>
<span class="sd">            (like &quot;list&quot;, &quot;for&quot;, &quot;import&quot;, etc) cannot be used.</span>

<span class="sd">            For example, if one of your columns is called ``a a`` and you want</span>
<span class="sd">            to sum it with ``b``, your query should be ```a a` + b``.</span>

<span class="sd">        inplace : bool</span>
<span class="sd">            Whether to modify the DataFrame rather than creating a new one.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            See the documentation for :func:`eval` for complete details</span>
<span class="sd">            on the keyword arguments accepted by :meth:`DataFrame.query`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame or None</span>
<span class="sd">            DataFrame resulting from the provided query expression or</span>
<span class="sd">            None if ``inplace=True``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        eval : Evaluate a string describing operations on</span>
<span class="sd">            DataFrame columns.</span>
<span class="sd">        DataFrame.eval : Evaluate a string describing operations on</span>
<span class="sd">            DataFrame columns.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The result of the evaluation of this expression is first passed to</span>
<span class="sd">        :attr:`DataFrame.loc` and if that fails because of a</span>
<span class="sd">        multidimensional key (e.g., a DataFrame) then the result will be passed</span>
<span class="sd">        to :meth:`DataFrame.__getitem__`.</span>

<span class="sd">        This method uses the top-level :func:`eval` function to</span>
<span class="sd">        evaluate the passed query.</span>

<span class="sd">        The :meth:`~pandas.DataFrame.query` method uses a slightly</span>
<span class="sd">        modified Python syntax by default. For example, the ``&amp;`` and ``|``</span>
<span class="sd">        (bitwise) operators have the precedence of their boolean cousins,</span>
<span class="sd">        :keyword:`and` and :keyword:`or`. This *is* syntactically valid Python,</span>
<span class="sd">        however the semantics are different.</span>

<span class="sd">        You can change the semantics of the expression by passing the keyword</span>
<span class="sd">        argument ``parser=&#39;python&#39;``. This enforces the same semantics as</span>
<span class="sd">        evaluation in Python space. Likewise, you can pass ``engine=&#39;python&#39;``</span>
<span class="sd">        to evaluate an expression using Python itself as a backend. This is not</span>
<span class="sd">        recommended as it is inefficient compared to using ``numexpr`` as the</span>
<span class="sd">        engine.</span>

<span class="sd">        The :attr:`DataFrame.index` and</span>
<span class="sd">        :attr:`DataFrame.columns` attributes of the</span>
<span class="sd">        :class:`~pandas.DataFrame` instance are placed in the query namespace</span>
<span class="sd">        by default, which allows you to treat both the index and columns of the</span>
<span class="sd">        frame as a column in the frame.</span>
<span class="sd">        The identifier ``index`` is used for the frame index; you can also</span>
<span class="sd">        use the name of the index to identify it in a query. Please note that</span>
<span class="sd">        Python keywords may not be used as identifiers.</span>

<span class="sd">        For further details and examples see the ``query`` documentation in</span>
<span class="sd">        :ref:`indexing &lt;indexing.query&gt;`.</span>

<span class="sd">        *Backtick quoted variables*</span>

<span class="sd">        Backtick quoted variables are parsed as literal Python code and</span>
<span class="sd">        are converted internally to a Python valid identifier.</span>
<span class="sd">        This can lead to the following problems.</span>

<span class="sd">        During parsing a number of disallowed characters inside the backtick</span>
<span class="sd">        quoted string are replaced by strings that are allowed as a Python identifier.</span>
<span class="sd">        These characters include all operators in Python, the space character, the</span>
<span class="sd">        question mark, the exclamation mark, the dollar sign, and the euro sign.</span>
<span class="sd">        For other characters that fall outside the ASCII range (U+0001..U+007F)</span>
<span class="sd">        and those that are not further specified in PEP 3131,</span>
<span class="sd">        the query parser will raise an error.</span>
<span class="sd">        This excludes whitespace different than the space character,</span>
<span class="sd">        but also the hashtag (as it is used for comments) and the backtick</span>
<span class="sd">        itself (backtick can also not be escaped).</span>

<span class="sd">        In a special case, quotes that make a pair around a backtick can</span>
<span class="sd">        confuse the parser.</span>
<span class="sd">        For example, ```it&#39;s` &gt; `that&#39;s``` will raise an error,</span>
<span class="sd">        as it forms a quoted string (``&#39;s &gt; `that&#39;``) with a backtick inside.</span>

<span class="sd">        See also the Python documentation about lexical analysis</span>
<span class="sd">        (https://docs.python.org/3/reference/lexical_analysis.html)</span>
<span class="sd">        in combination with the source code in :mod:`pandas.core.computation.parsing`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: range(1, 6),</span>
<span class="sd">        ...                    &#39;B&#39;: range(10, 0, -2),</span>
<span class="sd">        ...                    &#39;C C&#39;: range(10, 5, -1)})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A   B  C C</span>
<span class="sd">        0  1  10   10</span>
<span class="sd">        1  2   8    9</span>
<span class="sd">        2  3   6    8</span>
<span class="sd">        3  4   4    7</span>
<span class="sd">        4  5   2    6</span>
<span class="sd">        &gt;&gt;&gt; df.query(&#39;A &gt; B&#39;)</span>
<span class="sd">           A  B  C C</span>
<span class="sd">        4  5  2    6</span>

<span class="sd">        The previous expression is equivalent to</span>

<span class="sd">        &gt;&gt;&gt; df[df.A &gt; df.B]</span>
<span class="sd">           A  B  C C</span>
<span class="sd">        4  5  2    6</span>

<span class="sd">        For columns with spaces in their name, you can use backtick quoting.</span>

<span class="sd">        &gt;&gt;&gt; df.query(&#39;B == `C C`&#39;)</span>
<span class="sd">           A   B  C C</span>
<span class="sd">        0  1  10   10</span>

<span class="sd">        The previous expression is equivalent to</span>

<span class="sd">        &gt;&gt;&gt; df[df.B == df[&#39;C C&#39;]]</span>
<span class="sd">           A   B  C C</span>
<span class="sd">        0  1  10   10</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;expr must be a string to be evaluated, </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="si">}</span><span class="s2"> given&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;level&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;level&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">res</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># when res is multi-dimensional loc raises, but this is sometimes a</span>
            <span class="c1"># valid query</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">res</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate a string describing operations on DataFrame columns.</span>

<span class="sd">        Operates on columns only, not specific rows or elements.  This allows</span>
<span class="sd">        `eval` to run arbitrary code, which can make you vulnerable to code</span>
<span class="sd">        injection if you pass user input to this function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expr : str</span>
<span class="sd">            The expression string to evaluate.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If the expression contains an assignment, whether to perform the</span>
<span class="sd">            operation inplace and mutate the existing DataFrame. Otherwise,</span>
<span class="sd">            a new DataFrame is returned.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            See the documentation for :func:`eval` for complete details</span>
<span class="sd">            on the keyword arguments accepted by</span>
<span class="sd">            :meth:`~pandas.DataFrame.query`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray, scalar, pandas object, or None</span>
<span class="sd">            The result of the evaluation or None if ``inplace=True``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.query : Evaluates a boolean expression to query the columns</span>
<span class="sd">            of a frame.</span>
<span class="sd">        DataFrame.assign : Can evaluate an expression or function to create new</span>
<span class="sd">            values for a column.</span>
<span class="sd">        eval : Evaluate a Python expression as a string using various</span>
<span class="sd">            backends.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For more details see the API documentation for :func:`~eval`.</span>
<span class="sd">        For detailed examples see :ref:`enhancing performance with eval</span>
<span class="sd">        &lt;enhancingperf.eval&gt;`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: range(1, 6), &#39;B&#39;: range(10, 0, -2)})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A   B</span>
<span class="sd">        0  1  10</span>
<span class="sd">        1  2   8</span>
<span class="sd">        2  3   6</span>
<span class="sd">        3  4   4</span>
<span class="sd">        4  5   2</span>
<span class="sd">        &gt;&gt;&gt; df.eval(&#39;A + B&#39;)</span>
<span class="sd">        0    11</span>
<span class="sd">        1    10</span>
<span class="sd">        2     9</span>
<span class="sd">        3     8</span>
<span class="sd">        4     7</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Assignment is allowed though by default the original DataFrame is not</span>
<span class="sd">        modified.</span>

<span class="sd">        &gt;&gt;&gt; df.eval(&#39;C = A + B&#39;)</span>
<span class="sd">           A   B   C</span>
<span class="sd">        0  1  10  11</span>
<span class="sd">        1  2   8  10</span>
<span class="sd">        2  3   6   9</span>
<span class="sd">        3  4   4   8</span>
<span class="sd">        4  5   2   7</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A   B</span>
<span class="sd">        0  1  10</span>
<span class="sd">        1  2   8</span>
<span class="sd">        2  3   6</span>
<span class="sd">        3  4   4</span>
<span class="sd">        4  5   2</span>

<span class="sd">        Multiple columns can be assigned to using multi-line expressions:</span>

<span class="sd">        &gt;&gt;&gt; df.eval(</span>
<span class="sd">        ...     &#39;&#39;&#39;</span>
<span class="sd">        ... C = A + B</span>
<span class="sd">        ... D = A - B</span>
<span class="sd">        ... &#39;&#39;&#39;</span>
<span class="sd">        ... )</span>
<span class="sd">           A   B   C  D</span>
<span class="sd">        0  1  10  11 -9</span>
<span class="sd">        1  2   8  10 -6</span>
<span class="sd">        2  3   6   9 -3</span>
<span class="sd">        3  4   4   8  0</span>
<span class="sd">        4  5   2   7  3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.computation.eval</span> <span class="kn">import</span> <span class="nb">eval</span> <span class="k">as</span> <span class="n">_eval</span>

        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;level&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;level&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">index_resolvers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_index_resolvers</span><span class="p">()</span>
        <span class="n">column_resolvers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_cleaned_column_resolvers</span><span class="p">()</span>
        <span class="n">resolvers</span> <span class="o">=</span> <span class="n">column_resolvers</span><span class="p">,</span> <span class="n">index_resolvers</span>
        <span class="k">if</span> <span class="s2">&quot;target&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;target&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;resolvers&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;resolvers&quot;</span><span class="p">,</span> <span class="p">()))</span> <span class="o">+</span> <span class="n">resolvers</span>

        <span class="k">return</span> <span class="n">_eval</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">select_dtypes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a subset of the DataFrame&#39;s columns based on the column dtypes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        include, exclude : scalar or list-like</span>
<span class="sd">            A selection of dtypes or strings to be included/excluded. At least</span>
<span class="sd">            one of these parameters must be supplied.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            The subset of the frame including the dtypes in ``include`` and</span>
<span class="sd">            excluding the dtypes in ``exclude``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            * If both of ``include`` and ``exclude`` are empty</span>
<span class="sd">            * If ``include`` and ``exclude`` have overlapping elements</span>
<span class="sd">            * If any kind of string dtype is passed in.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.dtypes: Return Series with the data type of each column.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        * To select all *numeric* types, use ``np.number`` or ``&#39;number&#39;``</span>
<span class="sd">        * To select strings you must use the ``object`` dtype, but note that</span>
<span class="sd">          this will return *all* object dtype columns</span>
<span class="sd">        * See the `numpy dtype hierarchy</span>
<span class="sd">          &lt;https://numpy.org/doc/stable/reference/arrays.scalars.html&gt;`__</span>
<span class="sd">        * To select datetimes, use ``np.datetime64``, ``&#39;datetime&#39;`` or</span>
<span class="sd">          ``&#39;datetime64&#39;``</span>
<span class="sd">        * To select timedeltas, use ``np.timedelta64``, ``&#39;timedelta&#39;`` or</span>
<span class="sd">          ``&#39;timedelta64&#39;``</span>
<span class="sd">        * To select Pandas categorical dtypes, use ``&#39;category&#39;``</span>
<span class="sd">        * To select Pandas datetimetz dtypes, use ``&#39;datetimetz&#39;`` (new in</span>
<span class="sd">          0.20.0) or ``&#39;datetime64[ns, tz]&#39;``</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;a&#39;: [1, 2] * 3,</span>
<span class="sd">        ...                    &#39;b&#39;: [True, False] * 3,</span>
<span class="sd">        ...                    &#39;c&#39;: [1.0, 2.0] * 3})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                a      b  c</span>
<span class="sd">        0       1   True  1.0</span>
<span class="sd">        1       2  False  2.0</span>
<span class="sd">        2       1   True  1.0</span>
<span class="sd">        3       2  False  2.0</span>
<span class="sd">        4       1   True  1.0</span>
<span class="sd">        5       2  False  2.0</span>

<span class="sd">        &gt;&gt;&gt; df.select_dtypes(include=&#39;bool&#39;)</span>
<span class="sd">           b</span>
<span class="sd">        0  True</span>
<span class="sd">        1  False</span>
<span class="sd">        2  True</span>
<span class="sd">        3  False</span>
<span class="sd">        4  True</span>
<span class="sd">        5  False</span>

<span class="sd">        &gt;&gt;&gt; df.select_dtypes(include=[&#39;float64&#39;])</span>
<span class="sd">           c</span>
<span class="sd">        0  1.0</span>
<span class="sd">        1  2.0</span>
<span class="sd">        2  1.0</span>
<span class="sd">        3  2.0</span>
<span class="sd">        4  1.0</span>
<span class="sd">        5  2.0</span>

<span class="sd">        &gt;&gt;&gt; df.select_dtypes(exclude=[&#39;int64&#39;])</span>
<span class="sd">               b    c</span>
<span class="sd">        0   True  1.0</span>
<span class="sd">        1  False  2.0</span>
<span class="sd">        2   True  1.0</span>
<span class="sd">        3  False  2.0</span>
<span class="sd">        4   True  1.0</span>
<span class="sd">        5  False  2.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">include</span><span class="p">):</span>
            <span class="n">include</span> <span class="o">=</span> <span class="p">(</span><span class="n">include</span><span class="p">,)</span> <span class="k">if</span> <span class="n">include</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">exclude</span><span class="p">):</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="p">(</span><span class="n">exclude</span><span class="p">,)</span> <span class="k">if</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">()</span>

        <span class="n">selection</span> <span class="o">=</span> <span class="p">(</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">include</span><span class="p">),</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">exclude</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">selection</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;at least one of include or exclude must be nonempty&quot;</span><span class="p">)</span>

        <span class="c1"># convert the myriad valid dtypes object to a single representation</span>
        <span class="k">def</span> <span class="nf">check_int_infer_dtype</span><span class="p">(</span><span class="n">dtypes</span><span class="p">):</span>
            <span class="n">converted_dtypes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">type</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="n">dtypes</span><span class="p">:</span>
                <span class="c1"># Numpy maps int to different types (int32, in64) on Windows and Linux</span>
                <span class="c1"># see https://github.com/numpy/numpy/issues/9464</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">dtype</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">):</span>
                    <span class="n">converted_dtypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                    <span class="n">converted_dtypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;float&quot;</span> <span class="ow">or</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="nb">float</span><span class="p">:</span>
                    <span class="c1"># GH#42452 : np.dtype(&quot;float&quot;) coerces to np.float64 from Numpy 1.20</span>
                    <span class="n">converted_dtypes</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">converted_dtypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">infer_dtype_from_object</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">converted_dtypes</span><span class="p">)</span>

        <span class="n">include</span> <span class="o">=</span> <span class="n">check_int_infer_dtype</span><span class="p">(</span><span class="n">include</span><span class="p">)</span>
        <span class="n">exclude</span> <span class="o">=</span> <span class="n">check_int_infer_dtype</span><span class="p">(</span><span class="n">exclude</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">dtypes</span> <span class="ow">in</span> <span class="p">(</span><span class="n">include</span><span class="p">,</span> <span class="n">exclude</span><span class="p">):</span>
            <span class="n">invalidate_string_dtypes</span><span class="p">(</span><span class="n">dtypes</span><span class="p">)</span>

        <span class="c1"># can&#39;t both include AND exclude!</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">include</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">exclude</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;include and exclude overlap on </span><span class="si">{</span><span class="p">(</span><span class="n">include</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">exclude</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">dtype_predicate</span><span class="p">(</span><span class="n">dtype</span><span class="p">:</span> <span class="n">DtypeObj</span><span class="p">,</span> <span class="n">dtypes_set</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="c1"># GH 46870: BooleanDtype._is_numeric == True but should be excluded</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ArrowDtype</span><span class="p">)</span> <span class="k">else</span> <span class="n">dtype</span><span class="o">.</span><span class="n">numpy_dtype</span>
            <span class="k">return</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dtypes_set</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">number</span> <span class="ow">in</span> <span class="n">dtypes_set</span>
                <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;_is_numeric&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">predicate</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span>
            <span class="k">if</span> <span class="n">include</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">dtype_predicate</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">include</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">exclude</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dtype_predicate</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">exclude</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>

            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">mgr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">_get_data_subset</span><span class="p">(</span><span class="n">predicate</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">mgr</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">loc</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">column</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">Scalar</span> <span class="o">|</span> <span class="n">AnyArrayLike</span><span class="p">,</span>
        <span class="n">allow_duplicates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="n">lib</span><span class="o">.</span><span class="n">NoDefault</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert column into DataFrame at specified location.</span>

<span class="sd">        Raises a ValueError if `column` is already contained in the DataFrame,</span>
<span class="sd">        unless `allow_duplicates` is set to True.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loc : int</span>
<span class="sd">            Insertion index. Must verify 0 &lt;= loc &lt;= len(columns).</span>
<span class="sd">        column : str, number, or hashable object</span>
<span class="sd">            Label of the inserted column.</span>
<span class="sd">        value : Scalar, Series, or array-like</span>
<span class="sd">        allow_duplicates : bool, optional, default lib.no_default</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index.insert : Insert new item by index.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;col1&#39;: [1, 2], &#39;col2&#39;: [3, 4]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           col1  col2</span>
<span class="sd">        0     1     3</span>
<span class="sd">        1     2     4</span>
<span class="sd">        &gt;&gt;&gt; df.insert(1, &quot;newcol&quot;, [99, 99])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           col1  newcol  col2</span>
<span class="sd">        0     1      99     3</span>
<span class="sd">        1     2      99     4</span>
<span class="sd">        &gt;&gt;&gt; df.insert(0, &quot;col1&quot;, [100, 100], allow_duplicates=True)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           col1  col1  newcol  col2</span>
<span class="sd">        0   100     1      99     3</span>
<span class="sd">        1   100     2      99     4</span>

<span class="sd">        Notice that pandas uses index alignment in case of `value` from type `Series`:</span>

<span class="sd">        &gt;&gt;&gt; df.insert(0, &quot;col0&quot;, pd.Series([5, 6], index=[1, 2]))</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           col0  col1  col1  newcol  col2</span>
<span class="sd">        0   NaN   100     1      99     3</span>
<span class="sd">        1   5.0   100     2      99     4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">allow_duplicates</span> <span class="ow">is</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">:</span>
            <span class="n">allow_duplicates</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">allow_duplicates</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">allows_duplicate_labels</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot specify &#39;allow_duplicates=True&#39; when &quot;</span>
                <span class="s2">&quot;&#39;self.flags.allows_duplicate_labels&#39; is False.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_duplicates</span> <span class="ow">and</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c1"># Should this be a different kind of error??</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot insert </span><span class="si">{</span><span class="n">column</span><span class="si">}</span><span class="s2">, already exists&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;loc must be int&quot;</span><span class="p">)</span>

        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_column</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign new columns to a DataFrame.</span>

<span class="sd">        Returns a new object with all original columns in addition to new ones.</span>
<span class="sd">        Existing columns that are re-assigned will be overwritten.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs : dict of {str: callable or Series}</span>
<span class="sd">            The column names are keywords. If the values are</span>
<span class="sd">            callable, they are computed on the DataFrame and</span>
<span class="sd">            assigned to the new columns. The callable must not</span>
<span class="sd">            change input DataFrame (though pandas doesn&#39;t check it).</span>
<span class="sd">            If the values are not callable, (e.g. a Series, scalar, or array),</span>
<span class="sd">            they are simply assigned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            A new DataFrame with the new columns in addition to</span>
<span class="sd">            all the existing columns.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Assigning multiple columns within the same ``assign`` is possible.</span>
<span class="sd">        Later items in &#39;\*\*kwargs&#39; may refer to newly created or modified</span>
<span class="sd">        columns in &#39;df&#39;; items are computed and assigned into &#39;df&#39; in order.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;temp_c&#39;: [17.0, 25.0]},</span>
<span class="sd">        ...                   index=[&#39;Portland&#39;, &#39;Berkeley&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                  temp_c</span>
<span class="sd">        Portland    17.0</span>
<span class="sd">        Berkeley    25.0</span>

<span class="sd">        Where the value is a callable, evaluated on `df`:</span>

<span class="sd">        &gt;&gt;&gt; df.assign(temp_f=lambda x: x.temp_c * 9 / 5 + 32)</span>
<span class="sd">                  temp_c  temp_f</span>
<span class="sd">        Portland    17.0    62.6</span>
<span class="sd">        Berkeley    25.0    77.0</span>

<span class="sd">        Alternatively, the same behavior can be achieved by directly</span>
<span class="sd">        referencing an existing Series or sequence:</span>

<span class="sd">        &gt;&gt;&gt; df.assign(temp_f=df[&#39;temp_c&#39;] * 9 / 5 + 32)</span>
<span class="sd">                  temp_c  temp_f</span>
<span class="sd">        Portland    17.0    62.6</span>
<span class="sd">        Berkeley    25.0    77.0</span>

<span class="sd">        You can create multiple columns within the same assign where one</span>
<span class="sd">        of the columns depends on another one defined within the same assign:</span>

<span class="sd">        &gt;&gt;&gt; df.assign(temp_f=lambda x: x[&#39;temp_c&#39;] * 9 / 5 + 32,</span>
<span class="sd">        ...           temp_k=lambda x: (x[&#39;temp_f&#39;] + 459.67) * 5 / 9)</span>
<span class="sd">                  temp_c  temp_f  temp_k</span>
<span class="sd">        Portland    17.0    62.6  290.15</span>
<span class="sd">        Berkeley    25.0    77.0  298.15</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">com</span><span class="o">.</span><span class="n">apply_if_callable</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">_sanitize_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ensures new columns (which go into the BlockManager as new blocks) are</span>
<span class="sd">        always copied and converted into an array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : scalar, Series, or array-like</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray or ExtensionArray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_valid_index</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># We can get there through isetitem with a DataFrame</span>
        <span class="c1"># or through loc single_block_path</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_reindex_for_setitem</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">_reindex_for_setitem</span><span class="p">(</span><span class="n">Series</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="n">com</span><span class="o">.</span><span class="n">require_length_match</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sanitize_array</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_2d</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_series</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">item</span><span class="p">:</span> <span class="n">Series</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">iget</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">item</span><span class="p">,</span> <span class="n">fastpath</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="p">}</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Reindexing and alignment</span>

    <span class="k">def</span> <span class="nf">_reindex_axes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">copy</span><span class="p">):</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">columns</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="s2">&quot;columns&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">_reindex_columns</span><span class="p">(</span>
                <span class="n">columns</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span>
            <span class="p">)</span>

        <span class="n">index</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">_reindex_index</span><span class="p">(</span>
                <span class="n">index</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">frame</span>

    <span class="k">def</span> <span class="nf">_reindex_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">new_index</span><span class="p">,</span>
        <span class="n">method</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">new_index</span><span class="p">,</span> <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
            <span class="n">new_index</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_with_indexers</span><span class="p">(</span>
            <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="n">new_index</span><span class="p">,</span> <span class="n">indexer</span><span class="p">]},</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
            <span class="n">allow_dups</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reindex_columns</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">new_columns</span><span class="p">,</span>
        <span class="n">method</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">new_columns</span><span class="p">,</span> <span class="n">indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
            <span class="n">new_columns</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_with_indexers</span><span class="p">(</span>
            <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="n">new_columns</span><span class="p">,</span> <span class="n">indexer</span><span class="p">]},</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
            <span class="n">allow_dups</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reindex_multi</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Index</span><span class="p">],</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">fill_value</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        We are guaranteed non-Nones in the axes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new_index</span><span class="p">,</span> <span class="n">row_indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">])</span>
        <span class="n">new_columns</span><span class="p">,</span> <span class="n">col_indexer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="s2">&quot;columns&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">row_indexer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">col_indexer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Fastpath. By doing two &#39;take&#39;s at once we avoid making an</span>
            <span class="c1">#  unnecessary copy.</span>
            <span class="c1"># We only get here with `not self._is_mixed_type`, which (almost)</span>
            <span class="c1">#  ensures that self.values is cheap. It may be worth making this</span>
            <span class="c1">#  condition more specific.</span>
            <span class="n">indexer</span> <span class="o">=</span> <span class="n">row_indexer</span><span class="p">,</span> <span class="n">col_indexer</span>
            <span class="n">new_values</span> <span class="o">=</span> <span class="n">take_2d_multi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">indexer</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                <span class="n">new_values</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">new_columns</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reindex_with_indexers</span><span class="p">(</span>
                <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="n">new_index</span><span class="p">,</span> <span class="n">row_indexer</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="n">new_columns</span><span class="p">,</span> <span class="n">col_indexer</span><span class="p">]},</span>
                <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">NDFrame</span><span class="o">.</span><span class="n">align</span><span class="p">,</span> <span class="o">**</span><span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">align</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">join</span><span class="p">:</span> <span class="n">AlignJoin</span> <span class="o">=</span> <span class="s2">&quot;outer&quot;</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">FillnaOptions</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">broadcast_axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">align</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="n">join</span><span class="o">=</span><span class="n">join</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
            <span class="n">fill_axis</span><span class="o">=</span><span class="n">fill_axis</span><span class="p">,</span>
            <span class="n">broadcast_axis</span><span class="o">=</span><span class="n">broadcast_axis</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [1, 2, 3], &quot;B&quot;: [4, 5, 6]})</span>

<span class="sd">        Change the row labels.</span>

<span class="sd">        &gt;&gt;&gt; df.set_axis([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], axis=&#39;index&#39;)</span>
<span class="sd">           A  B</span>
<span class="sd">        a  1  4</span>
<span class="sd">        b  2  5</span>
<span class="sd">        c  3  6</span>

<span class="sd">        Change the column labels.</span>

<span class="sd">        &gt;&gt;&gt; df.set_axis([&#39;I&#39;, &#39;II&#39;], axis=&#39;columns&#39;)</span>
<span class="sd">           I  II</span>
<span class="sd">        0  1   4</span>
<span class="sd">        1  2   5</span>
<span class="sd">        2  3   6</span>
<span class="sd">        &quot;&quot;&quot;</span>
    <span class="p">)</span>
    <span class="nd">@Substitution</span><span class="p">(</span>
        <span class="o">**</span><span class="n">_shared_doc_kwargs</span><span class="p">,</span>
        <span class="n">extended_summary_sub</span><span class="o">=</span><span class="s2">&quot; column or&quot;</span><span class="p">,</span>
        <span class="n">axis_description_sub</span><span class="o">=</span><span class="s2">&quot;, and 1 identifies the columns&quot;</span><span class="p">,</span>
        <span class="n">see_also_sub</span><span class="o">=</span><span class="s2">&quot; or columns&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">NDFrame</span><span class="o">.</span><span class="n">set_axis</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_axis</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span>
        <span class="n">NDFrame</span><span class="o">.</span><span class="n">reindex</span><span class="p">,</span>
        <span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">],</span>
        <span class="n">optional_reindex</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;optional_reindex&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">reindex</span><span class="p">(</span>  <span class="c1"># type: ignore[override]</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Scalar</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span>
            <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
            <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">errors</span><span class="p">:</span> <span class="n">IgnoreRaise</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">errors</span><span class="p">:</span> <span class="n">IgnoreRaise</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">errors</span><span class="p">:</span> <span class="n">IgnoreRaise</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">labels</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">errors</span><span class="p">:</span> <span class="n">IgnoreRaise</span> <span class="o">=</span> <span class="s2">&quot;raise&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drop specified labels from rows or columns.</span>

<span class="sd">        Remove rows or columns by specifying label names and corresponding</span>
<span class="sd">        axis, or by specifying directly index or column names. When using a</span>
<span class="sd">        multi-index, labels on different levels can be removed by specifying</span>
<span class="sd">        the level. See the :ref:`user guide &lt;advanced.shown_levels&gt;`</span>
<span class="sd">        for more information about the now unused levels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : single label or list-like</span>
<span class="sd">            Index or column labels to drop. A tuple will be used as a single</span>
<span class="sd">            label and not treated as a list-like.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            Whether to drop labels from the index (0 or &#39;index&#39;) or</span>
<span class="sd">            columns (1 or &#39;columns&#39;).</span>
<span class="sd">        index : single label or list-like</span>
<span class="sd">            Alternative to specifying axis (``labels, axis=0``</span>
<span class="sd">            is equivalent to ``index=labels``).</span>
<span class="sd">        columns : single label or list-like</span>
<span class="sd">            Alternative to specifying axis (``labels, axis=1``</span>
<span class="sd">            is equivalent to ``columns=labels``).</span>
<span class="sd">        level : int or level name, optional</span>
<span class="sd">            For MultiIndex, level from which the labels will be removed.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            If False, return a copy. Otherwise, do operation</span>
<span class="sd">            inplace and return None.</span>
<span class="sd">        errors : {&#39;ignore&#39;, &#39;raise&#39;}, default &#39;raise&#39;</span>
<span class="sd">            If &#39;ignore&#39;, suppress error and only existing labels are</span>
<span class="sd">            dropped.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame or None</span>
<span class="sd">            DataFrame without the removed index or column labels or</span>
<span class="sd">            None if ``inplace=True``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError</span>
<span class="sd">            If any of the labels is not found in the selected axis.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.loc : Label-location based indexer for selection by label.</span>
<span class="sd">        DataFrame.dropna : Return DataFrame with labels on given axis omitted</span>
<span class="sd">            where (all or any) data are missing.</span>
<span class="sd">        DataFrame.drop_duplicates : Return DataFrame with duplicate rows</span>
<span class="sd">            removed, optionally only considering certain columns.</span>
<span class="sd">        Series.drop : Return Series with specified index labels removed.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(np.arange(12).reshape(3, 4),</span>
<span class="sd">        ...                   columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A  B   C   D</span>
<span class="sd">        0  0  1   2   3</span>
<span class="sd">        1  4  5   6   7</span>
<span class="sd">        2  8  9  10  11</span>

<span class="sd">        Drop columns</span>

<span class="sd">        &gt;&gt;&gt; df.drop([&#39;B&#39;, &#39;C&#39;], axis=1)</span>
<span class="sd">           A   D</span>
<span class="sd">        0  0   3</span>
<span class="sd">        1  4   7</span>
<span class="sd">        2  8  11</span>

<span class="sd">        &gt;&gt;&gt; df.drop(columns=[&#39;B&#39;, &#39;C&#39;])</span>
<span class="sd">           A   D</span>
<span class="sd">        0  0   3</span>
<span class="sd">        1  4   7</span>
<span class="sd">        2  8  11</span>

<span class="sd">        Drop a row by index</span>

<span class="sd">        &gt;&gt;&gt; df.drop([0, 1])</span>
<span class="sd">           A  B   C   D</span>
<span class="sd">        2  8  9  10  11</span>

<span class="sd">        Drop columns and/or rows of MultiIndex DataFrame</span>

<span class="sd">        &gt;&gt;&gt; midx = pd.MultiIndex(levels=[[&#39;lama&#39;, &#39;cow&#39;, &#39;falcon&#39;],</span>
<span class="sd">        ...                              [&#39;speed&#39;, &#39;weight&#39;, &#39;length&#39;]],</span>
<span class="sd">        ...                      codes=[[0, 0, 0, 1, 1, 1, 2, 2, 2],</span>
<span class="sd">        ...                             [0, 1, 2, 0, 1, 2, 0, 1, 2]])</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(index=midx, columns=[&#39;big&#39;, &#39;small&#39;],</span>
<span class="sd">        ...                   data=[[45, 30], [200, 100], [1.5, 1], [30, 20],</span>
<span class="sd">        ...                         [250, 150], [1.5, 0.8], [320, 250],</span>
<span class="sd">        ...                         [1, 0.8], [0.3, 0.2]])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                        big     small</span>
<span class="sd">        lama    speed   45.0    30.0</span>
<span class="sd">                weight  200.0   100.0</span>
<span class="sd">                length  1.5     1.0</span>
<span class="sd">        cow     speed   30.0    20.0</span>
<span class="sd">                weight  250.0   150.0</span>
<span class="sd">                length  1.5     0.8</span>
<span class="sd">        falcon  speed   320.0   250.0</span>
<span class="sd">                weight  1.0     0.8</span>
<span class="sd">                length  0.3     0.2</span>

<span class="sd">        Drop a specific index combination from the MultiIndex</span>
<span class="sd">        DataFrame, i.e., drop the combination ``&#39;falcon&#39;`` and</span>
<span class="sd">        ``&#39;weight&#39;``, which deletes only the corresponding row</span>

<span class="sd">        &gt;&gt;&gt; df.drop(index=(&#39;falcon&#39;, &#39;weight&#39;))</span>
<span class="sd">                        big     small</span>
<span class="sd">        lama    speed   45.0    30.0</span>
<span class="sd">                weight  200.0   100.0</span>
<span class="sd">                length  1.5     1.0</span>
<span class="sd">        cow     speed   30.0    20.0</span>
<span class="sd">                weight  250.0   150.0</span>
<span class="sd">                length  1.5     0.8</span>
<span class="sd">        falcon  speed   320.0   250.0</span>
<span class="sd">                length  0.3     0.2</span>

<span class="sd">        &gt;&gt;&gt; df.drop(index=&#39;cow&#39;, columns=&#39;small&#39;)</span>
<span class="sd">                        big</span>
<span class="sd">        lama    speed   45.0</span>
<span class="sd">                weight  200.0</span>
<span class="sd">                length  1.5</span>
<span class="sd">        falcon  speed   320.0</span>
<span class="sd">                weight  1.0</span>
<span class="sd">                length  0.3</span>

<span class="sd">        &gt;&gt;&gt; df.drop(index=&#39;length&#39;, level=1)</span>
<span class="sd">                        big     small</span>
<span class="sd">        lama    speed   45.0    30.0</span>
<span class="sd">                weight  200.0   100.0</span>
<span class="sd">        cow     speed   30.0    20.0</span>
<span class="sd">                weight  250.0   150.0</span>
<span class="sd">        falcon  speed   320.0   250.0</span>
<span class="sd">                weight  1.0     0.8</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span>
            <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
            <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mapper</span><span class="p">:</span> <span class="n">Renamer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">Renamer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Renamer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">errors</span><span class="p">:</span> <span class="n">IgnoreRaise</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mapper</span><span class="p">:</span> <span class="n">Renamer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">Renamer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Renamer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">errors</span><span class="p">:</span> <span class="n">IgnoreRaise</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mapper</span><span class="p">:</span> <span class="n">Renamer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">Renamer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Renamer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">errors</span><span class="p">:</span> <span class="n">IgnoreRaise</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mapper</span><span class="p">:</span> <span class="n">Renamer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">Renamer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="p">:</span> <span class="n">Renamer</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">errors</span><span class="p">:</span> <span class="n">IgnoreRaise</span> <span class="o">=</span> <span class="s2">&quot;ignore&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rename columns or index labels.</span>

<span class="sd">        Function / dict values must be unique (1-to-1). Labels not contained in</span>
<span class="sd">        a dict / Series will be left as-is. Extra labels listed don&#39;t throw an</span>
<span class="sd">        error.</span>

<span class="sd">        See the :ref:`user guide &lt;basics.rename&gt;` for more.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mapper : dict-like or function</span>
<span class="sd">            Dict-like or function transformations to apply to</span>
<span class="sd">            that axis&#39; values. Use either ``mapper`` and ``axis`` to</span>
<span class="sd">            specify the axis to target with ``mapper``, or ``index`` and</span>
<span class="sd">            ``columns``.</span>
<span class="sd">        index : dict-like or function</span>
<span class="sd">            Alternative to specifying axis (``mapper, axis=0``</span>
<span class="sd">            is equivalent to ``index=mapper``).</span>
<span class="sd">        columns : dict-like or function</span>
<span class="sd">            Alternative to specifying axis (``mapper, axis=1``</span>
<span class="sd">            is equivalent to ``columns=mapper``).</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            Axis to target with ``mapper``. Can be either the axis name</span>
<span class="sd">            (&#39;index&#39;, &#39;columns&#39;) or number (0, 1). The default is &#39;index&#39;.</span>
<span class="sd">        copy : bool, default True</span>
<span class="sd">            Also copy underlying data.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Whether to modify the DataFrame rather than creating a new one.</span>
<span class="sd">            If True then value of copy is ignored.</span>
<span class="sd">        level : int or level name, default None</span>
<span class="sd">            In case of a MultiIndex, only rename labels in the specified</span>
<span class="sd">            level.</span>
<span class="sd">        errors : {&#39;ignore&#39;, &#39;raise&#39;}, default &#39;ignore&#39;</span>
<span class="sd">            If &#39;raise&#39;, raise a `KeyError` when a dict-like `mapper`, `index`,</span>
<span class="sd">            or `columns` contains labels that are not present in the Index</span>
<span class="sd">            being transformed.</span>
<span class="sd">            If &#39;ignore&#39;, existing keys will be renamed and extra keys will be</span>
<span class="sd">            ignored.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame or None</span>
<span class="sd">            DataFrame with the renamed axis labels or None if ``inplace=True``.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        KeyError</span>
<span class="sd">            If any of the labels is not found in the selected axis and</span>
<span class="sd">            &quot;errors=&#39;raise&#39;&quot;.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.rename_axis : Set the name of the axis.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        ``DataFrame.rename`` supports two calling conventions</span>

<span class="sd">        * ``(index=index_mapper, columns=columns_mapper, ...)``</span>
<span class="sd">        * ``(mapper, axis={&#39;index&#39;, &#39;columns&#39;}, ...)``</span>

<span class="sd">        We *highly* recommend using keyword arguments to clarify your</span>
<span class="sd">        intent.</span>

<span class="sd">        Rename columns using a mapping:</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [1, 2, 3], &quot;B&quot;: [4, 5, 6]})</span>
<span class="sd">        &gt;&gt;&gt; df.rename(columns={&quot;A&quot;: &quot;a&quot;, &quot;B&quot;: &quot;c&quot;})</span>
<span class="sd">           a  c</span>
<span class="sd">        0  1  4</span>
<span class="sd">        1  2  5</span>
<span class="sd">        2  3  6</span>

<span class="sd">        Rename index using a mapping:</span>

<span class="sd">        &gt;&gt;&gt; df.rename(index={0: &quot;x&quot;, 1: &quot;y&quot;, 2: &quot;z&quot;})</span>
<span class="sd">           A  B</span>
<span class="sd">        x  1  4</span>
<span class="sd">        y  2  5</span>
<span class="sd">        z  3  6</span>

<span class="sd">        Cast index labels to a different type:</span>

<span class="sd">        &gt;&gt;&gt; df.index</span>
<span class="sd">        RangeIndex(start=0, stop=3, step=1)</span>
<span class="sd">        &gt;&gt;&gt; df.rename(index=str).index</span>
<span class="sd">        Index([&#39;0&#39;, &#39;1&#39;, &#39;2&#39;], dtype=&#39;object&#39;)</span>

<span class="sd">        &gt;&gt;&gt; df.rename(columns={&quot;A&quot;: &quot;a&quot;, &quot;B&quot;: &quot;b&quot;, &quot;C&quot;: &quot;c&quot;}, errors=&quot;raise&quot;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">        KeyError: [&#39;C&#39;] not found in axis</span>

<span class="sd">        Using axis-style parameters:</span>

<span class="sd">        &gt;&gt;&gt; df.rename(str.lower, axis=&#39;columns&#39;)</span>
<span class="sd">           a  b</span>
<span class="sd">        0  1  4</span>
<span class="sd">        1  2  5</span>
<span class="sd">        2  3  6</span>

<span class="sd">        &gt;&gt;&gt; df.rename({1: 2, 2: 4}, axis=&#39;index&#39;)</span>
<span class="sd">           A  B</span>
<span class="sd">        0  1  4</span>
<span class="sd">        2  2  5</span>
<span class="sd">        4  3  6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_rename</span><span class="p">(</span>
            <span class="n">mapper</span><span class="o">=</span><span class="n">mapper</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
            <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
            <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Mapping</span> <span class="o">|</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">DataFrame</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">FillnaOptions</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Mapping</span> <span class="o">|</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">DataFrame</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">FillnaOptions</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Mapping</span> <span class="o">|</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">DataFrame</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">FillnaOptions</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">NDFrame</span><span class="o">.</span><span class="n">fillna</span><span class="p">,</span> <span class="o">**</span><span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Mapping</span> <span class="o">|</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">DataFrame</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">FillnaOptions</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span>
            <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
            <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return item and drop from frame. Raise KeyError if not found.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        item : label</span>
<span class="sd">            Label of column to be popped.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([(&#39;falcon&#39;, &#39;bird&#39;, 389.0),</span>
<span class="sd">        ...                    (&#39;parrot&#39;, &#39;bird&#39;, 24.0),</span>
<span class="sd">        ...                    (&#39;lion&#39;, &#39;mammal&#39;, 80.5),</span>
<span class="sd">        ...                    (&#39;monkey&#39;, &#39;mammal&#39;, np.nan)],</span>
<span class="sd">        ...                   columns=(&#39;name&#39;, &#39;class&#39;, &#39;max_speed&#39;))</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">             name   class  max_speed</span>
<span class="sd">        0  falcon    bird      389.0</span>
<span class="sd">        1  parrot    bird       24.0</span>
<span class="sd">        2    lion  mammal       80.5</span>
<span class="sd">        3  monkey  mammal        NaN</span>

<span class="sd">        &gt;&gt;&gt; df.pop(&#39;class&#39;)</span>
<span class="sd">        0      bird</span>
<span class="sd">        1      bird</span>
<span class="sd">        2    mammal</span>
<span class="sd">        3    mammal</span>
<span class="sd">        Name: class, dtype: object</span>

<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">             name  max_speed</span>
<span class="sd">        0  falcon      389.0</span>
<span class="sd">        1  parrot       24.0</span>
<span class="sd">        2    lion       80.5</span>
<span class="sd">        3  monkey        NaN</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">item</span><span class="o">=</span><span class="n">item</span><span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">to_replace</span><span class="o">=...</span><span class="p">,</span>
        <span class="n">value</span><span class="o">=...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">regex</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="s2">&quot;ffill&quot;</span><span class="p">,</span> <span class="s2">&quot;bfill&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="n">lib</span><span class="o">.</span><span class="n">NoDefault</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">to_replace</span><span class="o">=...</span><span class="p">,</span>
        <span class="n">value</span><span class="o">=...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">regex</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="s2">&quot;ffill&quot;</span><span class="p">,</span> <span class="s2">&quot;bfill&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="n">lib</span><span class="o">.</span><span class="n">NoDefault</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">NDFrame</span><span class="o">.</span><span class="n">replace</span><span class="p">,</span> <span class="o">**</span><span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">to_replace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">value</span><span class="o">=</span><span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">regex</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="s2">&quot;ffill&quot;</span><span class="p">,</span> <span class="s2">&quot;bfill&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="n">lib</span><span class="o">.</span><span class="n">NoDefault</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
            <span class="n">to_replace</span><span class="o">=</span><span class="n">to_replace</span><span class="p">,</span>
            <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
            <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_replace_columnwise</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">mapping</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span> <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">regex</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dispatch to Series.replace column-wise.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mapping : dict</span>
<span class="sd">            of the form {col: (target, value)}</span>
<span class="sd">        inplace : bool</span>
<span class="sd">        regex : bool or same types as `to_replace` in DataFrame.replace</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Operate column-wise</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">inplace</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax_value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ax</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ax_value</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">:</span>
                <span class="n">ser</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>

                <span class="n">target</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">ax_value</span><span class="p">]</span>
                <span class="n">newobj</span> <span class="o">=</span> <span class="n">ser</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="n">regex</span><span class="p">)</span>

                <span class="n">res</span><span class="o">.</span><span class="n">_iset_item</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">newobj</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">NDFrame</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span> <span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">shift</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">periods</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="n">Frequency</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">ncols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="ow">and</span> <span class="n">periods</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="ow">and</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span>
            <span class="ow">and</span> <span class="n">ncols</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="c1"># We will infer fill_value to match the closest column</span>

            <span class="c1"># Use a column that we know is valid for our column&#39;s dtype GH#38434</span>
            <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">periods</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="n">periods</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">ncols</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">periods</span><span class="p">))):</span>
                    <span class="c1"># TODO(EA2D): doing this in a loop unnecessary with 2D EAs</span>
                    <span class="c1"># Define filler inside loop so we get a copy</span>
                    <span class="n">filler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">filler</span><span class="p">,</span> <span class="n">allow_duplicates</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="o">-</span><span class="n">periods</span><span class="p">:]</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">ncols</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">periods</span><span class="p">))):</span>
                    <span class="c1"># Define filler inside loop so we get a copy</span>
                    <span class="n">filler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="n">label</span><span class="p">,</span> <span class="n">filler</span><span class="p">,</span> <span class="n">allow_duplicates</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>

            <span class="n">result</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="ow">and</span> <span class="n">periods</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="ow">and</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span>
            <span class="ow">and</span> <span class="n">ncols</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="n">arrays</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">arrays</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="c1"># If we only have one block and we know that we can&#39;t</span>
                <span class="c1">#  keep the same dtype (i.e. the _can_hold_element check)</span>
                <span class="c1">#  then we can go through the reindex_indexer path</span>
                <span class="c1">#  (and avoid casting logic in the Block method).</span>
                <span class="ow">not</span> <span class="n">can_hold_element</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fill_value</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="c1"># GH#35488 we need to watch out for multi-block cases</span>
                <span class="c1"># We only get here with fill_value not-lib.no_default</span>
                <span class="n">nper</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">periods</span><span class="p">)</span>
                <span class="n">nper</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">nper</span><span class="p">,</span> <span class="n">ncols</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">periods</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">indexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                        <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">nper</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ncols</span> <span class="o">-</span> <span class="n">periods</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">indexer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                        <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nper</span><span class="p">,</span> <span class="n">ncols</span><span class="p">))</span> <span class="o">+</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">nper</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span>
                    <span class="p">)</span>
                <span class="n">mgr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">reindex_indexer</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
                    <span class="n">indexer</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
                    <span class="n">allow_dups</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">res_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">mgr</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">res_df</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;shift&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span>
            <span class="n">periods</span><span class="o">=</span><span class="n">periods</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span>
        <span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">set_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">append</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">verify_integrity</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">set_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">append</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">verify_integrity</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">set_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">append</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verify_integrity</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the DataFrame index using existing columns.</span>

<span class="sd">        Set the DataFrame index (row labels) using one or more existing</span>
<span class="sd">        columns or arrays (of the correct length). The index can replace the</span>
<span class="sd">        existing index or expand on it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keys : label or array-like or list of labels/arrays</span>
<span class="sd">            This parameter can be either a single column key, a single array of</span>
<span class="sd">            the same length as the calling DataFrame, or a list containing an</span>
<span class="sd">            arbitrary combination of column keys and arrays. Here, &quot;array&quot;</span>
<span class="sd">            encompasses :class:`Series`, :class:`Index`, ``np.ndarray``, and</span>
<span class="sd">            instances of :class:`~collections.abc.Iterator`.</span>
<span class="sd">        drop : bool, default True</span>
<span class="sd">            Delete columns to be used as the new index.</span>
<span class="sd">        append : bool, default False</span>
<span class="sd">            Whether to append columns to existing index.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Whether to modify the DataFrame rather than creating a new one.</span>
<span class="sd">        verify_integrity : bool, default False</span>
<span class="sd">            Check the new index for duplicates. Otherwise defer the check until</span>
<span class="sd">            necessary. Setting to False will improve the performance of this</span>
<span class="sd">            method.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame or None</span>
<span class="sd">            Changed row labels or None if ``inplace=True``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.reset_index : Opposite of set_index.</span>
<span class="sd">        DataFrame.reindex : Change to new indices or expand indices.</span>
<span class="sd">        DataFrame.reindex_like : Change to same indices as other DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;month&#39;: [1, 4, 7, 10],</span>
<span class="sd">        ...                    &#39;year&#39;: [2012, 2014, 2013, 2014],</span>
<span class="sd">        ...                    &#39;sale&#39;: [55, 40, 84, 31]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           month  year  sale</span>
<span class="sd">        0      1  2012    55</span>
<span class="sd">        1      4  2014    40</span>
<span class="sd">        2      7  2013    84</span>
<span class="sd">        3     10  2014    31</span>

<span class="sd">        Set the index to become the &#39;month&#39; column:</span>

<span class="sd">        &gt;&gt;&gt; df.set_index(&#39;month&#39;)</span>
<span class="sd">               year  sale</span>
<span class="sd">        month</span>
<span class="sd">        1      2012    55</span>
<span class="sd">        4      2014    40</span>
<span class="sd">        7      2013    84</span>
<span class="sd">        10     2014    31</span>

<span class="sd">        Create a MultiIndex using columns &#39;year&#39; and &#39;month&#39;:</span>

<span class="sd">        &gt;&gt;&gt; df.set_index([&#39;year&#39;, &#39;month&#39;])</span>
<span class="sd">                    sale</span>
<span class="sd">        year  month</span>
<span class="sd">        2012  1     55</span>
<span class="sd">        2014  4     40</span>
<span class="sd">        2013  7     84</span>
<span class="sd">        2014  10    31</span>

<span class="sd">        Create a MultiIndex using an Index and a column:</span>

<span class="sd">        &gt;&gt;&gt; df.set_index([pd.Index([1, 2, 3, 4]), &#39;year&#39;])</span>
<span class="sd">                 month  sale</span>
<span class="sd">           year</span>
<span class="sd">        1  2012  1      55</span>
<span class="sd">        2  2014  4      40</span>
<span class="sd">        3  2013  7      84</span>
<span class="sd">        4  2014  10     31</span>

<span class="sd">        Create a MultiIndex using two Series:</span>

<span class="sd">        &gt;&gt;&gt; s = pd.Series([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; df.set_index([s, s**2])</span>
<span class="sd">              month  year  sale</span>
<span class="sd">        1 1       1  2012    55</span>
<span class="sd">        2 4       4  2014    40</span>
<span class="sd">        3 9       7  2013    84</span>
<span class="sd">        4 16     10  2014    31</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_inplace_and_allows_duplicate_labels</span><span class="p">(</span><span class="n">inplace</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">keys</span><span class="p">]</span>

        <span class="n">err_msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;The parameter &quot;keys&quot; may be a column key, one-dimensional &#39;</span>
            <span class="s2">&quot;array, or a list containing only valid column keys and &quot;</span>
            <span class="s2">&quot;one-dimensional arrays.&quot;</span>
        <span class="p">)</span>

        <span class="n">missing</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="n">Index</span><span class="p">,</span> <span class="n">Series</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">Iterator</span><span class="p">)):</span>
                <span class="c1"># arrays are fine as long as they are one-dimensional</span>
                <span class="c1"># iterators get converted to list below</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s2">&quot;ndim&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># everything else gets tried as a key; see GH 24969</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
                <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">err_msg</span><span class="si">}</span><span class="s2">. Received column of type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">col</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
                        <span class="n">missing</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;None of </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s2"> are in the columns&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># GH 49473 Use &quot;lazy copy&quot; with Copy-on-Write</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">names</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">append</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">nlevels</span><span class="p">):</span>
                    <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_get_level_values</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="n">to_remove</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">nlevels</span><span class="p">):</span>
                    <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">_get_level_values</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
                <span class="n">names</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="n">Index</span><span class="p">,</span> <span class="n">Series</span><span class="p">)):</span>
                <span class="c1"># if Index then not MultiIndex (treated above)</span>

                <span class="c1"># error: Argument 1 to &quot;append&quot; of &quot;list&quot; has incompatible type</span>
                <span class="c1">#  &quot;Union[Index, Series]&quot;; expected &quot;Index&quot;</span>
                <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>  <span class="c1"># type:ignore[arg-type]</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="c1"># error: Argument 1 to &quot;append&quot; of &quot;list&quot; has incompatible type</span>
                <span class="c1"># &quot;Union[List[Any], ndarray]&quot;; expected &quot;Index&quot;</span>
                <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">abc</span><span class="o">.</span><span class="n">Iterator</span><span class="p">):</span>
                <span class="c1"># error: Argument 1 to &quot;append&quot; of &quot;list&quot; has incompatible type</span>
                <span class="c1"># &quot;List[Any]&quot;; expected &quot;Index&quot;</span>
                <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">col</span><span class="p">))</span>  <span class="c1"># type: ignore[arg-type]</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="c1"># from here, col can only be a column label</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
                <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">drop</span><span class="p">:</span>
                    <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="c1"># check newest element against length of calling frame, since</span>
                <span class="c1"># ensure_index_from_sequences would not raise for append=False.</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Length mismatch: Expected </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2"> rows, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;received array of length </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="n">index</span> <span class="o">=</span> <span class="n">ensure_index_from_sequences</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verify_integrity</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">index</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="n">duplicates</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Index has duplicate keys: </span><span class="si">{</span><span class="n">duplicates</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># use set to handle duplicate column names gracefully in case of drop</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">to_remove</span><span class="p">):</span>
            <span class="k">del</span> <span class="n">frame</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>

        <span class="c1"># clear up memory usage</span>
        <span class="n">index</span><span class="o">.</span><span class="n">_cleanup</span><span class="p">()</span>

        <span class="n">frame</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">frame</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">reset_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">col_level</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">col_fill</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">allow_duplicates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="n">lib</span><span class="o">.</span><span class="n">NoDefault</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">names</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">reset_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">col_level</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">col_fill</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">allow_duplicates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="n">lib</span><span class="o">.</span><span class="n">NoDefault</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">names</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">reset_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">col_level</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">col_fill</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">allow_duplicates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="n">lib</span><span class="o">.</span><span class="n">NoDefault</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">names</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">reset_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">col_level</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">col_fill</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">allow_duplicates</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="n">lib</span><span class="o">.</span><span class="n">NoDefault</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span>
        <span class="n">names</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset the index, or a level of it.</span>

<span class="sd">        Reset the index of the DataFrame, and use the default one instead.</span>
<span class="sd">        If the DataFrame has a MultiIndex, this method can remove one or more</span>
<span class="sd">        levels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int, str, tuple, or list, default None</span>
<span class="sd">            Only remove the given levels from the index. Removes all levels by</span>
<span class="sd">            default.</span>
<span class="sd">        drop : bool, default False</span>
<span class="sd">            Do not try to insert index into dataframe columns. This resets</span>
<span class="sd">            the index to the default integer index.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Whether to modify the DataFrame rather than creating a new one.</span>
<span class="sd">        col_level : int or str, default 0</span>
<span class="sd">            If the columns have multiple levels, determines which level the</span>
<span class="sd">            labels are inserted into. By default it is inserted into the first</span>
<span class="sd">            level.</span>
<span class="sd">        col_fill : object, default &#39;&#39;</span>
<span class="sd">            If the columns have multiple levels, determines how the other</span>
<span class="sd">            levels are named. If None then the index name is repeated.</span>
<span class="sd">        allow_duplicates : bool, optional, default lib.no_default</span>
<span class="sd">            Allow duplicate column labels to be created.</span>

<span class="sd">            .. versionadded:: 1.5.0</span>

<span class="sd">        names : int, str or 1-dimensional list, default None</span>
<span class="sd">            Using the given string, rename the DataFrame column which contains the</span>
<span class="sd">            index data. If the DataFrame has a MultiIndex, this has to be a list or</span>
<span class="sd">            tuple with length equal to the number of levels.</span>

<span class="sd">            .. versionadded:: 1.5.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame or None</span>
<span class="sd">            DataFrame with the new index or None if ``inplace=True``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.set_index : Opposite of reset_index.</span>
<span class="sd">        DataFrame.reindex : Change to new indices or expand indices.</span>
<span class="sd">        DataFrame.reindex_like : Change to same indices as other DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([(&#39;bird&#39;, 389.0),</span>
<span class="sd">        ...                    (&#39;bird&#39;, 24.0),</span>
<span class="sd">        ...                    (&#39;mammal&#39;, 80.5),</span>
<span class="sd">        ...                    (&#39;mammal&#39;, np.nan)],</span>
<span class="sd">        ...                   index=[&#39;falcon&#39;, &#39;parrot&#39;, &#39;lion&#39;, &#39;monkey&#39;],</span>
<span class="sd">        ...                   columns=(&#39;class&#39;, &#39;max_speed&#39;))</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                 class  max_speed</span>
<span class="sd">        falcon    bird      389.0</span>
<span class="sd">        parrot    bird       24.0</span>
<span class="sd">        lion    mammal       80.5</span>
<span class="sd">        monkey  mammal        NaN</span>

<span class="sd">        When we reset the index, the old index is added as a column, and a</span>
<span class="sd">        new sequential index is used:</span>

<span class="sd">        &gt;&gt;&gt; df.reset_index()</span>
<span class="sd">            index   class  max_speed</span>
<span class="sd">        0  falcon    bird      389.0</span>
<span class="sd">        1  parrot    bird       24.0</span>
<span class="sd">        2    lion  mammal       80.5</span>
<span class="sd">        3  monkey  mammal        NaN</span>

<span class="sd">        We can use the `drop` parameter to avoid the old index being added as</span>
<span class="sd">        a column:</span>

<span class="sd">        &gt;&gt;&gt; df.reset_index(drop=True)</span>
<span class="sd">            class  max_speed</span>
<span class="sd">        0    bird      389.0</span>
<span class="sd">        1    bird       24.0</span>
<span class="sd">        2  mammal       80.5</span>
<span class="sd">        3  mammal        NaN</span>

<span class="sd">        You can also use `reset_index` with `MultiIndex`.</span>

<span class="sd">        &gt;&gt;&gt; index = pd.MultiIndex.from_tuples([(&#39;bird&#39;, &#39;falcon&#39;),</span>
<span class="sd">        ...                                    (&#39;bird&#39;, &#39;parrot&#39;),</span>
<span class="sd">        ...                                    (&#39;mammal&#39;, &#39;lion&#39;),</span>
<span class="sd">        ...                                    (&#39;mammal&#39;, &#39;monkey&#39;)],</span>
<span class="sd">        ...                                   names=[&#39;class&#39;, &#39;name&#39;])</span>
<span class="sd">        &gt;&gt;&gt; columns = pd.MultiIndex.from_tuples([(&#39;speed&#39;, &#39;max&#39;),</span>
<span class="sd">        ...                                      (&#39;species&#39;, &#39;type&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([(389.0, &#39;fly&#39;),</span>
<span class="sd">        ...                    (24.0, &#39;fly&#39;),</span>
<span class="sd">        ...                    (80.5, &#39;run&#39;),</span>
<span class="sd">        ...                    (np.nan, &#39;jump&#39;)],</span>
<span class="sd">        ...                   index=index,</span>
<span class="sd">        ...                   columns=columns)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                       speed species</span>
<span class="sd">                         max    type</span>
<span class="sd">        class  name</span>
<span class="sd">        bird   falcon  389.0     fly</span>
<span class="sd">               parrot   24.0     fly</span>
<span class="sd">        mammal lion     80.5     run</span>
<span class="sd">               monkey    NaN    jump</span>

<span class="sd">        Using the `names` parameter, choose a name for the index column:</span>

<span class="sd">        &gt;&gt;&gt; df.reset_index(names=[&#39;classes&#39;, &#39;names&#39;])</span>
<span class="sd">          classes   names  speed species</span>
<span class="sd">                             max    type</span>
<span class="sd">        0    bird  falcon  389.0     fly</span>
<span class="sd">        1    bird  parrot   24.0     fly</span>
<span class="sd">        2  mammal    lion   80.5     run</span>
<span class="sd">        3  mammal  monkey    NaN    jump</span>

<span class="sd">        If the index has multiple levels, we can reset a subset of them:</span>

<span class="sd">        &gt;&gt;&gt; df.reset_index(level=&#39;class&#39;)</span>
<span class="sd">                 class  speed species</span>
<span class="sd">                          max    type</span>
<span class="sd">        name</span>
<span class="sd">        falcon    bird  389.0     fly</span>
<span class="sd">        parrot    bird   24.0     fly</span>
<span class="sd">        lion    mammal   80.5     run</span>
<span class="sd">        monkey  mammal    NaN    jump</span>

<span class="sd">        If we are not dropping the index, by default, it is placed in the top</span>
<span class="sd">        level. We can place it in another level:</span>

<span class="sd">        &gt;&gt;&gt; df.reset_index(level=&#39;class&#39;, col_level=1)</span>
<span class="sd">                        speed species</span>
<span class="sd">                 class    max    type</span>
<span class="sd">        name</span>
<span class="sd">        falcon    bird  389.0     fly</span>
<span class="sd">        parrot    bird   24.0     fly</span>
<span class="sd">        lion    mammal   80.5     run</span>
<span class="sd">        monkey  mammal    NaN    jump</span>

<span class="sd">        When the index is inserted under another level, we can specify under</span>
<span class="sd">        which one with the parameter `col_fill`:</span>

<span class="sd">        &gt;&gt;&gt; df.reset_index(level=&#39;class&#39;, col_level=1, col_fill=&#39;species&#39;)</span>
<span class="sd">                      species  speed species</span>
<span class="sd">                        class    max    type</span>
<span class="sd">        name</span>
<span class="sd">        falcon           bird  389.0     fly</span>
<span class="sd">        parrot           bird   24.0     fly</span>
<span class="sd">        lion           mammal   80.5     run</span>
<span class="sd">        monkey         mammal    NaN    jump</span>

<span class="sd">        If we specify a nonexistent level for `col_fill`, it is created:</span>

<span class="sd">        &gt;&gt;&gt; df.reset_index(level=&#39;class&#39;, col_level=1, col_fill=&#39;genus&#39;)</span>
<span class="sd">                        genus  speed species</span>
<span class="sd">                        class    max    type</span>
<span class="sd">        name</span>
<span class="sd">        falcon           bird  389.0     fly</span>
<span class="sd">        parrot           bird   24.0     fly</span>
<span class="sd">        lion           mammal   80.5     run</span>
<span class="sd">        monkey         mammal    NaN    jump</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_inplace_and_allows_duplicate_labels</span><span class="p">(</span><span class="n">inplace</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">allow_duplicates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">:</span>
            <span class="n">allow_duplicates</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">allow_duplicates</span><span class="p">,</span> <span class="s2">&quot;allow_duplicates&quot;</span><span class="p">)</span>

        <span class="n">new_index</span> <span class="o">=</span> <span class="n">default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_obj</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="n">level</span> <span class="o">=</span> <span class="p">[</span><span class="n">level</span><span class="p">]</span>
            <span class="n">level</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">lev</span><span class="p">)</span> <span class="k">for</span> <span class="n">lev</span> <span class="ow">in</span> <span class="n">level</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">level</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">nlevels</span><span class="p">:</span>
                <span class="n">new_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">drop</span><span class="p">:</span>
            <span class="n">to_insert</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]]</span>

            <span class="n">default</span> <span class="o">=</span> <span class="s2">&quot;index&quot;</span> <span class="k">if</span> <span class="s2">&quot;index&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">else</span> <span class="s2">&quot;level_0&quot;</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">_get_default_index_names</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                <span class="n">to_insert</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">levels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">codes</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">to_insert</span> <span class="o">=</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="kc">None</span><span class="p">),)</span>

            <span class="n">multi_col</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">lab</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">to_insert</span><span class="p">))):</span>
                <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">level</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">multi_col</span><span class="p">:</span>
                    <span class="n">col_name</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">col_fill</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">col_name</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">nlevels</span><span class="p">):</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                                <span class="s2">&quot;col_fill=None is incompatible &quot;</span>
                                <span class="sa">f</span><span class="s2">&quot;with incomplete column name </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="p">)</span>
                        <span class="n">col_fill</span> <span class="o">=</span> <span class="n">col_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="n">lev_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_get_level_number</span><span class="p">(</span><span class="n">col_level</span><span class="p">)</span>
                    <span class="n">name_lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">col_fill</span><span class="p">]</span> <span class="o">*</span> <span class="n">lev_num</span> <span class="o">+</span> <span class="n">col_name</span>
                    <span class="n">missing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">name_lst</span><span class="p">)</span>
                    <span class="n">name_lst</span> <span class="o">+=</span> <span class="p">[</span><span class="n">col_fill</span><span class="p">]</span> <span class="o">*</span> <span class="n">missing</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">name_lst</span><span class="p">)</span>

                <span class="c1"># to ndarray and maybe infer different dtype</span>
                <span class="n">level_values</span> <span class="o">=</span> <span class="n">lev</span><span class="o">.</span><span class="n">_values</span>
                <span class="k">if</span> <span class="n">level_values</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">object_</span><span class="p">:</span>
                    <span class="n">level_values</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">maybe_convert_objects</span><span class="p">(</span><span class="n">level_values</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">lab</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># if we have the codes, extract the values with a mask</span>
                    <span class="n">level_values</span> <span class="o">=</span> <span class="n">algorithms</span><span class="o">.</span><span class="n">take</span><span class="p">(</span>
                        <span class="n">level_values</span><span class="p">,</span> <span class="n">lab</span><span class="p">,</span> <span class="n">allow_fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">lev</span><span class="o">.</span><span class="n">_na_value</span>
                    <span class="p">)</span>

                <span class="n">new_obj</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="n">name</span><span class="p">,</span>
                    <span class="n">level_values</span><span class="p">,</span>
                    <span class="n">allow_duplicates</span><span class="o">=</span><span class="n">allow_duplicates</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="n">new_obj</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">new_index</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new_obj</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Reindex-based selection methods</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">NDFrame</span><span class="o">.</span><span class="n">isna</span><span class="p">,</span> <span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">isna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">isna</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;isna&quot;</span><span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">NDFrame</span><span class="o">.</span><span class="n">isna</span><span class="p">,</span> <span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">isnull</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DataFrame.isnull is an alias for DataFrame.isna.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">NDFrame</span><span class="o">.</span><span class="n">notna</span><span class="p">,</span> <span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">notna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">NDFrame</span><span class="o">.</span><span class="n">notna</span><span class="p">,</span> <span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">notnull</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DataFrame.notnull is an alias for DataFrame.notna.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">dropna</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">how</span><span class="p">:</span> <span class="n">AnyAll</span> <span class="o">|</span> <span class="n">NoDefault</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">thresh</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">NoDefault</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">subset</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">dropna</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">how</span><span class="p">:</span> <span class="n">AnyAll</span> <span class="o">|</span> <span class="n">NoDefault</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">thresh</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">NoDefault</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">subset</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">dropna</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">how</span><span class="p">:</span> <span class="n">AnyAll</span> <span class="o">|</span> <span class="n">NoDefault</span> <span class="o">=</span> <span class="n">no_default</span><span class="p">,</span>
        <span class="n">thresh</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">NoDefault</span> <span class="o">=</span> <span class="n">no_default</span><span class="p">,</span>
        <span class="n">subset</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove missing values.</span>

<span class="sd">        See the :ref:`User Guide &lt;missing_data&gt;` for more on which values are</span>
<span class="sd">        considered missing, and how to work with missing data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            Determine if rows or columns which contain missing values are</span>
<span class="sd">            removed.</span>

<span class="sd">            * 0, or &#39;index&#39; : Drop rows which contain missing values.</span>
<span class="sd">            * 1, or &#39;columns&#39; : Drop columns which contain missing value.</span>

<span class="sd">            Pass tuple or list to drop on multiple axes.</span>
<span class="sd">            Only a single axis is allowed.</span>

<span class="sd">        how : {&#39;any&#39;, &#39;all&#39;}, default &#39;any&#39;</span>
<span class="sd">            Determine if row or column is removed from DataFrame, when we have</span>
<span class="sd">            at least one NA or all NA.</span>

<span class="sd">            * &#39;any&#39; : If any NA values are present, drop that row or column.</span>
<span class="sd">            * &#39;all&#39; : If all values are NA, drop that row or column.</span>

<span class="sd">        thresh : int, optional</span>
<span class="sd">            Require that many non-NA values. Cannot be combined with how.</span>
<span class="sd">        subset : column label or sequence of labels, optional</span>
<span class="sd">            Labels along other axis to consider, e.g. if you are dropping rows</span>
<span class="sd">            these would be a list of columns to include.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Whether to modify the DataFrame rather than creating a new one.</span>
<span class="sd">        ignore_index : bool, default ``False``</span>
<span class="sd">            If ``True``, the resulting axis will be labeled 0, 1, …, n - 1.</span>

<span class="sd">            .. versionadded:: 2.0.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame or None</span>
<span class="sd">            DataFrame with NA entries dropped from it or None if ``inplace=True``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.isna: Indicate missing values.</span>
<span class="sd">        DataFrame.notna : Indicate existing (non-missing) values.</span>
<span class="sd">        DataFrame.fillna : Replace missing values.</span>
<span class="sd">        Series.dropna : Drop missing values.</span>
<span class="sd">        Index.dropna : Drop missing indices.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;name&quot;: [&#39;Alfred&#39;, &#39;Batman&#39;, &#39;Catwoman&#39;],</span>
<span class="sd">        ...                    &quot;toy&quot;: [np.nan, &#39;Batmobile&#39;, &#39;Bullwhip&#39;],</span>
<span class="sd">        ...                    &quot;born&quot;: [pd.NaT, pd.Timestamp(&quot;1940-04-25&quot;),</span>
<span class="sd">        ...                             pd.NaT]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">               name        toy       born</span>
<span class="sd">        0    Alfred        NaN        NaT</span>
<span class="sd">        1    Batman  Batmobile 1940-04-25</span>
<span class="sd">        2  Catwoman   Bullwhip        NaT</span>

<span class="sd">        Drop the rows where at least one element is missing.</span>

<span class="sd">        &gt;&gt;&gt; df.dropna()</span>
<span class="sd">             name        toy       born</span>
<span class="sd">        1  Batman  Batmobile 1940-04-25</span>

<span class="sd">        Drop the columns where at least one element is missing.</span>

<span class="sd">        &gt;&gt;&gt; df.dropna(axis=&#39;columns&#39;)</span>
<span class="sd">               name</span>
<span class="sd">        0    Alfred</span>
<span class="sd">        1    Batman</span>
<span class="sd">        2  Catwoman</span>

<span class="sd">        Drop the rows where all elements are missing.</span>

<span class="sd">        &gt;&gt;&gt; df.dropna(how=&#39;all&#39;)</span>
<span class="sd">               name        toy       born</span>
<span class="sd">        0    Alfred        NaN        NaT</span>
<span class="sd">        1    Batman  Batmobile 1940-04-25</span>
<span class="sd">        2  Catwoman   Bullwhip        NaT</span>

<span class="sd">        Keep only the rows with at least 2 non-NA values.</span>

<span class="sd">        &gt;&gt;&gt; df.dropna(thresh=2)</span>
<span class="sd">               name        toy       born</span>
<span class="sd">        1    Batman  Batmobile 1940-04-25</span>
<span class="sd">        2  Catwoman   Bullwhip        NaT</span>

<span class="sd">        Define in which columns to look for missing values.</span>

<span class="sd">        &gt;&gt;&gt; df.dropna(subset=[&#39;name&#39;, &#39;toy&#39;])</span>
<span class="sd">               name        toy       born</span>
<span class="sd">        1    Batman  Batmobile 1940-04-25</span>
<span class="sd">        2  Catwoman   Bullwhip        NaT</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">how</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">no_default</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">thresh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">no_default</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;You cannot set both the how and thresh arguments at the same time.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">how</span> <span class="ow">is</span> <span class="n">no_default</span><span class="p">:</span>
            <span class="n">how</span> <span class="o">=</span> <span class="s2">&quot;any&quot;</span>

        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="c1"># GH20987</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;supplying multiple axes to axis is no longer supported.&quot;</span><span class="p">)</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">agg_axis</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">axis</span>

        <span class="n">agg_obj</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># subset needs to be list</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">subset</span><span class="p">):</span>
                <span class="n">subset</span> <span class="o">=</span> <span class="p">[</span><span class="n">subset</span><span class="p">]</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">agg_axis</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_indexer_for</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span>
            <span class="n">check</span> <span class="o">=</span> <span class="n">indices</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">check</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">subset</span><span class="p">)[</span><span class="n">check</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="n">agg_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">agg_axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">thresh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">no_default</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">agg_obj</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">agg_axis</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="n">thresh</span>
        <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;any&quot;</span><span class="p">:</span>
            <span class="c1"># faster equivalent to &#39;agg_obj.count(agg_axis) == self.shape[agg_axis]&#39;</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">agg_obj</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">agg_axis</span><span class="p">,</span> <span class="n">bool_only</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="c1"># faster equivalent to &#39;agg_obj.count(agg_axis) &gt; 0&#39;</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">agg_obj</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">agg_axis</span><span class="p">,</span> <span class="n">bool_only</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid how option: </span><span class="si">{</span><span class="n">how</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)[</span><span class="n">mask</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ignore_index</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">drop_duplicates</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">subset</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">keep</span><span class="p">:</span> <span class="n">DropKeep</span> <span class="o">=</span> <span class="s2">&quot;first&quot;</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return DataFrame with duplicate rows removed.</span>

<span class="sd">        Considering certain columns is optional. Indexes, including time indexes</span>
<span class="sd">        are ignored.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        subset : column label or sequence of labels, optional</span>
<span class="sd">            Only consider certain columns for identifying duplicates, by</span>
<span class="sd">            default use all of the columns.</span>
<span class="sd">        keep : {&#39;first&#39;, &#39;last&#39;, ``False``}, default &#39;first&#39;</span>
<span class="sd">            Determines which duplicates (if any) to keep.</span>

<span class="sd">            - &#39;first&#39; : Drop duplicates except for the first occurrence.</span>
<span class="sd">            - &#39;last&#39; : Drop duplicates except for the last occurrence.</span>
<span class="sd">            - ``False`` : Drop all duplicates.</span>

<span class="sd">        inplace : bool, default ``False``</span>
<span class="sd">            Whether to modify the DataFrame rather than creating a new one.</span>
<span class="sd">        ignore_index : bool, default ``False``</span>
<span class="sd">            If ``True``, the resulting axis will be labeled 0, 1, …, n - 1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame or None</span>
<span class="sd">            DataFrame with duplicates removed or None if ``inplace=True``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.value_counts: Count unique combinations of columns.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Consider dataset containing ramen rating.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({</span>
<span class="sd">        ...     &#39;brand&#39;: [&#39;Yum Yum&#39;, &#39;Yum Yum&#39;, &#39;Indomie&#39;, &#39;Indomie&#39;, &#39;Indomie&#39;],</span>
<span class="sd">        ...     &#39;style&#39;: [&#39;cup&#39;, &#39;cup&#39;, &#39;cup&#39;, &#39;pack&#39;, &#39;pack&#39;],</span>
<span class="sd">        ...     &#39;rating&#39;: [4, 4, 3.5, 15, 5]</span>
<span class="sd">        ... })</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">            brand style  rating</span>
<span class="sd">        0  Yum Yum   cup     4.0</span>
<span class="sd">        1  Yum Yum   cup     4.0</span>
<span class="sd">        2  Indomie   cup     3.5</span>
<span class="sd">        3  Indomie  pack    15.0</span>
<span class="sd">        4  Indomie  pack     5.0</span>

<span class="sd">        By default, it removes duplicate rows based on all columns.</span>

<span class="sd">        &gt;&gt;&gt; df.drop_duplicates()</span>
<span class="sd">            brand style  rating</span>
<span class="sd">        0  Yum Yum   cup     4.0</span>
<span class="sd">        2  Indomie   cup     3.5</span>
<span class="sd">        3  Indomie  pack    15.0</span>
<span class="sd">        4  Indomie  pack     5.0</span>

<span class="sd">        To remove duplicates on specific column(s), use ``subset``.</span>

<span class="sd">        &gt;&gt;&gt; df.drop_duplicates(subset=[&#39;brand&#39;])</span>
<span class="sd">            brand style  rating</span>
<span class="sd">        0  Yum Yum   cup     4.0</span>
<span class="sd">        2  Indomie   cup     3.5</span>

<span class="sd">        To remove duplicates and keep last occurrences, use ``keep``.</span>

<span class="sd">        &gt;&gt;&gt; df.drop_duplicates(subset=[&#39;brand&#39;, &#39;style&#39;], keep=&#39;last&#39;)</span>
<span class="sd">            brand style  rating</span>
<span class="sd">        1  Yum Yum   cup     4.0</span>
<span class="sd">        2  Indomie   cup     3.5</span>
<span class="sd">        4  Indomie  pack     5.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="n">ignore_index</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">ignore_index</span><span class="p">,</span> <span class="s2">&quot;ignore_index&quot;</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="n">keep</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">ignore_index</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">duplicated</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">subset</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">keep</span><span class="p">:</span> <span class="n">DropKeep</span> <span class="o">=</span> <span class="s2">&quot;first&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return boolean Series denoting duplicate rows.</span>

<span class="sd">        Considering certain columns is optional.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        subset : column label or sequence of labels, optional</span>
<span class="sd">            Only consider certain columns for identifying duplicates, by</span>
<span class="sd">            default use all of the columns.</span>
<span class="sd">        keep : {&#39;first&#39;, &#39;last&#39;, False}, default &#39;first&#39;</span>
<span class="sd">            Determines which duplicates (if any) to mark.</span>

<span class="sd">            - ``first`` : Mark duplicates as ``True`` except for the first occurrence.</span>
<span class="sd">            - ``last`` : Mark duplicates as ``True`` except for the last occurrence.</span>
<span class="sd">            - False : Mark all duplicates as ``True``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Boolean series for each duplicated rows.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index.duplicated : Equivalent method on index.</span>
<span class="sd">        Series.duplicated : Equivalent method on Series.</span>
<span class="sd">        Series.drop_duplicates : Remove duplicate values from Series.</span>
<span class="sd">        DataFrame.drop_duplicates : Remove duplicate values from DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Consider dataset containing ramen rating.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({</span>
<span class="sd">        ...     &#39;brand&#39;: [&#39;Yum Yum&#39;, &#39;Yum Yum&#39;, &#39;Indomie&#39;, &#39;Indomie&#39;, &#39;Indomie&#39;],</span>
<span class="sd">        ...     &#39;style&#39;: [&#39;cup&#39;, &#39;cup&#39;, &#39;cup&#39;, &#39;pack&#39;, &#39;pack&#39;],</span>
<span class="sd">        ...     &#39;rating&#39;: [4, 4, 3.5, 15, 5]</span>
<span class="sd">        ... })</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">            brand style  rating</span>
<span class="sd">        0  Yum Yum   cup     4.0</span>
<span class="sd">        1  Yum Yum   cup     4.0</span>
<span class="sd">        2  Indomie   cup     3.5</span>
<span class="sd">        3  Indomie  pack    15.0</span>
<span class="sd">        4  Indomie  pack     5.0</span>

<span class="sd">        By default, for each set of duplicated values, the first occurrence</span>
<span class="sd">        is set on False and all others on True.</span>

<span class="sd">        &gt;&gt;&gt; df.duplicated()</span>
<span class="sd">        0    False</span>
<span class="sd">        1     True</span>
<span class="sd">        2    False</span>
<span class="sd">        3    False</span>
<span class="sd">        4    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        By using &#39;last&#39;, the last occurrence of each set of duplicated values</span>
<span class="sd">        is set on False and all others on True.</span>

<span class="sd">        &gt;&gt;&gt; df.duplicated(keep=&#39;last&#39;)</span>
<span class="sd">        0     True</span>
<span class="sd">        1    False</span>
<span class="sd">        2    False</span>
<span class="sd">        3    False</span>
<span class="sd">        4    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        By setting ``keep`` on False, all duplicates are True.</span>

<span class="sd">        &gt;&gt;&gt; df.duplicated(keep=False)</span>
<span class="sd">        0     True</span>
<span class="sd">        1     True</span>
<span class="sd">        2    False</span>
<span class="sd">        3    False</span>
<span class="sd">        4    False</span>
<span class="sd">        dtype: bool</span>

<span class="sd">        To find duplicates on specific column(s), use ``subset``.</span>

<span class="sd">        &gt;&gt;&gt; df.duplicated(subset=[&#39;brand&#39;])</span>
<span class="sd">        0    False</span>
<span class="sd">        1     True</span>
<span class="sd">        2    False</span>
<span class="sd">        3     True</span>
<span class="sd">        4     True</span>
<span class="sd">        dtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
            <span class="n">labels</span><span class="p">,</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">algorithms</span><span class="o">.</span><span class="n">factorize</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">size_hint</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">labels</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;i8&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># https://github.com/pandas-dev/pandas/issues/28770</span>
            <span class="c1"># Incompatible types in assignment (expression has type &quot;Index&quot;, variable</span>
            <span class="c1"># has type &quot;Sequence[Any]&quot;)</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>  <span class="c1"># type: ignore[assignment]</span>
        <span class="k">elif</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
            <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">subset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">):</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="p">(</span><span class="n">subset</span><span class="p">,)</span>

        <span class="c1">#  needed for mypy since can&#39;t narrow types using np.iterable</span>
        <span class="n">subset</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Sequence</span><span class="p">,</span> <span class="n">subset</span><span class="p">)</span>

        <span class="c1"># Verify all columns in subset exist in the queried dataframe</span>
        <span class="c1"># Otherwise, raise a KeyError, same as if you try to __getitem__ with a</span>
        <span class="c1"># key that doesn&#39;t exist.</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">diff</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">Index</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="c1"># GH#45236 This is faster than get_group_index below</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">subset</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">values</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">subset</span><span class="p">)</span>
            <span class="n">labels</span><span class="p">,</span> <span class="n">shape</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">vals</span><span class="p">)))</span>

            <span class="n">ids</span> <span class="o">=</span> <span class="n">get_group_index</span><span class="p">(</span>
                <span class="n">labels</span><span class="p">,</span>
                <span class="c1"># error: Argument 1 to &quot;tuple&quot; has incompatible type &quot;List[_T]&quot;;</span>
                <span class="c1"># expected &quot;Iterable[int]&quot;</span>
                <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span>  <span class="c1"># type: ignore[arg-type]</span>
                <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">xnull</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span><span class="n">duplicated</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">keep</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;duplicated&quot;</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Sorting</span>
    <span class="c1"># error: Signature of &quot;sort_values&quot; incompatible with supertype &quot;NDFrame&quot;</span>
    <span class="nd">@overload</span>  <span class="c1"># type: ignore[override]</span>
    <span class="k">def</span> <span class="nf">sort_values</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">by</span><span class="p">:</span> <span class="n">IndexLabel</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">ascending</span><span class="o">=...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">na_position</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">ValueKeyFunc</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">sort_values</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">by</span><span class="p">:</span> <span class="n">IndexLabel</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">ascending</span><span class="o">=...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">na_position</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">ValueKeyFunc</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="c1"># TODO: Just move the sort_values doc here.</span>
    <span class="nd">@Substitution</span><span class="p">(</span><span class="o">**</span><span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">NDFrame</span><span class="o">.</span><span class="n">sort_values</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">sort_values</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">by</span><span class="p">:</span> <span class="n">IndexLabel</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;quicksort&quot;</span><span class="p">,</span>
        <span class="n">na_position</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;last&quot;</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">ValueKeyFunc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">inplace</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">inplace</span><span class="p">,</span> <span class="s2">&quot;inplace&quot;</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">ascending</span> <span class="o">=</span> <span class="n">validate_ascending</span><span class="p">(</span><span class="n">ascending</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">by</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">by</span> <span class="o">=</span> <span class="p">[</span><span class="n">by</span><span class="p">]</span>
        <span class="c1"># error: Argument 1 to &quot;len&quot; has incompatible type &quot;Union[bool, List[bool]]&quot;;</span>
        <span class="c1"># expected &quot;Sized&quot;</span>
        <span class="k">if</span> <span class="n">is_sequence</span><span class="p">(</span><span class="n">ascending</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">by</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ascending</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
        <span class="p">):</span>
            <span class="c1"># error: Argument 1 to &quot;len&quot; has incompatible type &quot;Union[bool,</span>
            <span class="c1"># List[bool]]&quot;; expected &quot;Sized&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Length of ascending (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ascending</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>  <span class="c1"># type: ignore[arg-type]</span>
                <span class="sa">f</span><span class="s2">&quot; != length of by (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">by</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">by</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_label_or_level_values</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">by</span><span class="p">]</span>

            <span class="c1"># need to rewrap columns in Series to apply key function</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># error: List comprehension has incompatible type List[Series];</span>
                <span class="c1"># expected List[ndarray]</span>
                <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">Series</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># type: ignore[misc]</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">by</span><span class="p">)</span>
                <span class="p">]</span>

            <span class="n">indexer</span> <span class="o">=</span> <span class="n">lexsort_indexer</span><span class="p">(</span>
                <span class="n">keys</span><span class="p">,</span> <span class="n">orders</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span> <span class="n">na_position</span><span class="o">=</span><span class="n">na_position</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">by</span><span class="p">):</span>
            <span class="c1"># len(by) == 1</span>

            <span class="n">by</span> <span class="o">=</span> <span class="n">by</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_label_or_level_values</span><span class="p">(</span><span class="n">by</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

            <span class="c1"># need to rewrap column in Series to apply key function</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># error: Incompatible types in assignment (expression has type</span>
                <span class="c1"># &quot;Series&quot;, variable has type &quot;ndarray&quot;)</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">by</span><span class="p">)</span>  <span class="c1"># type: ignore[assignment]</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ascending</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="n">ascending</span> <span class="o">=</span> <span class="n">ascending</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">indexer</span> <span class="o">=</span> <span class="n">nargsort</span><span class="p">(</span>
                <span class="n">k</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span> <span class="n">na_position</span><span class="o">=</span><span class="n">na_position</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_range_indexer</span><span class="p">(</span><span class="n">indexer</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">indexer</span><span class="p">)):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="p">(</span><span class="ow">not</span> <span class="n">inplace</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">using_copy_on_write</span><span class="p">()))</span>
            <span class="k">if</span> <span class="n">ignore_index</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span>

        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">take</span><span class="p">(</span>
            <span class="n">indexer</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">verify</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">ignore_index</span><span class="p">:</span>
            <span class="n">new_data</span><span class="o">.</span><span class="n">set_axis</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_block_manager_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indexer</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_inplace</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;sort_values&quot;</span><span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">sort_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">kind</span><span class="p">:</span> <span class="n">SortKind</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">na_position</span><span class="p">:</span> <span class="n">NaPosition</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">sort_remaining</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">IndexKeyFunc</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">sort_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">kind</span><span class="p">:</span> <span class="n">SortKind</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">na_position</span><span class="p">:</span> <span class="n">NaPosition</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">sort_remaining</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">IndexKeyFunc</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">sort_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">kind</span><span class="p">:</span> <span class="n">SortKind</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">na_position</span><span class="p">:</span> <span class="n">NaPosition</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">sort_remaining</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">IndexKeyFunc</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">sort_index</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">kind</span><span class="p">:</span> <span class="n">SortKind</span> <span class="o">=</span> <span class="s2">&quot;quicksort&quot;</span><span class="p">,</span>
        <span class="n">na_position</span><span class="p">:</span> <span class="n">NaPosition</span> <span class="o">=</span> <span class="s2">&quot;last&quot;</span><span class="p">,</span>
        <span class="n">sort_remaining</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">IndexKeyFunc</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort object by labels (along an axis).</span>

<span class="sd">        Returns a new DataFrame sorted by label if `inplace` argument is</span>
<span class="sd">        ``False``, otherwise updates the original DataFrame and returns None.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            The axis along which to sort.  The value 0 identifies the rows,</span>
<span class="sd">            and 1 identifies the columns.</span>
<span class="sd">        level : int or level name or list of ints or list of level names</span>
<span class="sd">            If not None, sort on values in specified index level(s).</span>
<span class="sd">        ascending : bool or list-like of bools, default True</span>
<span class="sd">            Sort ascending vs. descending. When the index is a MultiIndex the</span>
<span class="sd">            sort direction can be controlled for each level individually.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Whether to modify the DataFrame rather than creating a new one.</span>
<span class="sd">        kind : {&#39;quicksort&#39;, &#39;mergesort&#39;, &#39;heapsort&#39;, &#39;stable&#39;}, default &#39;quicksort&#39;</span>
<span class="sd">            Choice of sorting algorithm. See also :func:`numpy.sort` for more</span>
<span class="sd">            information. `mergesort` and `stable` are the only stable algorithms. For</span>
<span class="sd">            DataFrames, this option is only applied when sorting on a single</span>
<span class="sd">            column or label.</span>
<span class="sd">        na_position : {&#39;first&#39;, &#39;last&#39;}, default &#39;last&#39;</span>
<span class="sd">            Puts NaNs at the beginning if `first`; `last` puts NaNs at the end.</span>
<span class="sd">            Not implemented for MultiIndex.</span>
<span class="sd">        sort_remaining : bool, default True</span>
<span class="sd">            If True and sorting by level and index is multilevel, sort by other</span>
<span class="sd">            levels too (in order) after sorting by specified level.</span>
<span class="sd">        ignore_index : bool, default False</span>
<span class="sd">            If True, the resulting axis will be labeled 0, 1, …, n - 1.</span>
<span class="sd">        key : callable, optional</span>
<span class="sd">            If not None, apply the key function to the index values</span>
<span class="sd">            before sorting. This is similar to the `key` argument in the</span>
<span class="sd">            builtin :meth:`sorted` function, with the notable difference that</span>
<span class="sd">            this `key` function should be *vectorized*. It should expect an</span>
<span class="sd">            ``Index`` and return an ``Index`` of the same shape. For MultiIndex</span>
<span class="sd">            inputs, the key is applied *per level*.</span>

<span class="sd">            .. versionadded:: 1.1.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame or None</span>
<span class="sd">            The original DataFrame sorted by the labels or None if ``inplace=True``.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.sort_index : Sort Series by the index.</span>
<span class="sd">        DataFrame.sort_values : Sort DataFrame by the value.</span>
<span class="sd">        Series.sort_values : Sort Series by the value.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([1, 2, 3, 4, 5], index=[100, 29, 234, 1, 150],</span>
<span class="sd">        ...                   columns=[&#39;A&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df.sort_index()</span>
<span class="sd">             A</span>
<span class="sd">        1    4</span>
<span class="sd">        29   2</span>
<span class="sd">        100  1</span>
<span class="sd">        150  5</span>
<span class="sd">        234  3</span>

<span class="sd">        By default, it sorts in ascending order, to sort in descending order,</span>
<span class="sd">        use ``ascending=False``</span>

<span class="sd">        &gt;&gt;&gt; df.sort_index(ascending=False)</span>
<span class="sd">             A</span>
<span class="sd">        234  3</span>
<span class="sd">        150  5</span>
<span class="sd">        100  1</span>
<span class="sd">        29   2</span>
<span class="sd">        1    4</span>

<span class="sd">        A key function can be specified which is applied to the index before</span>
<span class="sd">        sorting. For a ``MultiIndex`` this is applied to each level separately.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;a&quot;: [1, 2, 3, 4]}, index=[&#39;A&#39;, &#39;b&#39;, &#39;C&#39;, &#39;d&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df.sort_index(key=lambda x: x.str.lower())</span>
<span class="sd">           a</span>
<span class="sd">        A  1</span>
<span class="sd">        b  2</span>
<span class="sd">        C  3</span>
<span class="sd">        d  4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
            <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
            <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
            <span class="n">na_position</span><span class="o">=</span><span class="n">na_position</span><span class="p">,</span>
            <span class="n">sort_remaining</span><span class="o">=</span><span class="n">sort_remaining</span><span class="p">,</span>
            <span class="n">ignore_index</span><span class="o">=</span><span class="n">ignore_index</span><span class="p">,</span>
            <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">value_counts</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">subset</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">sort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dropna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a Series containing counts of unique rows in the DataFrame.</span>

<span class="sd">        .. versionadded:: 1.1.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        subset : label or list of labels, optional</span>
<span class="sd">            Columns to use when counting unique combinations.</span>
<span class="sd">        normalize : bool, default False</span>
<span class="sd">            Return proportions rather than frequencies.</span>
<span class="sd">        sort : bool, default True</span>
<span class="sd">            Sort by frequencies.</span>
<span class="sd">        ascending : bool, default False</span>
<span class="sd">            Sort in ascending order.</span>
<span class="sd">        dropna : bool, default True</span>
<span class="sd">            Don’t include counts of rows that contain NA values.</span>

<span class="sd">            .. versionadded:: 1.3.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.value_counts: Equivalent method on Series.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The returned Series will have a MultiIndex with one level per input</span>
<span class="sd">        column but an Index (non-multi) for a single label. By default, rows</span>
<span class="sd">        that contain any NA values are omitted from the result. By default,</span>
<span class="sd">        the resulting Series will be in descending order so that the first</span>
<span class="sd">        element is the most frequently-occurring row.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;num_legs&#39;: [2, 4, 4, 6],</span>
<span class="sd">        ...                    &#39;num_wings&#39;: [2, 0, 0, 0]},</span>
<span class="sd">        ...                   index=[&#39;falcon&#39;, &#39;dog&#39;, &#39;cat&#39;, &#39;ant&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                num_legs  num_wings</span>
<span class="sd">        falcon         2          2</span>
<span class="sd">        dog            4          0</span>
<span class="sd">        cat            4          0</span>
<span class="sd">        ant            6          0</span>

<span class="sd">        &gt;&gt;&gt; df.value_counts()</span>
<span class="sd">        num_legs  num_wings</span>
<span class="sd">        4         0            2</span>
<span class="sd">        2         2            1</span>
<span class="sd">        6         0            1</span>
<span class="sd">        Name: count, dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; df.value_counts(sort=False)</span>
<span class="sd">        num_legs  num_wings</span>
<span class="sd">        2         2            1</span>
<span class="sd">        4         0            2</span>
<span class="sd">        6         0            1</span>
<span class="sd">        Name: count, dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; df.value_counts(ascending=True)</span>
<span class="sd">        num_legs  num_wings</span>
<span class="sd">        2         2            1</span>
<span class="sd">        6         0            1</span>
<span class="sd">        4         0            2</span>
<span class="sd">        Name: count, dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; df.value_counts(normalize=True)</span>
<span class="sd">        num_legs  num_wings</span>
<span class="sd">        4         0            0.50</span>
<span class="sd">        2         2            0.25</span>
<span class="sd">        6         0            0.25</span>
<span class="sd">        Name: proportion, dtype: float64</span>

<span class="sd">        With `dropna` set to `False` we can also count rows with NA values.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;first_name&#39;: [&#39;John&#39;, &#39;Anne&#39;, &#39;John&#39;, &#39;Beth&#39;],</span>
<span class="sd">        ...                    &#39;middle_name&#39;: [&#39;Smith&#39;, pd.NA, pd.NA, &#39;Louise&#39;]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">          first_name middle_name</span>
<span class="sd">        0       John       Smith</span>
<span class="sd">        1       Anne        &lt;NA&gt;</span>
<span class="sd">        2       John        &lt;NA&gt;</span>
<span class="sd">        3       Beth      Louise</span>

<span class="sd">        &gt;&gt;&gt; df.value_counts()</span>
<span class="sd">        first_name  middle_name</span>
<span class="sd">        Beth        Louise         1</span>
<span class="sd">        John        Smith          1</span>
<span class="sd">        Name: count, dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; df.value_counts(dropna=False)</span>
<span class="sd">        first_name  middle_name</span>
<span class="sd">        Anne        NaN            1</span>
<span class="sd">        Beth        Louise         1</span>
<span class="sd">        John        Smith          1</span>
<span class="sd">                    NaN            1</span>
<span class="sd">        Name: count, dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; df.value_counts(&quot;first_name&quot;)</span>
<span class="sd">        first_name</span>
<span class="sd">        John    2</span>
<span class="sd">        Anne    1</span>
<span class="sd">        Beth    1</span>
<span class="sd">        Name: count, dtype: int64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;proportion&quot;</span> <span class="k">if</span> <span class="n">normalize</span> <span class="k">else</span> <span class="s2">&quot;count&quot;</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">dropna</span><span class="o">=</span><span class="n">dropna</span><span class="p">)</span><span class="o">.</span><span class="n">grouper</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="n">counts</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">/=</span> <span class="n">counts</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># Force MultiIndex for single column</span>
        <span class="k">if</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">counts</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span>
                <span class="p">[</span><span class="n">counts</span><span class="o">.</span><span class="n">index</span><span class="p">],</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="n">counts</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">counts</span>

    <span class="k">def</span> <span class="nf">nlargest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">columns</span><span class="p">:</span> <span class="n">IndexLabel</span><span class="p">,</span> <span class="n">keep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;first&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the first `n` rows ordered by `columns` in descending order.</span>

<span class="sd">        Return the first `n` rows with the largest values in `columns`, in</span>
<span class="sd">        descending order. The columns that are not specified are returned as</span>
<span class="sd">        well, but not used for ordering.</span>

<span class="sd">        This method is equivalent to</span>
<span class="sd">        ``df.sort_values(columns, ascending=False).head(n)``, but more</span>
<span class="sd">        performant.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int</span>
<span class="sd">            Number of rows to return.</span>
<span class="sd">        columns : label or list of labels</span>
<span class="sd">            Column label(s) to order by.</span>
<span class="sd">        keep : {&#39;first&#39;, &#39;last&#39;, &#39;all&#39;}, default &#39;first&#39;</span>
<span class="sd">            Where there are duplicate values:</span>

<span class="sd">            - ``first`` : prioritize the first occurrence(s)</span>
<span class="sd">            - ``last`` : prioritize the last occurrence(s)</span>
<span class="sd">            - ``all`` : do not drop any duplicates, even it means</span>
<span class="sd">              selecting more than `n` items.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            The first `n` rows ordered by the given columns in descending</span>
<span class="sd">            order.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.nsmallest : Return the first `n` rows ordered by `columns` in</span>
<span class="sd">            ascending order.</span>
<span class="sd">        DataFrame.sort_values : Sort DataFrame by the values.</span>
<span class="sd">        DataFrame.head : Return the first `n` rows without re-ordering.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function cannot be used with all column types. For example, when</span>
<span class="sd">        specifying columns with `object` or `category` dtypes, ``TypeError`` is</span>
<span class="sd">        raised.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;population&#39;: [59000000, 65000000, 434000,</span>
<span class="sd">        ...                                   434000, 434000, 337000, 11300,</span>
<span class="sd">        ...                                   11300, 11300],</span>
<span class="sd">        ...                    &#39;GDP&#39;: [1937894, 2583560 , 12011, 4520, 12128,</span>
<span class="sd">        ...                            17036, 182, 38, 311],</span>
<span class="sd">        ...                    &#39;alpha-2&#39;: [&quot;IT&quot;, &quot;FR&quot;, &quot;MT&quot;, &quot;MV&quot;, &quot;BN&quot;,</span>
<span class="sd">        ...                                &quot;IS&quot;, &quot;NR&quot;, &quot;TV&quot;, &quot;AI&quot;]},</span>
<span class="sd">        ...                   index=[&quot;Italy&quot;, &quot;France&quot;, &quot;Malta&quot;,</span>
<span class="sd">        ...                          &quot;Maldives&quot;, &quot;Brunei&quot;, &quot;Iceland&quot;,</span>
<span class="sd">        ...                          &quot;Nauru&quot;, &quot;Tuvalu&quot;, &quot;Anguilla&quot;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                  population      GDP alpha-2</span>
<span class="sd">        Italy       59000000  1937894      IT</span>
<span class="sd">        France      65000000  2583560      FR</span>
<span class="sd">        Malta         434000    12011      MT</span>
<span class="sd">        Maldives      434000     4520      MV</span>
<span class="sd">        Brunei        434000    12128      BN</span>
<span class="sd">        Iceland       337000    17036      IS</span>
<span class="sd">        Nauru          11300      182      NR</span>
<span class="sd">        Tuvalu         11300       38      TV</span>
<span class="sd">        Anguilla       11300      311      AI</span>

<span class="sd">        In the following example, we will use ``nlargest`` to select the three</span>
<span class="sd">        rows having the largest values in column &quot;population&quot;.</span>

<span class="sd">        &gt;&gt;&gt; df.nlargest(3, &#39;population&#39;)</span>
<span class="sd">                population      GDP alpha-2</span>
<span class="sd">        France    65000000  2583560      FR</span>
<span class="sd">        Italy     59000000  1937894      IT</span>
<span class="sd">        Malta       434000    12011      MT</span>

<span class="sd">        When using ``keep=&#39;last&#39;``, ties are resolved in reverse order:</span>

<span class="sd">        &gt;&gt;&gt; df.nlargest(3, &#39;population&#39;, keep=&#39;last&#39;)</span>
<span class="sd">                population      GDP alpha-2</span>
<span class="sd">        France    65000000  2583560      FR</span>
<span class="sd">        Italy     59000000  1937894      IT</span>
<span class="sd">        Brunei      434000    12128      BN</span>

<span class="sd">        When using ``keep=&#39;all&#39;``, all duplicate items are maintained:</span>

<span class="sd">        &gt;&gt;&gt; df.nlargest(3, &#39;population&#39;, keep=&#39;all&#39;)</span>
<span class="sd">                  population      GDP alpha-2</span>
<span class="sd">        France      65000000  2583560      FR</span>
<span class="sd">        Italy       59000000  1937894      IT</span>
<span class="sd">        Malta         434000    12011      MT</span>
<span class="sd">        Maldives      434000     4520      MV</span>
<span class="sd">        Brunei        434000    12128      BN</span>

<span class="sd">        To order by the largest values in column &quot;population&quot; and then &quot;GDP&quot;,</span>
<span class="sd">        we can specify multiple columns like in the next example.</span>

<span class="sd">        &gt;&gt;&gt; df.nlargest(3, [&#39;population&#39;, &#39;GDP&#39;])</span>
<span class="sd">                population      GDP alpha-2</span>
<span class="sd">        France    65000000  2583560      FR</span>
<span class="sd">        Italy     59000000  1937894      IT</span>
<span class="sd">        Brunei      434000    12128      BN</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">selectn</span><span class="o">.</span><span class="n">SelectNFrame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="n">keep</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">nlargest</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">nsmallest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">columns</span><span class="p">:</span> <span class="n">IndexLabel</span><span class="p">,</span> <span class="n">keep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;first&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the first `n` rows ordered by `columns` in ascending order.</span>

<span class="sd">        Return the first `n` rows with the smallest values in `columns`, in</span>
<span class="sd">        ascending order. The columns that are not specified are returned as</span>
<span class="sd">        well, but not used for ordering.</span>

<span class="sd">        This method is equivalent to</span>
<span class="sd">        ``df.sort_values(columns, ascending=True).head(n)``, but more</span>
<span class="sd">        performant.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int</span>
<span class="sd">            Number of items to retrieve.</span>
<span class="sd">        columns : list or str</span>
<span class="sd">            Column name or names to order by.</span>
<span class="sd">        keep : {&#39;first&#39;, &#39;last&#39;, &#39;all&#39;}, default &#39;first&#39;</span>
<span class="sd">            Where there are duplicate values:</span>

<span class="sd">            - ``first`` : take the first occurrence.</span>
<span class="sd">            - ``last`` : take the last occurrence.</span>
<span class="sd">            - ``all`` : do not drop any duplicates, even it means</span>
<span class="sd">              selecting more than `n` items.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.nlargest : Return the first `n` rows ordered by `columns` in</span>
<span class="sd">            descending order.</span>
<span class="sd">        DataFrame.sort_values : Sort DataFrame by the values.</span>
<span class="sd">        DataFrame.head : Return the first `n` rows without re-ordering.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;population&#39;: [59000000, 65000000, 434000,</span>
<span class="sd">        ...                                   434000, 434000, 337000, 337000,</span>
<span class="sd">        ...                                   11300, 11300],</span>
<span class="sd">        ...                    &#39;GDP&#39;: [1937894, 2583560 , 12011, 4520, 12128,</span>
<span class="sd">        ...                            17036, 182, 38, 311],</span>
<span class="sd">        ...                    &#39;alpha-2&#39;: [&quot;IT&quot;, &quot;FR&quot;, &quot;MT&quot;, &quot;MV&quot;, &quot;BN&quot;,</span>
<span class="sd">        ...                                &quot;IS&quot;, &quot;NR&quot;, &quot;TV&quot;, &quot;AI&quot;]},</span>
<span class="sd">        ...                   index=[&quot;Italy&quot;, &quot;France&quot;, &quot;Malta&quot;,</span>
<span class="sd">        ...                          &quot;Maldives&quot;, &quot;Brunei&quot;, &quot;Iceland&quot;,</span>
<span class="sd">        ...                          &quot;Nauru&quot;, &quot;Tuvalu&quot;, &quot;Anguilla&quot;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                  population      GDP alpha-2</span>
<span class="sd">        Italy       59000000  1937894      IT</span>
<span class="sd">        France      65000000  2583560      FR</span>
<span class="sd">        Malta         434000    12011      MT</span>
<span class="sd">        Maldives      434000     4520      MV</span>
<span class="sd">        Brunei        434000    12128      BN</span>
<span class="sd">        Iceland       337000    17036      IS</span>
<span class="sd">        Nauru         337000      182      NR</span>
<span class="sd">        Tuvalu         11300       38      TV</span>
<span class="sd">        Anguilla       11300      311      AI</span>

<span class="sd">        In the following example, we will use ``nsmallest`` to select the</span>
<span class="sd">        three rows having the smallest values in column &quot;population&quot;.</span>

<span class="sd">        &gt;&gt;&gt; df.nsmallest(3, &#39;population&#39;)</span>
<span class="sd">                  population    GDP alpha-2</span>
<span class="sd">        Tuvalu         11300     38      TV</span>
<span class="sd">        Anguilla       11300    311      AI</span>
<span class="sd">        Iceland       337000  17036      IS</span>

<span class="sd">        When using ``keep=&#39;last&#39;``, ties are resolved in reverse order:</span>

<span class="sd">        &gt;&gt;&gt; df.nsmallest(3, &#39;population&#39;, keep=&#39;last&#39;)</span>
<span class="sd">                  population  GDP alpha-2</span>
<span class="sd">        Anguilla       11300  311      AI</span>
<span class="sd">        Tuvalu         11300   38      TV</span>
<span class="sd">        Nauru         337000  182      NR</span>

<span class="sd">        When using ``keep=&#39;all&#39;``, all duplicate items are maintained:</span>

<span class="sd">        &gt;&gt;&gt; df.nsmallest(3, &#39;population&#39;, keep=&#39;all&#39;)</span>
<span class="sd">                  population    GDP alpha-2</span>
<span class="sd">        Tuvalu         11300     38      TV</span>
<span class="sd">        Anguilla       11300    311      AI</span>
<span class="sd">        Iceland       337000  17036      IS</span>
<span class="sd">        Nauru         337000    182      NR</span>

<span class="sd">        To order by the smallest values in column &quot;population&quot; and then &quot;GDP&quot;, we can</span>
<span class="sd">        specify multiple columns like in the next example.</span>

<span class="sd">        &gt;&gt;&gt; df.nsmallest(3, [&#39;population&#39;, &#39;GDP&#39;])</span>
<span class="sd">                  population  GDP alpha-2</span>
<span class="sd">        Tuvalu         11300   38      TV</span>
<span class="sd">        Anguilla       11300  311      AI</span>
<span class="sd">        Nauru         337000  182      NR</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">selectn</span><span class="o">.</span><span class="n">SelectNFrame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="n">keep</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">()</span>

    <span class="nd">@doc</span><span class="p">(</span>
        <span class="n">Series</span><span class="o">.</span><span class="n">swaplevel</span><span class="p">,</span>
        <span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">],</span>
        <span class="n">extra_params</span><span class="o">=</span><span class="n">dedent</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            The axis to swap levels on. 0 or &#39;index&#39; for row-wise, 1 or</span>
<span class="sd">            &#39;columns&#39; for column-wise.&quot;&quot;&quot;</span>
        <span class="p">),</span>
        <span class="n">examples</span><span class="o">=</span><span class="n">dedent</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;\</span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(</span>
<span class="sd">        ...     {&quot;Grade&quot;: [&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;C&quot;]},</span>
<span class="sd">        ...     index=[</span>
<span class="sd">        ...         [&quot;Final exam&quot;, &quot;Final exam&quot;, &quot;Coursework&quot;, &quot;Coursework&quot;],</span>
<span class="sd">        ...         [&quot;History&quot;, &quot;Geography&quot;, &quot;History&quot;, &quot;Geography&quot;],</span>
<span class="sd">        ...         [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;],</span>
<span class="sd">        ...     ],</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                                            Grade</span>
<span class="sd">        Final exam  History     January      A</span>
<span class="sd">                    Geography   February     B</span>
<span class="sd">        Coursework  History     March        A</span>
<span class="sd">                    Geography   April        C</span>

<span class="sd">        In the following example, we will swap the levels of the indices.</span>
<span class="sd">        Here, we will swap the levels column-wise, but levels can be swapped row-wise</span>
<span class="sd">        in a similar manner. Note that column-wise is the default behaviour.</span>
<span class="sd">        By not supplying any arguments for i and j, we swap the last and second to</span>
<span class="sd">        last indices.</span>

<span class="sd">        &gt;&gt;&gt; df.swaplevel()</span>
<span class="sd">                                            Grade</span>
<span class="sd">        Final exam  January     History         A</span>
<span class="sd">                    February    Geography       B</span>
<span class="sd">        Coursework  March       History         A</span>
<span class="sd">                    April       Geography       C</span>

<span class="sd">        By supplying one argument, we can choose which index to swap the last</span>
<span class="sd">        index with. We can for example swap the first index with the last one as</span>
<span class="sd">        follows.</span>

<span class="sd">        &gt;&gt;&gt; df.swaplevel(0)</span>
<span class="sd">                                            Grade</span>
<span class="sd">        January     History     Final exam      A</span>
<span class="sd">        February    Geography   Final exam      B</span>
<span class="sd">        March       History     Coursework      A</span>
<span class="sd">        April       Geography   Coursework      C</span>

<span class="sd">        We can also define explicitly which indices we want to swap by supplying values</span>
<span class="sd">        for both i and j. Here, we for example swap the first and second indices.</span>

<span class="sd">        &gt;&gt;&gt; df.swaplevel(0, 1)</span>
<span class="sd">                                            Grade</span>
<span class="sd">        History     Final exam  January         A</span>
<span class="sd">        Geography   Final exam  February        B</span>
<span class="sd">        History     Coursework  March           A</span>
<span class="sd">        Geography   Coursework  April           C&quot;&quot;&quot;</span>
        <span class="p">),</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">swaplevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">MultiIndex</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only swap levels on a hierarchical axis.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">swaplevel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">swaplevel</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">reorder_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">],</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rearrange index levels using input order. May not drop or duplicate levels.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : list of int or list of str</span>
<span class="sd">            List representing new level order. Reference level by number</span>
<span class="sd">            (position) or by key (label).</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            Where to reorder levels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; data = {</span>
<span class="sd">        ...     &quot;class&quot;: [&quot;Mammals&quot;, &quot;Mammals&quot;, &quot;Reptiles&quot;],</span>
<span class="sd">        ...     &quot;diet&quot;: [&quot;Omnivore&quot;, &quot;Carnivore&quot;, &quot;Carnivore&quot;],</span>
<span class="sd">        ...     &quot;species&quot;: [&quot;Humans&quot;, &quot;Dogs&quot;, &quot;Snakes&quot;],</span>
<span class="sd">        ... }</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(data, columns=[&quot;class&quot;, &quot;diet&quot;, &quot;species&quot;])</span>
<span class="sd">        &gt;&gt;&gt; df = df.set_index([&quot;class&quot;, &quot;diet&quot;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                                          species</span>
<span class="sd">        class      diet</span>
<span class="sd">        Mammals    Omnivore                Humans</span>
<span class="sd">                   Carnivore                 Dogs</span>
<span class="sd">        Reptiles   Carnivore               Snakes</span>

<span class="sd">        Let&#39;s reorder the levels of the index:</span>

<span class="sd">        &gt;&gt;&gt; df.reorder_levels([&quot;diet&quot;, &quot;class&quot;])</span>
<span class="sd">                                          species</span>
<span class="sd">        diet      class</span>
<span class="sd">        Omnivore  Mammals                  Humans</span>
<span class="sd">        Carnivore Mammals                    Dogs</span>
<span class="sd">                  Reptiles                 Snakes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">MultiIndex</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only reorder levels on a hierarchical axis.&quot;</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">reorder_levels</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">reorder_levels</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Arithmetic Methods</span>

    <span class="k">def</span> <span class="nf">_cmp_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># only relevant for Series other case</span>

        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">align_method_FRAME</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">flex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># See GH#4537 for discussion of scalar op behavior</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dispatch_frame_op</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_result</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_arith_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ops</span><span class="o">.</span><span class="n">should_reindex_frame_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ops</span><span class="o">.</span><span class="n">frame_arith_method_with_reindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

        <span class="n">axis</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># only relevant for Series other case</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">maybe_prepare_scalar_for_op</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],))</span>

        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">align_method_FRAME</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">flex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dispatch_frame_op</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_construct_result</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>

    <span class="n">_logical_method</span> <span class="o">=</span> <span class="n">_arith_method</span>

    <span class="k">def</span> <span class="nf">_dispatch_frame_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">AxisInt</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluate the frame operation func(left, right) by evaluating</span>
<span class="sd">        column-by-column, dispatching to the Series implementation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        right : scalar, Series, or DataFrame</span>
<span class="sd">        func : arithmetic or comparison operator</span>
<span class="sd">        axis : {None, 0, 1}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the appropriate array-op to apply to each column/block&#39;s values.</span>
        <span class="n">array_op</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">get_array_op</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

        <span class="n">right</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">item_from_zerodim</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">right</span><span class="p">):</span>
            <span class="c1"># i.e. scalar, faster than checking np.ndim(right) == 0</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                <span class="n">bm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">array_op</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">bm</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">right</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="c1"># TODO: The previous assertion `assert right._indexed_same(self)`</span>
            <span class="c1">#  fails in cases with empty columns reached via</span>
            <span class="c1">#  _frame_arith_method_with_reindex</span>

            <span class="c1"># TODO operate_blockwise expects a manager of the same type</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                <span class="n">bm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">operate_blockwise</span><span class="p">(</span>
                    <span class="c1"># error: Argument 1 to &quot;operate_blockwise&quot; of &quot;ArrayManager&quot; has</span>
                    <span class="c1"># incompatible type &quot;Union[ArrayManager, BlockManager]&quot;; expected</span>
                    <span class="c1"># &quot;ArrayManager&quot;</span>
                    <span class="c1"># error: Argument 1 to &quot;operate_blockwise&quot; of &quot;BlockManager&quot; has</span>
                    <span class="c1"># incompatible type &quot;Union[ArrayManager, BlockManager]&quot;; expected</span>
                    <span class="c1"># &quot;BlockManager&quot;</span>
                    <span class="n">right</span><span class="o">.</span><span class="n">_mgr</span><span class="p">,</span>  <span class="c1"># type: ignore[arg-type]</span>
                    <span class="n">array_op</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">bm</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">Series</span><span class="p">)</span> <span class="ow">and</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># axis=1 means we want to operate row-by-row</span>
            <span class="k">assert</span> <span class="n">right</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">_values</span>
            <span class="c1"># maybe_align_as_frame ensures we do not have an ndarray here</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>

            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">array_op</span><span class="p">(</span><span class="n">_left</span><span class="p">,</span> <span class="n">_right</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">_left</span><span class="p">,</span> <span class="n">_right</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iter_column_arrays</span><span class="p">(),</span> <span class="n">right</span><span class="p">)</span>
                <span class="p">]</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">right</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>  <span class="c1"># Handle other cases later</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">_values</span>

            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">array_op</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="k">for</span> <span class="n">left</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_column_arrays</span><span class="p">()]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Remaining cases have less-obvious dispatch rules</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_from_arrays</span><span class="p">(</span>
            <span class="n">arrays</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">verify_integrity</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_combine_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># at this point we have `self._indexed_same(other)`</span>

        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># since _arith_op may be called in a loop, avoid function call</span>
            <span class="c1">#  overhead if possible by doing this check once</span>
            <span class="n">_arith_op</span> <span class="o">=</span> <span class="n">func</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">_arith_op</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">):</span>
                <span class="c1"># for the mixed_type case where we iterate over columns,</span>
                <span class="c1"># _arith_op(left, right) is equivalent to</span>
                <span class="c1"># left._binop(right, func, fill_value=fill_value)</span>
                <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">fill_binop</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dispatch_frame_op</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">_arith_op</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_data</span>

    <span class="k">def</span> <span class="nf">_construct_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrap the result of an arithmetic, comparison, or logical operation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        result : DataFrame</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># Pin columns instead of passing to constructor for compat with</span>
        <span class="c1">#  non-unique columns case</span>
        <span class="n">out</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">out</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="fm">__divmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">]:</span>
        <span class="c1"># Naive implementation, room for optimization</span>
        <span class="n">div</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">//</span> <span class="n">other</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">div</span> <span class="o">*</span> <span class="n">other</span>
        <span class="k">return</span> <span class="n">div</span><span class="p">,</span> <span class="n">mod</span>

    <span class="k">def</span> <span class="fm">__rdivmod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">]:</span>
        <span class="c1"># Naive implementation, room for optimization</span>
        <span class="n">div</span> <span class="o">=</span> <span class="n">other</span> <span class="o">//</span> <span class="bp">self</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="n">other</span> <span class="o">-</span> <span class="n">div</span> <span class="o">*</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="n">div</span><span class="p">,</span> <span class="n">mod</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Combination-Related</span>

    <span class="nd">@doc</span><span class="p">(</span>
        <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;compare&quot;</span><span class="p">],</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Returns</span>
<span class="sd">-------</span>
<span class="sd">DataFrame</span>
<span class="sd">    DataFrame that shows the differences stacked side by side.</span>

<span class="sd">    The resulting index will be a MultiIndex with &#39;self&#39; and &#39;other&#39;</span>
<span class="sd">    stacked alternately at the inner level.</span>

<span class="sd">Raises</span>
<span class="sd">------</span>
<span class="sd">ValueError</span>
<span class="sd">    When the two DataFrames don&#39;t have identical labels or shape.</span>

<span class="sd">See Also</span>
<span class="sd">--------</span>
<span class="sd">Series.compare : Compare with another Series and show differences.</span>
<span class="sd">DataFrame.equals : Test whether two objects contain the same elements.</span>

<span class="sd">Notes</span>
<span class="sd">-----</span>
<span class="sd">Matching NaNs will not appear as a difference.</span>

<span class="sd">Can only compare identically-labeled</span>
<span class="sd">(i.e. same shape, identical row and column labels) DataFrames</span>

<span class="sd">Examples</span>
<span class="sd">--------</span>
<span class="sd">&gt;&gt;&gt; df = pd.DataFrame(</span>
<span class="sd">...     {{</span>
<span class="sd">...         &quot;col1&quot;: [&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;],</span>
<span class="sd">...         &quot;col2&quot;: [1.0, 2.0, 3.0, np.nan, 5.0],</span>
<span class="sd">...         &quot;col3&quot;: [1.0, 2.0, 3.0, 4.0, 5.0]</span>
<span class="sd">...     }},</span>
<span class="sd">...     columns=[&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;],</span>
<span class="sd">... )</span>
<span class="sd">&gt;&gt;&gt; df</span>
<span class="sd">  col1  col2  col3</span>
<span class="sd">0    a   1.0   1.0</span>
<span class="sd">1    a   2.0   2.0</span>
<span class="sd">2    b   3.0   3.0</span>
<span class="sd">3    b   NaN   4.0</span>
<span class="sd">4    a   5.0   5.0</span>

<span class="sd">&gt;&gt;&gt; df2 = df.copy()</span>
<span class="sd">&gt;&gt;&gt; df2.loc[0, &#39;col1&#39;] = &#39;c&#39;</span>
<span class="sd">&gt;&gt;&gt; df2.loc[2, &#39;col3&#39;] = 4.0</span>
<span class="sd">&gt;&gt;&gt; df2</span>
<span class="sd">  col1  col2  col3</span>
<span class="sd">0    c   1.0   1.0</span>
<span class="sd">1    a   2.0   2.0</span>
<span class="sd">2    b   3.0   4.0</span>
<span class="sd">3    b   NaN   4.0</span>
<span class="sd">4    a   5.0   5.0</span>

<span class="sd">Align the differences on columns</span>

<span class="sd">&gt;&gt;&gt; df.compare(df2)</span>
<span class="sd">  col1       col3</span>
<span class="sd">  self other self other</span>
<span class="sd">0    a     c  NaN   NaN</span>
<span class="sd">2  NaN   NaN  3.0   4.0</span>

<span class="sd">Assign result_names</span>

<span class="sd">&gt;&gt;&gt; df.compare(df2, result_names=(&quot;left&quot;, &quot;right&quot;))</span>
<span class="sd">  col1       col3</span>
<span class="sd">  left right left right</span>
<span class="sd">0    a     c  NaN   NaN</span>
<span class="sd">2  NaN   NaN  3.0   4.0</span>

<span class="sd">Stack the differences on rows</span>

<span class="sd">&gt;&gt;&gt; df.compare(df2, align_axis=0)</span>
<span class="sd">        col1  col3</span>
<span class="sd">0 self     a   NaN</span>
<span class="sd">  other    c   NaN</span>
<span class="sd">2 self   NaN   3.0</span>
<span class="sd">  other  NaN   4.0</span>

<span class="sd">Keep the equal values</span>

<span class="sd">&gt;&gt;&gt; df.compare(df2, keep_equal=True)</span>
<span class="sd">  col1       col3</span>
<span class="sd">  self other self other</span>
<span class="sd">0    a     c  1.0   1.0</span>
<span class="sd">2    b     b  3.0   4.0</span>

<span class="sd">Keep all original rows and columns</span>

<span class="sd">&gt;&gt;&gt; df.compare(df2, keep_shape=True)</span>
<span class="sd">  col1       col2       col3</span>
<span class="sd">  self other self other self other</span>
<span class="sd">0    a     c  NaN   NaN  NaN   NaN</span>
<span class="sd">1  NaN   NaN  NaN   NaN  NaN   NaN</span>
<span class="sd">2  NaN   NaN  NaN   NaN  3.0   4.0</span>
<span class="sd">3  NaN   NaN  NaN   NaN  NaN   NaN</span>
<span class="sd">4  NaN   NaN  NaN   NaN  NaN   NaN</span>

<span class="sd">Keep all original rows and columns and also all original values</span>

<span class="sd">&gt;&gt;&gt; df.compare(df2, keep_shape=True, keep_equal=True)</span>
<span class="sd">  col1       col2       col3</span>
<span class="sd">  self other self other self other</span>
<span class="sd">0    a     c  1.0   1.0  1.0   1.0</span>
<span class="sd">1    a     a  2.0   2.0  2.0   2.0</span>
<span class="sd">2    b     b  3.0   3.0  3.0   4.0</span>
<span class="sd">3    b     b  NaN   NaN  4.0   4.0</span>
<span class="sd">4    a     a  5.0   5.0  5.0   5.0</span>
<span class="sd">&quot;&quot;&quot;</span><span class="p">,</span>
        <span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">align_axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">keep_shape</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">keep_equal</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">result_names</span><span class="p">:</span> <span class="n">Suffixes</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;self&quot;</span><span class="p">,</span> <span class="s2">&quot;other&quot;</span><span class="p">),</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span>
            <span class="n">other</span><span class="o">=</span><span class="n">other</span><span class="p">,</span>
            <span class="n">align_axis</span><span class="o">=</span><span class="n">align_axis</span><span class="p">,</span>
            <span class="n">keep_shape</span><span class="o">=</span><span class="n">keep_shape</span><span class="p">,</span>
            <span class="n">keep_equal</span><span class="o">=</span><span class="n">keep_equal</span><span class="p">,</span>
            <span class="n">result_names</span><span class="o">=</span><span class="n">result_names</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">combine</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Series</span><span class="p">,</span> <span class="n">Series</span><span class="p">],</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">Hashable</span><span class="p">],</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform column-wise combine with another DataFrame.</span>

<span class="sd">        Combines a DataFrame with `other` DataFrame using `func`</span>
<span class="sd">        to element-wise combine columns. The row and column indexes of the</span>
<span class="sd">        resulting DataFrame will be the union of the two.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : DataFrame</span>
<span class="sd">            The DataFrame to merge column-wise.</span>
<span class="sd">        func : function</span>
<span class="sd">            Function that takes two series as inputs and return a Series or a</span>
<span class="sd">            scalar. Used to merge the two dataframes column by columns.</span>
<span class="sd">        fill_value : scalar value, default None</span>
<span class="sd">            The value to fill NaNs with prior to passing any column to the</span>
<span class="sd">            merge func.</span>
<span class="sd">        overwrite : bool, default True</span>
<span class="sd">            If True, columns in `self` that do not exist in `other` will be</span>
<span class="sd">            overwritten with NaNs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            Combination of the provided DataFrames.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.combine_first : Combine two DataFrame objects and default to</span>
<span class="sd">            non-null values in frame calling the method.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Combine using a simple function that chooses the smaller column.</span>

<span class="sd">        &gt;&gt;&gt; df1 = pd.DataFrame({&#39;A&#39;: [0, 0], &#39;B&#39;: [4, 4]})</span>
<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame({&#39;A&#39;: [1, 1], &#39;B&#39;: [3, 3]})</span>
<span class="sd">        &gt;&gt;&gt; take_smaller = lambda s1, s2: s1 if s1.sum() &lt; s2.sum() else s2</span>
<span class="sd">        &gt;&gt;&gt; df1.combine(df2, take_smaller)</span>
<span class="sd">           A  B</span>
<span class="sd">        0  0  3</span>
<span class="sd">        1  0  3</span>

<span class="sd">        Example using a true element-wise combine function.</span>

<span class="sd">        &gt;&gt;&gt; df1 = pd.DataFrame({&#39;A&#39;: [5, 0], &#39;B&#39;: [2, 4]})</span>
<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame({&#39;A&#39;: [1, 1], &#39;B&#39;: [3, 3]})</span>
<span class="sd">        &gt;&gt;&gt; df1.combine(df2, np.minimum)</span>
<span class="sd">           A  B</span>
<span class="sd">        0  1  2</span>
<span class="sd">        1  0  3</span>

<span class="sd">        Using `fill_value` fills Nones prior to passing the column to the</span>
<span class="sd">        merge function.</span>

<span class="sd">        &gt;&gt;&gt; df1 = pd.DataFrame({&#39;A&#39;: [0, 0], &#39;B&#39;: [None, 4]})</span>
<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame({&#39;A&#39;: [1, 1], &#39;B&#39;: [3, 3]})</span>
<span class="sd">        &gt;&gt;&gt; df1.combine(df2, take_smaller, fill_value=-5)</span>
<span class="sd">           A    B</span>
<span class="sd">        0  0 -5.0</span>
<span class="sd">        1  0  4.0</span>

<span class="sd">        However, if the same element in both dataframes is None, that None</span>
<span class="sd">        is preserved</span>

<span class="sd">        &gt;&gt;&gt; df1 = pd.DataFrame({&#39;A&#39;: [0, 0], &#39;B&#39;: [None, 4]})</span>
<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame({&#39;A&#39;: [1, 1], &#39;B&#39;: [None, 3]})</span>
<span class="sd">        &gt;&gt;&gt; df1.combine(df2, take_smaller, fill_value=-5)</span>
<span class="sd">            A    B</span>
<span class="sd">        0  0 -5.0</span>
<span class="sd">        1  0  3.0</span>

<span class="sd">        Example that demonstrates the use of `overwrite` and behavior when</span>
<span class="sd">        the axis differ between the dataframes.</span>

<span class="sd">        &gt;&gt;&gt; df1 = pd.DataFrame({&#39;A&#39;: [0, 0], &#39;B&#39;: [4, 4]})</span>
<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame({&#39;B&#39;: [3, 3], &#39;C&#39;: [-10, 1], }, index=[1, 2])</span>
<span class="sd">        &gt;&gt;&gt; df1.combine(df2, take_smaller)</span>
<span class="sd">             A    B     C</span>
<span class="sd">        0  NaN  NaN   NaN</span>
<span class="sd">        1  NaN  3.0 -10.0</span>
<span class="sd">        2  NaN  3.0   1.0</span>

<span class="sd">        &gt;&gt;&gt; df1.combine(df2, take_smaller, overwrite=False)</span>
<span class="sd">             A    B     C</span>
<span class="sd">        0  0.0  NaN   NaN</span>
<span class="sd">        1  0.0  3.0 -10.0</span>
<span class="sd">        2  NaN  3.0   1.0</span>

<span class="sd">        Demonstrating the preference of the passed in dataframe.</span>

<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame({&#39;B&#39;: [3, 3], &#39;C&#39;: [1, 1], }, index=[1, 2])</span>
<span class="sd">        &gt;&gt;&gt; df2.combine(df1, take_smaller)</span>
<span class="sd">           A    B   C</span>
<span class="sd">        0  0.0  NaN NaN</span>
<span class="sd">        1  0.0  3.0 NaN</span>
<span class="sd">        2  NaN  3.0 NaN</span>

<span class="sd">        &gt;&gt;&gt; df2.combine(df1, take_smaller, overwrite=False)</span>
<span class="sd">             A    B   C</span>
<span class="sd">        0  0.0  NaN NaN</span>
<span class="sd">        1  0.0  3.0 1.0</span>
<span class="sd">        2  NaN  3.0 1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other_idxlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>  <span class="c1"># save for compare</span>

        <span class="n">this</span><span class="p">,</span> <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">new_index</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">index</span>

        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">empty</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_index</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">empty</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="n">other_idxlen</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># sorts if possible; otherwise align above ensures that these are set-equal</span>
        <span class="n">new_columns</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">do_fill</span> <span class="o">=</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">new_columns</span><span class="p">:</span>
            <span class="n">series</span> <span class="o">=</span> <span class="n">this</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
            <span class="n">other_series</span> <span class="o">=</span> <span class="n">other</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>

            <span class="n">this_dtype</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">dtype</span>
            <span class="n">other_dtype</span> <span class="o">=</span> <span class="n">other_series</span><span class="o">.</span><span class="n">dtype</span>

            <span class="n">this_mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="n">series</span><span class="p">)</span>
            <span class="n">other_mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="n">other_series</span><span class="p">)</span>

            <span class="c1"># don&#39;t overwrite columns unnecessarily</span>
            <span class="c1"># DO propagate if this column is not in the intersection</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite</span> <span class="ow">and</span> <span class="n">other_mask</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="n">result</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">this</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">do_fill</span><span class="p">:</span>
                <span class="n">series</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">other_series</span> <span class="o">=</span> <span class="n">other_series</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">series</span><span class="p">[</span><span class="n">this_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
                <span class="n">other_series</span><span class="p">[</span><span class="n">other_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>

            <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="c1"># If self DataFrame does not have col in other DataFrame,</span>
                <span class="c1"># try to promote series, which is all NaN, as other_dtype.</span>
                <span class="n">new_dtype</span> <span class="o">=</span> <span class="n">other_dtype</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">series</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">new_dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="c1"># e.g. new_dtype is integer types</span>
                    <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if we have different dtypes, possibly promote</span>
                <span class="n">new_dtype</span> <span class="o">=</span> <span class="n">find_common_type</span><span class="p">([</span><span class="n">this_dtype</span><span class="p">,</span> <span class="n">other_dtype</span><span class="p">])</span>
                <span class="n">series</span> <span class="o">=</span> <span class="n">series</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">new_dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">other_series</span> <span class="o">=</span> <span class="n">other_series</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">new_dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">arr</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">other_series</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="c1"># if new_dtype is an EA Dtype, then `func` is expected to return</span>
                <span class="c1"># the correct dtype without any additional casting</span>
                <span class="c1"># error: No overload variant of &quot;maybe_downcast_to_dtype&quot; matches</span>
                <span class="c1"># argument types &quot;Union[Series, Hashable]&quot;, &quot;dtype[Any]&quot;</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">maybe_downcast_to_dtype</span><span class="p">(</span>  <span class="c1"># type: ignore[call-overload]</span>
                    <span class="n">arr</span><span class="p">,</span> <span class="n">new_dtype</span>
                <span class="p">)</span>

            <span class="n">result</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span>

        <span class="c1"># convert_objects just in case</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">new_index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">new_columns</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">combine_first</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update null elements with value in the same location in `other`.</span>

<span class="sd">        Combine two DataFrame objects by filling null values in one DataFrame</span>
<span class="sd">        with non-null values from other DataFrame. The row and column indexes</span>
<span class="sd">        of the resulting DataFrame will be the union of the two. The resulting</span>
<span class="sd">        dataframe contains the &#39;first&#39; dataframe values and overrides the</span>
<span class="sd">        second one values where both first.loc[index, col] and</span>
<span class="sd">        second.loc[index, col] are not missing values, upon calling</span>
<span class="sd">        first.combine_first(second).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : DataFrame</span>
<span class="sd">            Provided DataFrame to use to fill null values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            The result of combining the provided DataFrame with the other object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.combine : Perform series-wise operation on two DataFrames</span>
<span class="sd">            using a given function.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df1 = pd.DataFrame({&#39;A&#39;: [None, 0], &#39;B&#39;: [None, 4]})</span>
<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame({&#39;A&#39;: [1, 1], &#39;B&#39;: [3, 3]})</span>
<span class="sd">        &gt;&gt;&gt; df1.combine_first(df2)</span>
<span class="sd">             A    B</span>
<span class="sd">        0  1.0  3.0</span>
<span class="sd">        1  0.0  4.0</span>

<span class="sd">        Null values still persist if the location of that null value</span>
<span class="sd">        does not exist in `other`</span>

<span class="sd">        &gt;&gt;&gt; df1 = pd.DataFrame({&#39;A&#39;: [None, 0], &#39;B&#39;: [4, None]})</span>
<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame({&#39;B&#39;: [3, 3], &#39;C&#39;: [1, 1]}, index=[1, 2])</span>
<span class="sd">        &gt;&gt;&gt; df1.combine_first(df2)</span>
<span class="sd">             A    B    C</span>
<span class="sd">        0  NaN  4.0  NaN</span>
<span class="sd">        1  0.0  3.0  1.0</span>
<span class="sd">        2  NaN  3.0  1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.computation</span> <span class="kn">import</span> <span class="n">expressions</span>

        <span class="k">def</span> <span class="nf">combiner</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">extract_array</span><span class="p">(</span><span class="n">isna</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

            <span class="n">x_values</span> <span class="o">=</span> <span class="n">extract_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">extract_numpy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">y_values</span> <span class="o">=</span> <span class="n">extract_array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">extract_numpy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># If the column y in other DataFrame is not in first DataFrame,</span>
            <span class="c1"># just return y_values.</span>
            <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">y_values</span>

            <span class="k">return</span> <span class="n">expressions</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">y_values</span><span class="p">,</span> <span class="n">x_values</span><span class="p">)</span>

        <span class="n">combined</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">combiner</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">dtypes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">col</span><span class="p">:</span> <span class="n">find_common_type</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="n">other</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="n">col</span><span class="p">]])</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dtype_equal</span><span class="p">(</span><span class="n">combined</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">dtypes</span><span class="p">:</span>
            <span class="n">combined</span> <span class="o">=</span> <span class="n">combined</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtypes</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">combined</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">,</span>
        <span class="n">join</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span>
        <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">filter_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">errors</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ignore&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Modify in place using non-NA values from another DataFrame.</span>

<span class="sd">        Aligns on indices. There is no return value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : DataFrame, or object coercible into a DataFrame</span>
<span class="sd">            Should have at least one matching index/column label</span>
<span class="sd">            with the original DataFrame. If a Series is passed,</span>
<span class="sd">            its name attribute must be set, and that will be</span>
<span class="sd">            used as the column name to align with the original DataFrame.</span>
<span class="sd">        join : {&#39;left&#39;}, default &#39;left&#39;</span>
<span class="sd">            Only left join is implemented, keeping the index and columns of the</span>
<span class="sd">            original object.</span>
<span class="sd">        overwrite : bool, default True</span>
<span class="sd">            How to handle non-NA values for overlapping keys:</span>

<span class="sd">            * True: overwrite original DataFrame&#39;s values</span>
<span class="sd">              with values from `other`.</span>
<span class="sd">            * False: only update values that are NA in</span>
<span class="sd">              the original DataFrame.</span>

<span class="sd">        filter_func : callable(1d-array) -&gt; bool 1d-array, optional</span>
<span class="sd">            Can choose to replace values other than NA. Return True for values</span>
<span class="sd">            that should be updated.</span>
<span class="sd">        errors : {&#39;raise&#39;, &#39;ignore&#39;}, default &#39;ignore&#39;</span>
<span class="sd">            If &#39;raise&#39;, will raise a ValueError if the DataFrame and `other`</span>
<span class="sd">            both contain non-NA data in the same place.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">            This method directly changes calling object.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            * When `errors=&#39;raise&#39;` and there&#39;s overlapping non-NA data.</span>
<span class="sd">            * When `errors` is not either `&#39;ignore&#39;` or `&#39;raise&#39;`</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            * If `join != &#39;left&#39;`</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dict.update : Similar method for dictionaries.</span>
<span class="sd">        DataFrame.merge : For column(s)-on-column(s) operations.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [1, 2, 3],</span>
<span class="sd">        ...                    &#39;B&#39;: [400, 500, 600]})</span>
<span class="sd">        &gt;&gt;&gt; new_df = pd.DataFrame({&#39;B&#39;: [4, 5, 6],</span>
<span class="sd">        ...                        &#39;C&#39;: [7, 8, 9]})</span>
<span class="sd">        &gt;&gt;&gt; df.update(new_df)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A  B</span>
<span class="sd">        0  1  4</span>
<span class="sd">        1  2  5</span>
<span class="sd">        2  3  6</span>

<span class="sd">        The DataFrame&#39;s length does not increase as a result of the update,</span>
<span class="sd">        only values at matching index/column labels are updated.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],</span>
<span class="sd">        ...                    &#39;B&#39;: [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]})</span>
<span class="sd">        &gt;&gt;&gt; new_df = pd.DataFrame({&#39;B&#39;: [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;]})</span>
<span class="sd">        &gt;&gt;&gt; df.update(new_df)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A  B</span>
<span class="sd">        0  a  d</span>
<span class="sd">        1  b  e</span>
<span class="sd">        2  c  f</span>

<span class="sd">        For Series, its name attribute must be set.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],</span>
<span class="sd">        ...                    &#39;B&#39;: [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]})</span>
<span class="sd">        &gt;&gt;&gt; new_column = pd.Series([&#39;d&#39;, &#39;e&#39;], name=&#39;B&#39;, index=[0, 2])</span>
<span class="sd">        &gt;&gt;&gt; df.update(new_column)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A  B</span>
<span class="sd">        0  a  d</span>
<span class="sd">        1  b  y</span>
<span class="sd">        2  c  e</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],</span>
<span class="sd">        ...                    &#39;B&#39;: [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]})</span>
<span class="sd">        &gt;&gt;&gt; new_df = pd.DataFrame({&#39;B&#39;: [&#39;d&#39;, &#39;e&#39;]}, index=[1, 2])</span>
<span class="sd">        &gt;&gt;&gt; df.update(new_df)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A  B</span>
<span class="sd">        0  a  x</span>
<span class="sd">        1  b  d</span>
<span class="sd">        2  c  e</span>

<span class="sd">        If `other` contains NaNs the corresponding values are not updated</span>
<span class="sd">        in the original dataframe.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [1, 2, 3],</span>
<span class="sd">        ...                    &#39;B&#39;: [400, 500, 600]})</span>
<span class="sd">        &gt;&gt;&gt; new_df = pd.DataFrame({&#39;B&#39;: [4, np.nan, 6]})</span>
<span class="sd">        &gt;&gt;&gt; df.update(new_df)</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A    B</span>
<span class="sd">        0  1    4</span>
<span class="sd">        1  2  500</span>
<span class="sd">        2  3    6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.computation</span> <span class="kn">import</span> <span class="n">expressions</span>

        <span class="c1"># TODO: Support other joins</span>
        <span class="k">if</span> <span class="n">join</span> <span class="o">!=</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Only left join is supported&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">errors</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="s2">&quot;raise&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The parameter errors must be either &#39;ignore&#39; or &#39;raise&#39;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">_values</span>
            <span class="n">that</span> <span class="o">=</span> <span class="n">other</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">_values</span>

            <span class="k">if</span> <span class="n">filter_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">):</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">filter_func</span><span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="o">|</span> <span class="n">isna</span><span class="p">(</span><span class="n">that</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">errors</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
                    <span class="n">mask_this</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">that</span><span class="p">)</span>
                    <span class="n">mask_that</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">mask_this</span> <span class="o">&amp;</span> <span class="n">mask_that</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data overlaps.&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">isna</span><span class="p">(</span><span class="n">that</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">this</span><span class="p">)</span>

            <span class="c1"># don&#39;t overwrite columns unnecessarily</span>
            <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                <span class="k">continue</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">expressions</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">that</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Data reshaping</span>
    <span class="nd">@Appender</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Examples</span>
<span class="sd">--------</span>
<span class="sd">&gt;&gt;&gt; df = pd.DataFrame({&#39;Animal&#39;: [&#39;Falcon&#39;, &#39;Falcon&#39;,</span>
<span class="sd">...                               &#39;Parrot&#39;, &#39;Parrot&#39;],</span>
<span class="sd">...                    &#39;Max Speed&#39;: [380., 370., 24., 26.]})</span>
<span class="sd">&gt;&gt;&gt; df</span>
<span class="sd">   Animal  Max Speed</span>
<span class="sd">0  Falcon      380.0</span>
<span class="sd">1  Falcon      370.0</span>
<span class="sd">2  Parrot       24.0</span>
<span class="sd">3  Parrot       26.0</span>
<span class="sd">&gt;&gt;&gt; df.groupby([&#39;Animal&#39;]).mean()</span>
<span class="sd">        Max Speed</span>
<span class="sd">Animal</span>
<span class="sd">Falcon      375.0</span>
<span class="sd">Parrot       25.0</span>

<span class="sd">**Hierarchical Indexes**</span>

<span class="sd">We can groupby different levels of a hierarchical index</span>
<span class="sd">using the `level` parameter:</span>

<span class="sd">&gt;&gt;&gt; arrays = [[&#39;Falcon&#39;, &#39;Falcon&#39;, &#39;Parrot&#39;, &#39;Parrot&#39;],</span>
<span class="sd">...           [&#39;Captive&#39;, &#39;Wild&#39;, &#39;Captive&#39;, &#39;Wild&#39;]]</span>
<span class="sd">&gt;&gt;&gt; index = pd.MultiIndex.from_arrays(arrays, names=(&#39;Animal&#39;, &#39;Type&#39;))</span>
<span class="sd">&gt;&gt;&gt; df = pd.DataFrame({&#39;Max Speed&#39;: [390., 350., 30., 20.]},</span>
<span class="sd">...                   index=index)</span>
<span class="sd">&gt;&gt;&gt; df</span>
<span class="sd">                Max Speed</span>
<span class="sd">Animal Type</span>
<span class="sd">Falcon Captive      390.0</span>
<span class="sd">       Wild         350.0</span>
<span class="sd">Parrot Captive       30.0</span>
<span class="sd">       Wild          20.0</span>
<span class="sd">&gt;&gt;&gt; df.groupby(level=0).mean()</span>
<span class="sd">        Max Speed</span>
<span class="sd">Animal</span>
<span class="sd">Falcon      370.0</span>
<span class="sd">Parrot       25.0</span>
<span class="sd">&gt;&gt;&gt; df.groupby(level=&quot;Type&quot;).mean()</span>
<span class="sd">         Max Speed</span>
<span class="sd">Type</span>
<span class="sd">Captive      210.0</span>
<span class="sd">Wild         185.0</span>

<span class="sd">We can also choose to include NA in group keys or not by setting</span>
<span class="sd">`dropna` parameter, the default setting is `True`.</span>

<span class="sd">&gt;&gt;&gt; l = [[1, 2, 3], [1, None, 4], [2, 1, 3], [1, 2, 2]]</span>
<span class="sd">&gt;&gt;&gt; df = pd.DataFrame(l, columns=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])</span>

<span class="sd">&gt;&gt;&gt; df.groupby(by=[&quot;b&quot;]).sum()</span>
<span class="sd">    a   c</span>
<span class="sd">b</span>
<span class="sd">1.0 2   3</span>
<span class="sd">2.0 2   5</span>

<span class="sd">&gt;&gt;&gt; df.groupby(by=[&quot;b&quot;], dropna=False).sum()</span>
<span class="sd">    a   c</span>
<span class="sd">b</span>
<span class="sd">1.0 2   3</span>
<span class="sd">2.0 2   5</span>
<span class="sd">NaN 1   4</span>

<span class="sd">&gt;&gt;&gt; l = [[&quot;a&quot;, 12, 12], [None, 12.3, 33.], [&quot;b&quot;, 12.3, 123], [&quot;a&quot;, 1, 1]]</span>
<span class="sd">&gt;&gt;&gt; df = pd.DataFrame(l, columns=[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])</span>

<span class="sd">&gt;&gt;&gt; df.groupby(by=&quot;a&quot;).sum()</span>
<span class="sd">    b     c</span>
<span class="sd">a</span>
<span class="sd">a   13.0   13.0</span>
<span class="sd">b   12.3  123.0</span>

<span class="sd">&gt;&gt;&gt; df.groupby(by=&quot;a&quot;, dropna=False).sum()</span>
<span class="sd">    b     c</span>
<span class="sd">a</span>
<span class="sd">a   13.0   13.0</span>
<span class="sd">b   12.3  123.0</span>
<span class="sd">NaN 12.3   33.0</span>

<span class="sd">When using ``.apply()``, use ``group_keys`` to include or exclude the group keys.</span>
<span class="sd">The ``group_keys`` argument defaults to ``True`` (include).</span>

<span class="sd">&gt;&gt;&gt; df = pd.DataFrame({&#39;Animal&#39;: [&#39;Falcon&#39;, &#39;Falcon&#39;,</span>
<span class="sd">...                               &#39;Parrot&#39;, &#39;Parrot&#39;],</span>
<span class="sd">...                    &#39;Max Speed&#39;: [380., 370., 24., 26.]})</span>
<span class="sd">&gt;&gt;&gt; df.groupby(&quot;Animal&quot;, group_keys=True).apply(lambda x: x)</span>
<span class="sd">          Animal  Max Speed</span>
<span class="sd">Animal</span>
<span class="sd">Falcon 0  Falcon      380.0</span>
<span class="sd">       1  Falcon      370.0</span>
<span class="sd">Parrot 2  Parrot       24.0</span>
<span class="sd">       3  Parrot       26.0</span>

<span class="sd">&gt;&gt;&gt; df.groupby(&quot;Animal&quot;, group_keys=False).apply(lambda x: x)</span>
<span class="sd">   Animal  Max Speed</span>
<span class="sd">0  Falcon      380.0</span>
<span class="sd">1  Falcon      370.0</span>
<span class="sd">2  Parrot       24.0</span>
<span class="sd">3  Parrot       26.0</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;groupby&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">groupby</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">by</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">as_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">sort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">group_keys</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">observed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dropna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrameGroupBy</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pandas.core.groupby.generic</span> <span class="kn">import</span> <span class="n">DataFrameGroupBy</span>

        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">by</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;You have to supply one of &#39;by&#39; and &#39;level&#39;&quot;</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">DataFrameGroupBy</span><span class="p">(</span>
            <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">keys</span><span class="o">=</span><span class="n">by</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
            <span class="n">as_index</span><span class="o">=</span><span class="n">as_index</span><span class="p">,</span>
            <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span>
            <span class="n">group_keys</span><span class="o">=</span><span class="n">group_keys</span><span class="p">,</span>
            <span class="n">observed</span><span class="o">=</span><span class="n">observed</span><span class="p">,</span>
            <span class="n">dropna</span><span class="o">=</span><span class="n">dropna</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;pivot&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Return reshaped DataFrame organized by given index / column values.</span>

<span class="s2">        Reshape data (produce a &quot;pivot&quot; table) based on column values. Uses</span>
<span class="s2">        unique values from specified `index` / `columns` to form axes of the</span>
<span class="s2">        resulting DataFrame. This function does not support data</span>
<span class="s2">        aggregation, multiple values will result in a MultiIndex in the</span>
<span class="s2">        columns. See the :ref:`User Guide &lt;reshaping&gt;` for more on reshaping.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span><span class="si">%s</span>
<span class="s2">        columns : str or object or a list of str</span>
<span class="s2">            Column to use to make new frame&#39;s columns.</span>

<span class="s2">            .. versionchanged:: 1.1.0</span>
<span class="s2">               Also accept list of columns names.</span>

<span class="s2">        index : str or object or a list of str, optional</span>
<span class="s2">            Column to use to make new frame&#39;s index. If not given, uses existing index.</span>

<span class="s2">            .. versionchanged:: 1.1.0</span>
<span class="s2">               Also accept list of index names.</span>

<span class="s2">        values : str, object or a list of the previous, optional</span>
<span class="s2">            Column(s) to use for populating new frame&#39;s values. If not</span>
<span class="s2">            specified, all remaining columns will be used and the result will</span>
<span class="s2">            have hierarchically indexed columns.</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        DataFrame</span>
<span class="s2">            Returns reshaped DataFrame.</span>

<span class="s2">        Raises</span>
<span class="s2">        ------</span>
<span class="s2">        ValueError:</span>
<span class="s2">            When there are any `index`, `columns` combinations with multiple</span>
<span class="s2">            values. `DataFrame.pivot_table` when you need to aggregate.</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        DataFrame.pivot_table : Generalization of pivot that can handle</span>
<span class="s2">            duplicate values for one index/column pair.</span>
<span class="s2">        DataFrame.unstack : Pivot based on the index values instead of a</span>
<span class="s2">            column.</span>
<span class="s2">        wide_to_long : Wide panel to long format. Less flexible but more</span>
<span class="s2">            user-friendly than melt.</span>

<span class="s2">        Notes</span>
<span class="s2">        -----</span>
<span class="s2">        For finer-tuned control, see hierarchical indexing documentation along</span>
<span class="s2">        with the related stack/unstack methods.</span>

<span class="s2">        Reference :ref:`the user guide &lt;reshaping.pivot&gt;` for more examples.</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>
<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame({&#39;foo&#39;: [&#39;one&#39;, &#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;two&#39;,</span>
<span class="s2">        ...                            &#39;two&#39;],</span>
<span class="s2">        ...                    &#39;bar&#39;: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;],</span>
<span class="s2">        ...                    &#39;baz&#39;: [1, 2, 3, 4, 5, 6],</span>
<span class="s2">        ...                    &#39;zoo&#39;: [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;q&#39;, &#39;w&#39;, &#39;t&#39;]})</span>
<span class="s2">        &gt;&gt;&gt; df</span>
<span class="s2">            foo   bar  baz  zoo</span>
<span class="s2">        0   one   A    1    x</span>
<span class="s2">        1   one   B    2    y</span>
<span class="s2">        2   one   C    3    z</span>
<span class="s2">        3   two   A    4    q</span>
<span class="s2">        4   two   B    5    w</span>
<span class="s2">        5   two   C    6    t</span>

<span class="s2">        &gt;&gt;&gt; df.pivot(index=&#39;foo&#39;, columns=&#39;bar&#39;, values=&#39;baz&#39;)</span>
<span class="s2">        bar  A   B   C</span>
<span class="s2">        foo</span>
<span class="s2">        one  1   2   3</span>
<span class="s2">        two  4   5   6</span>

<span class="s2">        &gt;&gt;&gt; df.pivot(index=&#39;foo&#39;, columns=&#39;bar&#39;)[&#39;baz&#39;]</span>
<span class="s2">        bar  A   B   C</span>
<span class="s2">        foo</span>
<span class="s2">        one  1   2   3</span>
<span class="s2">        two  4   5   6</span>

<span class="s2">        &gt;&gt;&gt; df.pivot(index=&#39;foo&#39;, columns=&#39;bar&#39;, values=[&#39;baz&#39;, &#39;zoo&#39;])</span>
<span class="s2">              baz       zoo</span>
<span class="s2">        bar   A  B  C   A  B  C</span>
<span class="s2">        foo</span>
<span class="s2">        one   1  2  3   x  y  z</span>
<span class="s2">        two   4  5  6   q  w  t</span>

<span class="s2">        You could also assign a list of column names or a list of index names.</span>

<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame({</span>
<span class="s2">        ...        &quot;lev1&quot;: [1, 1, 1, 2, 2, 2],</span>
<span class="s2">        ...        &quot;lev2&quot;: [1, 1, 2, 1, 1, 2],</span>
<span class="s2">        ...        &quot;lev3&quot;: [1, 2, 1, 2, 1, 2],</span>
<span class="s2">        ...        &quot;lev4&quot;: [1, 2, 3, 4, 5, 6],</span>
<span class="s2">        ...        &quot;values&quot;: [0, 1, 2, 3, 4, 5]})</span>
<span class="s2">        &gt;&gt;&gt; df</span>
<span class="s2">            lev1 lev2 lev3 lev4 values</span>
<span class="s2">        0   1    1    1    1    0</span>
<span class="s2">        1   1    1    2    2    1</span>
<span class="s2">        2   1    2    1    3    2</span>
<span class="s2">        3   2    1    2    4    3</span>
<span class="s2">        4   2    1    1    5    4</span>
<span class="s2">        5   2    2    2    6    5</span>

<span class="s2">        &gt;&gt;&gt; df.pivot(index=&quot;lev1&quot;, columns=[&quot;lev2&quot;, &quot;lev3&quot;], values=&quot;values&quot;)</span>
<span class="s2">        lev2    1         2</span>
<span class="s2">        lev3    1    2    1    2</span>
<span class="s2">        lev1</span>
<span class="s2">        1     0.0  1.0  2.0  NaN</span>
<span class="s2">        2     4.0  3.0  NaN  5.0</span>

<span class="s2">        &gt;&gt;&gt; df.pivot(index=[&quot;lev1&quot;, &quot;lev2&quot;], columns=[&quot;lev3&quot;], values=&quot;values&quot;)</span>
<span class="s2">              lev3    1    2</span>
<span class="s2">        lev1  lev2</span>
<span class="s2">           1     1  0.0  1.0</span>
<span class="s2">                 2  2.0  NaN</span>
<span class="s2">           2     1  4.0  3.0</span>
<span class="s2">                 2  NaN  5.0</span>

<span class="s2">        A ValueError is raised if there are any duplicates.</span>

<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame({&quot;foo&quot;: [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;two&#39;],</span>
<span class="s2">        ...                    &quot;bar&quot;: [&#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;],</span>
<span class="s2">        ...                    &quot;baz&quot;: [1, 2, 3, 4]})</span>
<span class="s2">        &gt;&gt;&gt; df</span>
<span class="s2">           foo bar  baz</span>
<span class="s2">        0  one   A    1</span>
<span class="s2">        1  one   A    2</span>
<span class="s2">        2  two   B    3</span>
<span class="s2">        3  two   C    4</span>

<span class="s2">        Notice that the first two rows are the same for our `index`</span>
<span class="s2">        and `columns` arguments.</span>

<span class="s2">        &gt;&gt;&gt; df.pivot(index=&#39;foo&#39;, columns=&#39;bar&#39;, values=&#39;baz&#39;)</span>
<span class="s2">        Traceback (most recent call last):</span>
<span class="s2">           ...</span>
<span class="s2">        ValueError: Index contains duplicate entries, cannot reshape</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Substitution</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;pivot&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">pivot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">lib</span><span class="o">.</span><span class="n">NoDefault</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">lib</span><span class="o">.</span><span class="n">NoDefault</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.pivot</span> <span class="kn">import</span> <span class="n">pivot</span>

        <span class="k">return</span> <span class="n">pivot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">)</span>

    <span class="n">_shared_docs</span><span class="p">[</span>
        <span class="s2">&quot;pivot_table&quot;</span>
    <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Create a spreadsheet-style pivot table as a DataFrame.</span>

<span class="s2">        The levels in the pivot table will be stored in MultiIndex objects</span>
<span class="s2">        (hierarchical indexes) on the index and columns of the result DataFrame.</span>

<span class="s2">        Parameters</span>
<span class="s2">        ----------</span><span class="si">%s</span>
<span class="s2">        values : list-like or scalar, optional</span>
<span class="s2">            Column or columns to aggregate.</span>
<span class="s2">        index : column, Grouper, array, or list of the previous</span>
<span class="s2">            If an array is passed, it must be the same length as the data. The</span>
<span class="s2">            list can contain any of the other types (except list).</span>
<span class="s2">            Keys to group by on the pivot table index.  If an array is passed,</span>
<span class="s2">            it is being used as the same manner as column values.</span>
<span class="s2">        columns : column, Grouper, array, or list of the previous</span>
<span class="s2">            If an array is passed, it must be the same length as the data. The</span>
<span class="s2">            list can contain any of the other types (except list).</span>
<span class="s2">            Keys to group by on the pivot table column.  If an array is passed,</span>
<span class="s2">            it is being used as the same manner as column values.</span>
<span class="s2">        aggfunc : function, list of functions, dict, default numpy.mean</span>
<span class="s2">            If list of functions passed, the resulting pivot table will have</span>
<span class="s2">            hierarchical columns whose top level are the function names</span>
<span class="s2">            (inferred from the function objects themselves)</span>
<span class="s2">            If dict is passed, the key is column to aggregate and value</span>
<span class="s2">            is function or list of functions. If ``margin=True``,</span>
<span class="s2">            aggfunc will be used to calculate the partial aggregates.</span>
<span class="s2">        fill_value : scalar, default None</span>
<span class="s2">            Value to replace missing values with (in the resulting pivot table,</span>
<span class="s2">            after aggregation).</span>
<span class="s2">        margins : bool, default False</span>
<span class="s2">            If ``margins=True``, special ``All`` columns and rows</span>
<span class="s2">            will be added with partial group aggregates across the categories</span>
<span class="s2">            on the rows and columns.</span>
<span class="s2">        dropna : bool, default True</span>
<span class="s2">            Do not include columns whose entries are all NaN. If True,</span>
<span class="s2">            rows with a NaN value in any column will be omitted before</span>
<span class="s2">            computing margins.</span>
<span class="s2">        margins_name : str, default &#39;All&#39;</span>
<span class="s2">            Name of the row / column that will contain the totals</span>
<span class="s2">            when margins is True.</span>
<span class="s2">        observed : bool, default False</span>
<span class="s2">            This only applies if any of the groupers are Categoricals.</span>
<span class="s2">            If True: only show observed values for categorical groupers.</span>
<span class="s2">            If False: show all values for categorical groupers.</span>

<span class="s2">        sort : bool, default True</span>
<span class="s2">            Specifies if the result should be sorted.</span>

<span class="s2">            .. versionadded:: 1.3.0</span>

<span class="s2">        Returns</span>
<span class="s2">        -------</span>
<span class="s2">        DataFrame</span>
<span class="s2">            An Excel style pivot table.</span>

<span class="s2">        See Also</span>
<span class="s2">        --------</span>
<span class="s2">        DataFrame.pivot : Pivot without aggregation that can handle</span>
<span class="s2">            non-numeric data.</span>
<span class="s2">        DataFrame.melt: Unpivot a DataFrame from wide to long format,</span>
<span class="s2">            optionally leaving identifiers set.</span>
<span class="s2">        wide_to_long : Wide panel to long format. Less flexible but more</span>
<span class="s2">            user-friendly than melt.</span>

<span class="s2">        Notes</span>
<span class="s2">        -----</span>
<span class="s2">        Reference :ref:`the user guide &lt;reshaping.pivot&gt;` for more examples.</span>

<span class="s2">        Examples</span>
<span class="s2">        --------</span>
<span class="s2">        &gt;&gt;&gt; df = pd.DataFrame({&quot;A&quot;: [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;,</span>
<span class="s2">        ...                          &quot;bar&quot;, &quot;bar&quot;, &quot;bar&quot;, &quot;bar&quot;],</span>
<span class="s2">        ...                    &quot;B&quot;: [&quot;one&quot;, &quot;one&quot;, &quot;one&quot;, &quot;two&quot;, &quot;two&quot;,</span>
<span class="s2">        ...                          &quot;one&quot;, &quot;one&quot;, &quot;two&quot;, &quot;two&quot;],</span>
<span class="s2">        ...                    &quot;C&quot;: [&quot;small&quot;, &quot;large&quot;, &quot;large&quot;, &quot;small&quot;,</span>
<span class="s2">        ...                          &quot;small&quot;, &quot;large&quot;, &quot;small&quot;, &quot;small&quot;,</span>
<span class="s2">        ...                          &quot;large&quot;],</span>
<span class="s2">        ...                    &quot;D&quot;: [1, 2, 2, 3, 3, 4, 5, 6, 7],</span>
<span class="s2">        ...                    &quot;E&quot;: [2, 4, 5, 5, 6, 6, 8, 9, 9]})</span>
<span class="s2">        &gt;&gt;&gt; df</span>
<span class="s2">             A    B      C  D  E</span>
<span class="s2">        0  foo  one  small  1  2</span>
<span class="s2">        1  foo  one  large  2  4</span>
<span class="s2">        2  foo  one  large  2  5</span>
<span class="s2">        3  foo  two  small  3  5</span>
<span class="s2">        4  foo  two  small  3  6</span>
<span class="s2">        5  bar  one  large  4  6</span>
<span class="s2">        6  bar  one  small  5  8</span>
<span class="s2">        7  bar  two  small  6  9</span>
<span class="s2">        8  bar  two  large  7  9</span>

<span class="s2">        This first example aggregates values by taking the sum.</span>

<span class="s2">        &gt;&gt;&gt; table = pd.pivot_table(df, values=&#39;D&#39;, index=[&#39;A&#39;, &#39;B&#39;],</span>
<span class="s2">        ...                        columns=[&#39;C&#39;], aggfunc=np.sum)</span>
<span class="s2">        &gt;&gt;&gt; table</span>
<span class="s2">        C        large  small</span>
<span class="s2">        A   B</span>
<span class="s2">        bar one    4.0    5.0</span>
<span class="s2">            two    7.0    6.0</span>
<span class="s2">        foo one    4.0    1.0</span>
<span class="s2">            two    NaN    6.0</span>

<span class="s2">        We can also fill missing values using the `fill_value` parameter.</span>

<span class="s2">        &gt;&gt;&gt; table = pd.pivot_table(df, values=&#39;D&#39;, index=[&#39;A&#39;, &#39;B&#39;],</span>
<span class="s2">        ...                        columns=[&#39;C&#39;], aggfunc=np.sum, fill_value=0)</span>
<span class="s2">        &gt;&gt;&gt; table</span>
<span class="s2">        C        large  small</span>
<span class="s2">        A   B</span>
<span class="s2">        bar one      4      5</span>
<span class="s2">            two      7      6</span>
<span class="s2">        foo one      4      1</span>
<span class="s2">            two      0      6</span>

<span class="s2">        The next example aggregates by taking the mean across multiple columns.</span>

<span class="s2">        &gt;&gt;&gt; table = pd.pivot_table(df, values=[&#39;D&#39;, &#39;E&#39;], index=[&#39;A&#39;, &#39;C&#39;],</span>
<span class="s2">        ...                        aggfunc={&#39;D&#39;: np.mean, &#39;E&#39;: np.mean})</span>
<span class="s2">        &gt;&gt;&gt; table</span>
<span class="s2">                        D         E</span>
<span class="s2">        A   C</span>
<span class="s2">        bar large  5.500000  7.500000</span>
<span class="s2">            small  5.500000  8.500000</span>
<span class="s2">        foo large  2.000000  4.500000</span>
<span class="s2">            small  2.333333  4.333333</span>

<span class="s2">        We can also calculate multiple types of aggregations for any given</span>
<span class="s2">        value column.</span>

<span class="s2">        &gt;&gt;&gt; table = pd.pivot_table(df, values=[&#39;D&#39;, &#39;E&#39;], index=[&#39;A&#39;, &#39;C&#39;],</span>
<span class="s2">        ...                        aggfunc={&#39;D&#39;: np.mean,</span>
<span class="s2">        ...                                 &#39;E&#39;: [min, max, np.mean]})</span>
<span class="s2">        &gt;&gt;&gt; table</span>
<span class="s2">                          D   E</span>
<span class="s2">                       mean max      mean  min</span>
<span class="s2">        A   C</span>
<span class="s2">        bar large  5.500000   9  7.500000    6</span>
<span class="s2">            small  5.500000   9  8.500000    8</span>
<span class="s2">        foo large  2.000000   5  4.500000    4</span>
<span class="s2">            small  2.333333   6  4.333333    2</span>
<span class="s2">        &quot;&quot;&quot;</span>

    <span class="nd">@Substitution</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;pivot_table&quot;</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">pivot_table</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">aggfunc</span><span class="p">:</span> <span class="n">AggFuncType</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">margins</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dropna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">margins_name</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="s2">&quot;All&quot;</span><span class="p">,</span>
        <span class="n">observed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">sort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.pivot</span> <span class="kn">import</span> <span class="n">pivot_table</span>

        <span class="k">return</span> <span class="n">pivot_table</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">,</span>
            <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span>
            <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span>
            <span class="n">aggfunc</span><span class="o">=</span><span class="n">aggfunc</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
            <span class="n">margins</span><span class="o">=</span><span class="n">margins</span><span class="p">,</span>
            <span class="n">dropna</span><span class="o">=</span><span class="n">dropna</span><span class="p">,</span>
            <span class="n">margins_name</span><span class="o">=</span><span class="n">margins_name</span><span class="p">,</span>
            <span class="n">observed</span><span class="o">=</span><span class="n">observed</span><span class="p">,</span>
            <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">stack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dropna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stack the prescribed level(s) from columns to index.</span>

<span class="sd">        Return a reshaped DataFrame or Series having a multi-level</span>
<span class="sd">        index with one or more new inner-most levels compared to the current</span>
<span class="sd">        DataFrame. The new inner-most levels are created by pivoting the</span>
<span class="sd">        columns of the current dataframe:</span>

<span class="sd">          - if the columns have a single level, the output is a Series;</span>
<span class="sd">          - if the columns have multiple levels, the new index</span>
<span class="sd">            level(s) is (are) taken from the prescribed level(s) and</span>
<span class="sd">            the output is a DataFrame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int, str, list, default -1</span>
<span class="sd">            Level(s) to stack from the column axis onto the index</span>
<span class="sd">            axis, defined as one index or label, or a list of indices</span>
<span class="sd">            or labels.</span>
<span class="sd">        dropna : bool, default True</span>
<span class="sd">            Whether to drop rows in the resulting Frame/Series with</span>
<span class="sd">            missing values. Stacking a column level onto the index</span>
<span class="sd">            axis can create combinations of index and column values</span>
<span class="sd">            that are missing from the original dataframe. See Examples</span>
<span class="sd">            section.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame or Series</span>
<span class="sd">            Stacked dataframe or series.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.unstack : Unstack prescribed level(s) from index axis</span>
<span class="sd">             onto column axis.</span>
<span class="sd">        DataFrame.pivot : Reshape dataframe from long format to wide</span>
<span class="sd">             format.</span>
<span class="sd">        DataFrame.pivot_table : Create a spreadsheet-style pivot table</span>
<span class="sd">             as a DataFrame.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The function is named by analogy with a collection of books</span>
<span class="sd">        being reorganized from being side by side on a horizontal</span>
<span class="sd">        position (the columns of the dataframe) to being stacked</span>
<span class="sd">        vertically on top of each other (in the index of the</span>
<span class="sd">        dataframe).</span>

<span class="sd">        Reference :ref:`the user guide &lt;reshaping.stacking&gt;` for more examples.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        **Single level columns**</span>

<span class="sd">        &gt;&gt;&gt; df_single_level_cols = pd.DataFrame([[0, 1], [2, 3]],</span>
<span class="sd">        ...                                     index=[&#39;cat&#39;, &#39;dog&#39;],</span>
<span class="sd">        ...                                     columns=[&#39;weight&#39;, &#39;height&#39;])</span>

<span class="sd">        Stacking a dataframe with a single level column axis returns a Series:</span>

<span class="sd">        &gt;&gt;&gt; df_single_level_cols</span>
<span class="sd">             weight height</span>
<span class="sd">        cat       0      1</span>
<span class="sd">        dog       2      3</span>
<span class="sd">        &gt;&gt;&gt; df_single_level_cols.stack()</span>
<span class="sd">        cat  weight    0</span>
<span class="sd">             height    1</span>
<span class="sd">        dog  weight    2</span>
<span class="sd">             height    3</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        **Multi level columns: simple case**</span>

<span class="sd">        &gt;&gt;&gt; multicol1 = pd.MultiIndex.from_tuples([(&#39;weight&#39;, &#39;kg&#39;),</span>
<span class="sd">        ...                                        (&#39;weight&#39;, &#39;pounds&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; df_multi_level_cols1 = pd.DataFrame([[1, 2], [2, 4]],</span>
<span class="sd">        ...                                     index=[&#39;cat&#39;, &#39;dog&#39;],</span>
<span class="sd">        ...                                     columns=multicol1)</span>

<span class="sd">        Stacking a dataframe with a multi-level column axis:</span>

<span class="sd">        &gt;&gt;&gt; df_multi_level_cols1</span>
<span class="sd">             weight</span>
<span class="sd">                 kg    pounds</span>
<span class="sd">        cat       1        2</span>
<span class="sd">        dog       2        4</span>
<span class="sd">        &gt;&gt;&gt; df_multi_level_cols1.stack()</span>
<span class="sd">                    weight</span>
<span class="sd">        cat kg           1</span>
<span class="sd">            pounds       2</span>
<span class="sd">        dog kg           2</span>
<span class="sd">            pounds       4</span>

<span class="sd">        **Missing values**</span>

<span class="sd">        &gt;&gt;&gt; multicol2 = pd.MultiIndex.from_tuples([(&#39;weight&#39;, &#39;kg&#39;),</span>
<span class="sd">        ...                                        (&#39;height&#39;, &#39;m&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; df_multi_level_cols2 = pd.DataFrame([[1.0, 2.0], [3.0, 4.0]],</span>
<span class="sd">        ...                                     index=[&#39;cat&#39;, &#39;dog&#39;],</span>
<span class="sd">        ...                                     columns=multicol2)</span>

<span class="sd">        It is common to have missing values when stacking a dataframe</span>
<span class="sd">        with multi-level columns, as the stacked dataframe typically</span>
<span class="sd">        has more values than the original dataframe. Missing values</span>
<span class="sd">        are filled with NaNs:</span>

<span class="sd">        &gt;&gt;&gt; df_multi_level_cols2</span>
<span class="sd">            weight height</span>
<span class="sd">                kg      m</span>
<span class="sd">        cat    1.0    2.0</span>
<span class="sd">        dog    3.0    4.0</span>
<span class="sd">        &gt;&gt;&gt; df_multi_level_cols2.stack()</span>
<span class="sd">                height  weight</span>
<span class="sd">        cat kg     NaN     1.0</span>
<span class="sd">            m      2.0     NaN</span>
<span class="sd">        dog kg     NaN     3.0</span>
<span class="sd">            m      4.0     NaN</span>

<span class="sd">        **Prescribing the level(s) to be stacked**</span>

<span class="sd">        The first parameter controls which level or levels are stacked:</span>

<span class="sd">        &gt;&gt;&gt; df_multi_level_cols2.stack(0)</span>
<span class="sd">                     kg    m</span>
<span class="sd">        cat height  NaN  2.0</span>
<span class="sd">            weight  1.0  NaN</span>
<span class="sd">        dog height  NaN  4.0</span>
<span class="sd">            weight  3.0  NaN</span>
<span class="sd">        &gt;&gt;&gt; df_multi_level_cols2.stack([0, 1])</span>
<span class="sd">        cat  height  m     2.0</span>
<span class="sd">             weight  kg    1.0</span>
<span class="sd">        dog  height  m     4.0</span>
<span class="sd">             weight  kg    3.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        **Dropping missing values**</span>

<span class="sd">        &gt;&gt;&gt; df_multi_level_cols3 = pd.DataFrame([[None, 1.0], [2.0, 3.0]],</span>
<span class="sd">        ...                                     index=[&#39;cat&#39;, &#39;dog&#39;],</span>
<span class="sd">        ...                                     columns=multicol2)</span>

<span class="sd">        Note that rows where all values are missing are dropped by</span>
<span class="sd">        default but this behaviour can be controlled via the dropna</span>
<span class="sd">        keyword parameter:</span>

<span class="sd">        &gt;&gt;&gt; df_multi_level_cols3</span>
<span class="sd">            weight height</span>
<span class="sd">                kg      m</span>
<span class="sd">        cat    NaN    1.0</span>
<span class="sd">        dog    2.0    3.0</span>
<span class="sd">        &gt;&gt;&gt; df_multi_level_cols3.stack(dropna=False)</span>
<span class="sd">                height  weight</span>
<span class="sd">        cat kg     NaN     NaN</span>
<span class="sd">            m      1.0     NaN</span>
<span class="sd">        dog kg     NaN     2.0</span>
<span class="sd">            m      3.0     NaN</span>
<span class="sd">        &gt;&gt;&gt; df_multi_level_cols3.stack(dropna=True)</span>
<span class="sd">                height  weight</span>
<span class="sd">        cat m      1.0     NaN</span>
<span class="sd">        dog kg     NaN     2.0</span>
<span class="sd">            m      3.0     NaN</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.reshape</span> <span class="kn">import</span> <span class="p">(</span>
            <span class="n">stack</span><span class="p">,</span>
            <span class="n">stack_multiple</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">stack_multiple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">dropna</span><span class="o">=</span><span class="n">dropna</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">stack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">dropna</span><span class="o">=</span><span class="n">dropna</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;stack&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">explode</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">column</span><span class="p">:</span> <span class="n">IndexLabel</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform each element of a list-like to a row, replicating index values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        column : IndexLabel</span>
<span class="sd">            Column(s) to explode.</span>
<span class="sd">            For multiple columns, specify a non-empty list with each element</span>
<span class="sd">            be str or tuple, and all specified columns their list-like data</span>
<span class="sd">            on same row of the frame must have matching length.</span>

<span class="sd">            .. versionadded:: 1.3.0</span>
<span class="sd">                Multi-column explode</span>

<span class="sd">        ignore_index : bool, default False</span>
<span class="sd">            If True, the resulting index will be labeled 0, 1, …, n - 1.</span>

<span class="sd">            .. versionadded:: 1.1.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            Exploded lists to rows of the subset columns;</span>
<span class="sd">            index will be duplicated for these rows.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError :</span>
<span class="sd">            * If columns of the frame are not unique.</span>
<span class="sd">            * If specified columns to explode is empty list.</span>
<span class="sd">            * If specified columns to explode have not matching count of</span>
<span class="sd">              elements rowwise in the frame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.unstack : Pivot a level of the (necessarily hierarchical)</span>
<span class="sd">            index labels.</span>
<span class="sd">        DataFrame.melt : Unpivot a DataFrame from wide format to long format.</span>
<span class="sd">        Series.explode : Explode a DataFrame from list-like columns to long format.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This routine will explode list-likes including lists, tuples, sets,</span>
<span class="sd">        Series, and np.ndarray. The result dtype of the subset rows will</span>
<span class="sd">        be object. Scalars will be returned unchanged, and empty list-likes will</span>
<span class="sd">        result in a np.nan for that row. In addition, the ordering of rows in the</span>
<span class="sd">        output will be non-deterministic when exploding sets.</span>

<span class="sd">        Reference :ref:`the user guide &lt;reshaping.explode&gt;` for more examples.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [[0, 1, 2], &#39;foo&#39;, [], [3, 4]],</span>
<span class="sd">        ...                    &#39;B&#39;: 1,</span>
<span class="sd">        ...                    &#39;C&#39;: [[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], np.nan, [], [&#39;d&#39;, &#39;e&#39;]]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                   A  B          C</span>
<span class="sd">        0  [0, 1, 2]  1  [a, b, c]</span>
<span class="sd">        1        foo  1        NaN</span>
<span class="sd">        2         []  1         []</span>
<span class="sd">        3     [3, 4]  1     [d, e]</span>

<span class="sd">        Single-column explode.</span>

<span class="sd">        &gt;&gt;&gt; df.explode(&#39;A&#39;)</span>
<span class="sd">             A  B          C</span>
<span class="sd">        0    0  1  [a, b, c]</span>
<span class="sd">        0    1  1  [a, b, c]</span>
<span class="sd">        0    2  1  [a, b, c]</span>
<span class="sd">        1  foo  1        NaN</span>
<span class="sd">        2  NaN  1         []</span>
<span class="sd">        3    3  1     [d, e]</span>
<span class="sd">        3    4  1     [d, e]</span>

<span class="sd">        Multi-column explode.</span>

<span class="sd">        &gt;&gt;&gt; df.explode(list(&#39;AC&#39;))</span>
<span class="sd">             A  B    C</span>
<span class="sd">        0    0  1    a</span>
<span class="sd">        0    1  1    b</span>
<span class="sd">        0    2  1    c</span>
<span class="sd">        1  foo  1  NaN</span>
<span class="sd">        2  NaN  1  NaN</span>
<span class="sd">        3    3  1    d</span>
<span class="sd">        3    4  1    e</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="n">duplicate_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">duplicated</span><span class="p">()]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;DataFrame columns must be unique. Duplicate columns: </span><span class="si">{</span><span class="n">duplicate_cols</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">columns</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Hashable</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">(</span><span class="n">column</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">column</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">is_scalar</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">column</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">column</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;column must be nonempty&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">column</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">column</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;column must be unique&quot;</span><span class="p">)</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="n">column</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;column must be a scalar, tuple, or list thereof&quot;</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">explode</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mylen</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_list_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="n">counts0</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">mylen</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">counts0</span> <span class="o">==</span> <span class="bp">self</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">mylen</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;columns must have matching element counts&quot;</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">({</span><span class="n">c</span><span class="p">:</span> <span class="n">df</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">explode</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">})</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ignore_index</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">default_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;explode&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">unstack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pivot a level of the (necessarily hierarchical) index labels.</span>

<span class="sd">        Returns a DataFrame having a new level of column labels whose inner-most level</span>
<span class="sd">        consists of the pivoted index labels.</span>

<span class="sd">        If the index is not a MultiIndex, the output will be a Series</span>
<span class="sd">        (the analogue of stack when the columns are not a MultiIndex).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int, str, or list of these, default -1 (last level)</span>
<span class="sd">            Level(s) of index to unstack, can pass level name.</span>
<span class="sd">        fill_value : int, str or dict</span>
<span class="sd">            Replace NaN with this value if the unstack produces missing values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.pivot : Pivot a table based on column values.</span>
<span class="sd">        DataFrame.stack : Pivot a level of the column labels (inverse operation</span>
<span class="sd">            from `unstack`).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Reference :ref:`the user guide &lt;reshaping.stacking&gt;` for more examples.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; index = pd.MultiIndex.from_tuples([(&#39;one&#39;, &#39;a&#39;), (&#39;one&#39;, &#39;b&#39;),</span>
<span class="sd">        ...                                    (&#39;two&#39;, &#39;a&#39;), (&#39;two&#39;, &#39;b&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; s = pd.Series(np.arange(1.0, 5.0), index=index)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        one  a   1.0</span>
<span class="sd">             b   2.0</span>
<span class="sd">        two  a   3.0</span>
<span class="sd">             b   4.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; s.unstack(level=-1)</span>
<span class="sd">             a   b</span>
<span class="sd">        one  1.0  2.0</span>
<span class="sd">        two  3.0  4.0</span>

<span class="sd">        &gt;&gt;&gt; s.unstack(level=0)</span>
<span class="sd">           one  two</span>
<span class="sd">        a  1.0   3.0</span>
<span class="sd">        b  2.0   4.0</span>

<span class="sd">        &gt;&gt;&gt; df = s.unstack(level=0)</span>
<span class="sd">        &gt;&gt;&gt; df.unstack()</span>
<span class="sd">        one  a  1.0</span>
<span class="sd">             b  2.0</span>
<span class="sd">        two  a  3.0</span>
<span class="sd">             b  4.0</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.reshape</span> <span class="kn">import</span> <span class="n">unstack</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">unstack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;unstack&quot;</span><span class="p">)</span>

    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;melt&quot;</span><span class="p">]</span> <span class="o">%</span> <span class="p">{</span><span class="s2">&quot;caller&quot;</span><span class="p">:</span> <span class="s2">&quot;df.melt(&quot;</span><span class="p">,</span> <span class="s2">&quot;other&quot;</span><span class="p">:</span> <span class="s2">&quot;melt&quot;</span><span class="p">})</span>
    <span class="k">def</span> <span class="nf">melt</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">id_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">value_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">var_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">value_name</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="s2">&quot;value&quot;</span><span class="p">,</span>
        <span class="n">col_level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">melt</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">id_vars</span><span class="o">=</span><span class="n">id_vars</span><span class="p">,</span>
            <span class="n">value_vars</span><span class="o">=</span><span class="n">value_vars</span><span class="p">,</span>
            <span class="n">var_name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span>
            <span class="n">value_name</span><span class="o">=</span><span class="n">value_name</span><span class="p">,</span>
            <span class="n">col_level</span><span class="o">=</span><span class="n">col_level</span><span class="p">,</span>
            <span class="n">ignore_index</span><span class="o">=</span><span class="n">ignore_index</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;melt&quot;</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Time series-related</span>

    <span class="nd">@doc</span><span class="p">(</span>
        <span class="n">Series</span><span class="o">.</span><span class="n">diff</span><span class="p">,</span>
        <span class="n">klass</span><span class="o">=</span><span class="s2">&quot;DataFrame&quot;</span><span class="p">,</span>
        <span class="n">extra_params</span><span class="o">=</span><span class="s2">&quot;axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span><span class="se">\n</span><span class="s2">    &quot;</span>
        <span class="s2">&quot;Take difference over rows (0) or columns (1).</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">other_klass</span><span class="o">=</span><span class="s2">&quot;Series&quot;</span><span class="p">,</span>
        <span class="n">examples</span><span class="o">=</span><span class="n">dedent</span><span class="p">(</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Difference with previous row</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;a&#39;: [1, 2, 3, 4, 5, 6],</span>
<span class="sd">        ...                    &#39;b&#39;: [1, 1, 2, 3, 5, 8],</span>
<span class="sd">        ...                    &#39;c&#39;: [1, 4, 9, 16, 25, 36]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           a  b   c</span>
<span class="sd">        0  1  1   1</span>
<span class="sd">        1  2  1   4</span>
<span class="sd">        2  3  2   9</span>
<span class="sd">        3  4  3  16</span>
<span class="sd">        4  5  5  25</span>
<span class="sd">        5  6  8  36</span>

<span class="sd">        &gt;&gt;&gt; df.diff()</span>
<span class="sd">             a    b     c</span>
<span class="sd">        0  NaN  NaN   NaN</span>
<span class="sd">        1  1.0  0.0   3.0</span>
<span class="sd">        2  1.0  1.0   5.0</span>
<span class="sd">        3  1.0  1.0   7.0</span>
<span class="sd">        4  1.0  2.0   9.0</span>
<span class="sd">        5  1.0  3.0  11.0</span>

<span class="sd">        Difference with previous column</span>

<span class="sd">        &gt;&gt;&gt; df.diff(axis=1)</span>
<span class="sd">            a  b   c</span>
<span class="sd">        0 NaN  0   0</span>
<span class="sd">        1 NaN -1   3</span>
<span class="sd">        2 NaN -1   7</span>
<span class="sd">        3 NaN -1  13</span>
<span class="sd">        4 NaN  0  20</span>
<span class="sd">        5 NaN  2  28</span>

<span class="sd">        Difference with 3rd previous row</span>

<span class="sd">        &gt;&gt;&gt; df.diff(periods=3)</span>
<span class="sd">             a    b     c</span>
<span class="sd">        0  NaN  NaN   NaN</span>
<span class="sd">        1  NaN  NaN   NaN</span>
<span class="sd">        2  NaN  NaN   NaN</span>
<span class="sd">        3  3.0  2.0  15.0</span>
<span class="sd">        4  3.0  4.0  21.0</span>
<span class="sd">        5  3.0  6.0  27.0</span>

<span class="sd">        Difference with following row</span>

<span class="sd">        &gt;&gt;&gt; df.diff(periods=-1)</span>
<span class="sd">             a    b     c</span>
<span class="sd">        0 -1.0  0.0  -3.0</span>
<span class="sd">        1 -1.0 -1.0  -5.0</span>
<span class="sd">        2 -1.0 -1.0  -7.0</span>
<span class="sd">        3 -1.0 -2.0  -9.0</span>
<span class="sd">        4 -1.0 -3.0 -11.0</span>
<span class="sd">        5  NaN  NaN   NaN</span>

<span class="sd">        Overflow in input dtype</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;a&#39;: [1, 0]}, dtype=np.uint8)</span>
<span class="sd">        &gt;&gt;&gt; df.diff()</span>
<span class="sd">               a</span>
<span class="sd">        0    NaN</span>
<span class="sd">        1  255.0&quot;&quot;&quot;</span>
        <span class="p">),</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">periods</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">lib</span><span class="o">.</span><span class="n">is_integer</span><span class="p">(</span><span class="n">periods</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
                <span class="n">is_float</span><span class="p">(</span><span class="n">periods</span><span class="p">)</span>
                <span class="c1"># error: &quot;int&quot; has no attribute &quot;is_integer&quot;</span>
                <span class="ow">and</span> <span class="n">periods</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()</span>  <span class="c1"># type: ignore[attr-defined]</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;periods must be an integer&quot;</span><span class="p">)</span>
            <span class="n">periods</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">periods</span><span class="p">)</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">periods</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># in the periods == 0 case, this is equivalent diff of 0 periods</span>
                <span class="c1">#  along axis=0, and the Manager method may be somewhat more</span>
                <span class="c1">#  performant, so we dispatch in that case.</span>
                <span class="k">return</span> <span class="bp">self</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="c1"># With periods=0 this is equivalent to a diff with axis=0</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">periods</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;diff&quot;</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Function application</span>

    <span class="k">def</span> <span class="nf">_gotitem</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="n">IndexLabel</span><span class="p">,</span>
        <span class="n">ndim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">subset</span><span class="p">:</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Series</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sub-classes to define. Return a sliced object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : string / list of selections</span>
<span class="sd">        ndim : {1, 2}</span>
<span class="sd">            requested ndim of result</span>
<span class="sd">        subset : object, default None</span>
<span class="sd">            subset to act on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">subset</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># is Series</span>
            <span class="k">return</span> <span class="n">subset</span>

        <span class="c1"># TODO: _shallow_copy(subset)?</span>
        <span class="k">return</span> <span class="n">subset</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="n">_agg_summary_and_see_also_doc</span> <span class="o">=</span> <span class="n">dedent</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The aggregation operations are always performed over an axis, either the</span>
<span class="sd">    index (default) or the column axis. This behavior is different from</span>
<span class="sd">    `numpy` aggregation functions (`mean`, `median`, `prod`, `sum`, `std`,</span>
<span class="sd">    `var`), where the default is to compute the aggregation of the flattened</span>
<span class="sd">    array, e.g., ``numpy.mean(arr_2d)`` as opposed to</span>
<span class="sd">    ``numpy.mean(arr_2d, axis=0)``.</span>

<span class="sd">    `agg` is an alias for `aggregate`. Use the alias.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    DataFrame.apply : Perform any type of operations.</span>
<span class="sd">    DataFrame.transform : Perform transformation type operations.</span>
<span class="sd">    core.groupby.GroupBy : Perform operations over groups.</span>
<span class="sd">    core.resample.Resampler : Perform operations over resampled bins.</span>
<span class="sd">    core.window.Rolling : Perform operations over rolling window.</span>
<span class="sd">    core.window.Expanding : Perform operations over expanding window.</span>
<span class="sd">    core.window.ExponentialMovingWindow : Perform operation over exponential weighted</span>
<span class="sd">        window.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">)</span>

    <span class="n">_agg_examples_doc</span> <span class="o">=</span> <span class="n">dedent</span><span class="p">(</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; df = pd.DataFrame([[1, 2, 3],</span>
<span class="sd">    ...                    [4, 5, 6],</span>
<span class="sd">    ...                    [7, 8, 9],</span>
<span class="sd">    ...                    [np.nan, np.nan, np.nan]],</span>
<span class="sd">    ...                   columns=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;])</span>

<span class="sd">    Aggregate these functions over the rows.</span>

<span class="sd">    &gt;&gt;&gt; df.agg([&#39;sum&#39;, &#39;min&#39;])</span>
<span class="sd">            A     B     C</span>
<span class="sd">    sum  12.0  15.0  18.0</span>
<span class="sd">    min   1.0   2.0   3.0</span>

<span class="sd">    Different aggregations per column.</span>

<span class="sd">    &gt;&gt;&gt; df.agg({&#39;A&#39; : [&#39;sum&#39;, &#39;min&#39;], &#39;B&#39; : [&#39;min&#39;, &#39;max&#39;]})</span>
<span class="sd">            A    B</span>
<span class="sd">    sum  12.0  NaN</span>
<span class="sd">    min   1.0  2.0</span>
<span class="sd">    max   NaN  8.0</span>

<span class="sd">    Aggregate different functions over the columns and rename the index of the resulting</span>
<span class="sd">    DataFrame.</span>

<span class="sd">    &gt;&gt;&gt; df.agg(x=(&#39;A&#39;, max), y=(&#39;B&#39;, &#39;min&#39;), z=(&#39;C&#39;, np.mean))</span>
<span class="sd">         A    B    C</span>
<span class="sd">    x  7.0  NaN  NaN</span>
<span class="sd">    y  NaN  2.0  NaN</span>
<span class="sd">    z  NaN  NaN  6.0</span>

<span class="sd">    Aggregate over the columns.</span>

<span class="sd">    &gt;&gt;&gt; df.agg(&quot;mean&quot;, axis=&quot;columns&quot;)</span>
<span class="sd">    0    2.0</span>
<span class="sd">    1    5.0</span>
<span class="sd">    2    8.0</span>
<span class="sd">    3    NaN</span>
<span class="sd">    dtype: float64</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span>
        <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;aggregate&quot;</span><span class="p">],</span>
        <span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">],</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">],</span>
        <span class="n">see_also</span><span class="o">=</span><span class="n">_agg_summary_and_see_also_doc</span><span class="p">,</span>
        <span class="n">examples</span><span class="o">=</span><span class="n">_agg_examples_doc</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">aggregate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pandas.core.apply</span> <span class="kn">import</span> <span class="n">frame_apply</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="n">relabeling</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">order</span> <span class="o">=</span> <span class="n">reconstruct_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">op</span> <span class="o">=</span> <span class="n">frame_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">agg</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">relabeling</span><span class="p">:</span>
            <span class="c1"># This is to keep the order to columns occurrence unchanged, and also</span>
            <span class="c1"># keep the order of new columns occurrence unchanged</span>

            <span class="c1"># For the return values of reconstruct_func, if relabeling is</span>
            <span class="c1"># False, columns and order will be None.</span>
            <span class="k">assert</span> <span class="n">columns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">assert</span> <span class="n">order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

            <span class="n">result_in_dict</span> <span class="o">=</span> <span class="n">relabel_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">result_in_dict</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="n">agg</span> <span class="o">=</span> <span class="n">aggregate</span>

    <span class="c1"># error: Signature of &quot;any&quot; incompatible with supertype &quot;NDFrame&quot;  [override]</span>
    <span class="nd">@overload</span>  <span class="c1"># type: ignore[override]</span>
    <span class="k">def</span> <span class="nf">any</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">bool_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">any</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">bool_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Series</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="c1"># error: Missing return statement</span>
    <span class="nd">@doc</span><span class="p">(</span><span class="n">NDFrame</span><span class="o">.</span><span class="n">any</span><span class="p">,</span> <span class="o">**</span><span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">any</span><span class="p">(</span>  <span class="c1"># type: ignore[empty-body]</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">bool_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Series</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@doc</span><span class="p">(</span>
        <span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;transform&quot;</span><span class="p">],</span>
        <span class="n">klass</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;klass&quot;</span><span class="p">],</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">_shared_doc_kwargs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">AggFuncType</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pandas.core.apply</span> <span class="kn">import</span> <span class="n">frame_apply</span>

        <span class="n">op</span> <span class="o">=</span> <span class="n">frame_apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">transform</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">func</span><span class="p">:</span> <span class="n">AggFuncType</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">raw</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">result_type</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;expand&quot;</span><span class="p">,</span> <span class="s2">&quot;reduce&quot;</span><span class="p">,</span> <span class="s2">&quot;broadcast&quot;</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">args</span><span class="o">=</span><span class="p">(),</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a function along an axis of the DataFrame.</span>

<span class="sd">        Objects passed to the function are Series objects whose index is</span>
<span class="sd">        either the DataFrame&#39;s index (``axis=0``) or the DataFrame&#39;s columns</span>
<span class="sd">        (``axis=1``). By default (``result_type=None``), the final return type</span>
<span class="sd">        is inferred from the return type of the applied function. Otherwise,</span>
<span class="sd">        it depends on the `result_type` argument.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : function</span>
<span class="sd">            Function to apply to each column or row.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            Axis along which the function is applied:</span>

<span class="sd">            * 0 or &#39;index&#39;: apply function to each column.</span>
<span class="sd">            * 1 or &#39;columns&#39;: apply function to each row.</span>

<span class="sd">        raw : bool, default False</span>
<span class="sd">            Determines if row or column is passed as a Series or ndarray object:</span>

<span class="sd">            * ``False`` : passes each row or column as a Series to the</span>
<span class="sd">              function.</span>
<span class="sd">            * ``True`` : the passed function will receive ndarray objects</span>
<span class="sd">              instead.</span>
<span class="sd">              If you are just applying a NumPy reduction function this will</span>
<span class="sd">              achieve much better performance.</span>

<span class="sd">        result_type : {&#39;expand&#39;, &#39;reduce&#39;, &#39;broadcast&#39;, None}, default None</span>
<span class="sd">            These only act when ``axis=1`` (columns):</span>

<span class="sd">            * &#39;expand&#39; : list-like results will be turned into columns.</span>
<span class="sd">            * &#39;reduce&#39; : returns a Series if possible rather than expanding</span>
<span class="sd">              list-like results. This is the opposite of &#39;expand&#39;.</span>
<span class="sd">            * &#39;broadcast&#39; : results will be broadcast to the original shape</span>
<span class="sd">              of the DataFrame, the original index and columns will be</span>
<span class="sd">              retained.</span>

<span class="sd">            The default behaviour (None) depends on the return value of the</span>
<span class="sd">            applied function: list-like results will be returned as a Series</span>
<span class="sd">            of those. However if the apply function returns a Series these</span>
<span class="sd">            are expanded to columns.</span>
<span class="sd">        args : tuple</span>
<span class="sd">            Positional arguments to pass to `func` in addition to the</span>
<span class="sd">            array/series.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass as keywords arguments to</span>
<span class="sd">            `func`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Result of applying ``func`` along the given axis of the</span>
<span class="sd">            DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.applymap: For elementwise operations.</span>
<span class="sd">        DataFrame.aggregate: Only perform aggregating type operations.</span>
<span class="sd">        DataFrame.transform: Only perform transforming type operations.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Functions that mutate the passed object can produce unexpected</span>
<span class="sd">        behavior or errors and are not supported. See :ref:`gotchas.udf-mutation`</span>
<span class="sd">        for more details.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([[4, 9]] * 3, columns=[&#39;A&#39;, &#39;B&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A  B</span>
<span class="sd">        0  4  9</span>
<span class="sd">        1  4  9</span>
<span class="sd">        2  4  9</span>

<span class="sd">        Using a numpy universal function (in this case the same as</span>
<span class="sd">        ``np.sqrt(df)``):</span>

<span class="sd">        &gt;&gt;&gt; df.apply(np.sqrt)</span>
<span class="sd">             A    B</span>
<span class="sd">        0  2.0  3.0</span>
<span class="sd">        1  2.0  3.0</span>
<span class="sd">        2  2.0  3.0</span>

<span class="sd">        Using a reducing function on either axis</span>

<span class="sd">        &gt;&gt;&gt; df.apply(np.sum, axis=0)</span>
<span class="sd">        A    12</span>
<span class="sd">        B    27</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; df.apply(np.sum, axis=1)</span>
<span class="sd">        0    13</span>
<span class="sd">        1    13</span>
<span class="sd">        2    13</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Returning a list-like will result in a Series</span>

<span class="sd">        &gt;&gt;&gt; df.apply(lambda x: [1, 2], axis=1)</span>
<span class="sd">        0    [1, 2]</span>
<span class="sd">        1    [1, 2]</span>
<span class="sd">        2    [1, 2]</span>
<span class="sd">        dtype: object</span>

<span class="sd">        Passing ``result_type=&#39;expand&#39;`` will expand list-like results</span>
<span class="sd">        to columns of a Dataframe</span>

<span class="sd">        &gt;&gt;&gt; df.apply(lambda x: [1, 2], axis=1, result_type=&#39;expand&#39;)</span>
<span class="sd">           0  1</span>
<span class="sd">        0  1  2</span>
<span class="sd">        1  1  2</span>
<span class="sd">        2  1  2</span>

<span class="sd">        Returning a Series inside the function is similar to passing</span>
<span class="sd">        ``result_type=&#39;expand&#39;``. The resulting column names</span>
<span class="sd">        will be the Series index.</span>

<span class="sd">        &gt;&gt;&gt; df.apply(lambda x: pd.Series([1, 2], index=[&#39;foo&#39;, &#39;bar&#39;]), axis=1)</span>
<span class="sd">           foo  bar</span>
<span class="sd">        0    1    2</span>
<span class="sd">        1    1    2</span>
<span class="sd">        2    1    2</span>

<span class="sd">        Passing ``result_type=&#39;broadcast&#39;`` will ensure the same shape</span>
<span class="sd">        result, whether list-like or scalar is returned by the function,</span>
<span class="sd">        and broadcast it along the axis. The resulting column names will</span>
<span class="sd">        be the originals.</span>

<span class="sd">        &gt;&gt;&gt; df.apply(lambda x: [1, 2], axis=1, result_type=&#39;broadcast&#39;)</span>
<span class="sd">           A  B</span>
<span class="sd">        0  1  2</span>
<span class="sd">        1  1  2</span>
<span class="sd">        2  1  2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.apply</span> <span class="kn">import</span> <span class="n">frame_apply</span>

        <span class="n">op</span> <span class="o">=</span> <span class="n">frame_apply</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">raw</span><span class="o">=</span><span class="n">raw</span><span class="p">,</span>
            <span class="n">result_type</span><span class="o">=</span><span class="n">result_type</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">apply</span><span class="p">()</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;apply&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">applymap</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">PythonFuncType</span><span class="p">,</span> <span class="n">na_action</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply a function to a Dataframe elementwise.</span>

<span class="sd">        This method applies a function that accepts and returns a scalar</span>
<span class="sd">        to every element of a DataFrame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : callable</span>
<span class="sd">            Python function, returns a single value from a single value.</span>
<span class="sd">        na_action : {None, &#39;ignore&#39;}, default None</span>
<span class="sd">            If ‘ignore’, propagate NaN values, without passing them to func.</span>

<span class="sd">            .. versionadded:: 1.2</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Additional keyword arguments to pass as keywords arguments to</span>
<span class="sd">            `func`.</span>

<span class="sd">            .. versionadded:: 1.3.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            Transformed DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.apply : Apply a function along input axis of DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([[1, 2.12], [3.356, 4.567]])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">               0      1</span>
<span class="sd">        0  1.000  2.120</span>
<span class="sd">        1  3.356  4.567</span>

<span class="sd">        &gt;&gt;&gt; df.applymap(lambda x: len(str(x)))</span>
<span class="sd">           0  1</span>
<span class="sd">        0  3  4</span>
<span class="sd">        1  5  5</span>

<span class="sd">        Like Series.map, NA values can be ignored:</span>

<span class="sd">        &gt;&gt;&gt; df_copy = df.copy()</span>
<span class="sd">        &gt;&gt;&gt; df_copy.iloc[0, 0] = pd.NA</span>
<span class="sd">        &gt;&gt;&gt; df_copy.applymap(lambda x: len(str(x)), na_action=&#39;ignore&#39;)</span>
<span class="sd">             0  1</span>
<span class="sd">        0  NaN  4</span>
<span class="sd">        1  5.0  5</span>

<span class="sd">        Note that a vectorized version of `func` often exists, which will</span>
<span class="sd">        be much faster. You could square each number elementwise.</span>

<span class="sd">        &gt;&gt;&gt; df.applymap(lambda x: x**2)</span>
<span class="sd">                   0          1</span>
<span class="sd">        0   1.000000   4.494400</span>
<span class="sd">        1  11.262736  20.857489</span>

<span class="sd">        But it&#39;s better to avoid applymap in that case.</span>

<span class="sd">        &gt;&gt;&gt; df ** 2</span>
<span class="sd">                   0          1</span>
<span class="sd">        0   1.000000   4.494400</span>
<span class="sd">        1  11.262736  20.857489</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">na_action</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;na_action must be &#39;ignore&#39; or None. Got </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">na_action</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">ignore_na</span> <span class="o">=</span> <span class="n">na_action</span> <span class="o">==</span> <span class="s2">&quot;ignore&quot;</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># if we have a dtype == &#39;M8[ns]&#39;, provide boxed values</span>
        <span class="k">def</span> <span class="nf">infer</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">lib</span><span class="o">.</span><span class="n">map_infer</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">ignore_na</span><span class="o">=</span><span class="n">ignore_na</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">lib</span><span class="o">.</span><span class="n">map_infer</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">ignore_na</span><span class="o">=</span><span class="n">ignore_na</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">infer</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;applymap&quot;</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Merging / joining methods</span>

    <span class="k">def</span> <span class="nf">_append</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">,</span>
        <span class="n">ignore_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">verify_integrity</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">sort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ignore_index</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Can only append a dict if ignore_index=True&quot;</span><span class="p">)</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">Series</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ignore_index</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;Can only append a Series if ignore_index=True &quot;</span>
                    <span class="s2">&quot;or if the Series has a name&quot;</span>
                <span class="p">)</span>

            <span class="n">index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span>
                <span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">],</span>
                <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span>
                <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">row_df</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
            <span class="c1"># infer_objects is needed for</span>
            <span class="c1">#  test_append_empty_frame_to_series_with_dateutil_tz</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">row_df</span><span class="o">.</span><span class="n">infer_objects</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">rename_axis</span><span class="p">(</span>
                <span class="n">index</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">DataFrame</span><span class="p">):</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ignore_index</span><span class="p">:</span>
                    <span class="n">other</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span>

        <span class="kn">from</span> <span class="nn">pandas.core.reshape.concat</span> <span class="kn">import</span> <span class="n">concat</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">to_concat</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">to_concat</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">]</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">concat</span><span class="p">(</span>
            <span class="n">to_concat</span><span class="p">,</span>
            <span class="n">ignore_index</span><span class="o">=</span><span class="n">ignore_index</span><span class="p">,</span>
            <span class="n">verify_integrity</span><span class="o">=</span><span class="n">verify_integrity</span><span class="p">,</span>
            <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;append&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Series</span><span class="p">],</span>
        <span class="n">on</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">how</span><span class="p">:</span> <span class="n">MergeHow</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span>
        <span class="n">lsuffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">rsuffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">sort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">validate</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Join columns of another DataFrame.</span>

<span class="sd">        Join columns with `other` DataFrame either on index or on a key</span>
<span class="sd">        column. Efficiently join multiple DataFrame objects by index at once by</span>
<span class="sd">        passing a list.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : DataFrame, Series, or a list containing any combination of them</span>
<span class="sd">            Index should be similar to one of the columns in this one. If a</span>
<span class="sd">            Series is passed, its name attribute must be set, and that will be</span>
<span class="sd">            used as the column name in the resulting joined DataFrame.</span>
<span class="sd">        on : str, list of str, or array-like, optional</span>
<span class="sd">            Column or index level name(s) in the caller to join on the index</span>
<span class="sd">            in `other`, otherwise joins index-on-index. If multiple</span>
<span class="sd">            values given, the `other` DataFrame must have a MultiIndex. Can</span>
<span class="sd">            pass an array as the join key if it is not already contained in</span>
<span class="sd">            the calling DataFrame. Like an Excel VLOOKUP operation.</span>
<span class="sd">        how : {&#39;left&#39;, &#39;right&#39;, &#39;outer&#39;, &#39;inner&#39;, &#39;cross&#39;}, default &#39;left&#39;</span>
<span class="sd">            How to handle the operation of the two objects.</span>

<span class="sd">            * left: use calling frame&#39;s index (or column if on is specified)</span>
<span class="sd">            * right: use `other`&#39;s index.</span>
<span class="sd">            * outer: form union of calling frame&#39;s index (or column if on is</span>
<span class="sd">              specified) with `other`&#39;s index, and sort it.</span>
<span class="sd">              lexicographically.</span>
<span class="sd">            * inner: form intersection of calling frame&#39;s index (or column if</span>
<span class="sd">              on is specified) with `other`&#39;s index, preserving the order</span>
<span class="sd">              of the calling&#39;s one.</span>
<span class="sd">            * cross: creates the cartesian product from both frames, preserves the order</span>
<span class="sd">              of the left keys.</span>

<span class="sd">              .. versionadded:: 1.2.0</span>

<span class="sd">        lsuffix : str, default &#39;&#39;</span>
<span class="sd">            Suffix to use from left frame&#39;s overlapping columns.</span>
<span class="sd">        rsuffix : str, default &#39;&#39;</span>
<span class="sd">            Suffix to use from right frame&#39;s overlapping columns.</span>
<span class="sd">        sort : bool, default False</span>
<span class="sd">            Order result DataFrame lexicographically by the join key. If False,</span>
<span class="sd">            the order of the join key depends on the join type (how keyword).</span>
<span class="sd">        validate : str, optional</span>
<span class="sd">            If specified, checks if join is of specified type.</span>
<span class="sd">            * &quot;one_to_one&quot; or &quot;1:1&quot;: check if join keys are unique in both left</span>
<span class="sd">            and right datasets.</span>
<span class="sd">            * &quot;one_to_many&quot; or &quot;1:m&quot;: check if join keys are unique in left dataset.</span>
<span class="sd">            * &quot;many_to_one&quot; or &quot;m:1&quot;: check if join keys are unique in right dataset.</span>
<span class="sd">            * &quot;many_to_many&quot; or &quot;m:m&quot;: allowed, but does not result in checks.</span>
<span class="sd">            .. versionadded:: 1.5.0</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            A dataframe containing columns from both the caller and `other`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.merge : For column(s)-on-column(s) operations.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Parameters `on`, `lsuffix`, and `rsuffix` are not supported when</span>
<span class="sd">        passing a list of `DataFrame` objects.</span>

<span class="sd">        Support for specifying index levels as the `on` parameter was added</span>
<span class="sd">        in version 0.23.0.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;key&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K2&#39;, &#39;K3&#39;, &#39;K4&#39;, &#39;K5&#39;],</span>
<span class="sd">        ...                    &#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;, &#39;A4&#39;, &#39;A5&#39;]})</span>

<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">          key   A</span>
<span class="sd">        0  K0  A0</span>
<span class="sd">        1  K1  A1</span>
<span class="sd">        2  K2  A2</span>
<span class="sd">        3  K3  A3</span>
<span class="sd">        4  K4  A4</span>
<span class="sd">        5  K5  A5</span>

<span class="sd">        &gt;&gt;&gt; other = pd.DataFrame({&#39;key&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K2&#39;],</span>
<span class="sd">        ...                       &#39;B&#39;: [&#39;B0&#39;, &#39;B1&#39;, &#39;B2&#39;]})</span>

<span class="sd">        &gt;&gt;&gt; other</span>
<span class="sd">          key   B</span>
<span class="sd">        0  K0  B0</span>
<span class="sd">        1  K1  B1</span>
<span class="sd">        2  K2  B2</span>

<span class="sd">        Join DataFrames using their indexes.</span>

<span class="sd">        &gt;&gt;&gt; df.join(other, lsuffix=&#39;_caller&#39;, rsuffix=&#39;_other&#39;)</span>
<span class="sd">          key_caller   A key_other    B</span>
<span class="sd">        0         K0  A0        K0   B0</span>
<span class="sd">        1         K1  A1        K1   B1</span>
<span class="sd">        2         K2  A2        K2   B2</span>
<span class="sd">        3         K3  A3       NaN  NaN</span>
<span class="sd">        4         K4  A4       NaN  NaN</span>
<span class="sd">        5         K5  A5       NaN  NaN</span>

<span class="sd">        If we want to join using the key columns, we need to set key to be</span>
<span class="sd">        the index in both `df` and `other`. The joined DataFrame will have</span>
<span class="sd">        key as its index.</span>

<span class="sd">        &gt;&gt;&gt; df.set_index(&#39;key&#39;).join(other.set_index(&#39;key&#39;))</span>
<span class="sd">              A    B</span>
<span class="sd">        key</span>
<span class="sd">        K0   A0   B0</span>
<span class="sd">        K1   A1   B1</span>
<span class="sd">        K2   A2   B2</span>
<span class="sd">        K3   A3  NaN</span>
<span class="sd">        K4   A4  NaN</span>
<span class="sd">        K5   A5  NaN</span>

<span class="sd">        Another option to join using the key columns is to use the `on`</span>
<span class="sd">        parameter. DataFrame.join always uses `other`&#39;s index but we can use</span>
<span class="sd">        any column in `df`. This method preserves the original DataFrame&#39;s</span>
<span class="sd">        index in the result.</span>

<span class="sd">        &gt;&gt;&gt; df.join(other.set_index(&#39;key&#39;), on=&#39;key&#39;)</span>
<span class="sd">          key   A    B</span>
<span class="sd">        0  K0  A0   B0</span>
<span class="sd">        1  K1  A1   B1</span>
<span class="sd">        2  K2  A2   B2</span>
<span class="sd">        3  K3  A3  NaN</span>
<span class="sd">        4  K4  A4  NaN</span>
<span class="sd">        5  K5  A5  NaN</span>

<span class="sd">        Using non-unique key values shows how they are matched.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;key&#39;: [&#39;K0&#39;, &#39;K1&#39;, &#39;K1&#39;, &#39;K3&#39;, &#39;K0&#39;, &#39;K1&#39;],</span>
<span class="sd">        ...                    &#39;A&#39;: [&#39;A0&#39;, &#39;A1&#39;, &#39;A2&#39;, &#39;A3&#39;, &#39;A4&#39;, &#39;A5&#39;]})</span>

<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">          key   A</span>
<span class="sd">        0  K0  A0</span>
<span class="sd">        1  K1  A1</span>
<span class="sd">        2  K1  A2</span>
<span class="sd">        3  K3  A3</span>
<span class="sd">        4  K0  A4</span>
<span class="sd">        5  K1  A5</span>

<span class="sd">        &gt;&gt;&gt; df.join(other.set_index(&#39;key&#39;), on=&#39;key&#39;, validate=&#39;m:1&#39;)</span>
<span class="sd">          key   A    B</span>
<span class="sd">        0  K0  A0   B0</span>
<span class="sd">        1  K1  A1   B1</span>
<span class="sd">        2  K1  A2   B1</span>
<span class="sd">        3  K3  A3  NaN</span>
<span class="sd">        4  K0  A4   B0</span>
<span class="sd">        5  K1  A5   B1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_join_compat</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="n">on</span><span class="o">=</span><span class="n">on</span><span class="p">,</span>
            <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
            <span class="n">lsuffix</span><span class="o">=</span><span class="n">lsuffix</span><span class="p">,</span>
            <span class="n">rsuffix</span><span class="o">=</span><span class="n">rsuffix</span><span class="p">,</span>
            <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span>
            <span class="n">validate</span><span class="o">=</span><span class="n">validate</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_join_compat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Series</span><span class="p">],</span>
        <span class="n">on</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">how</span><span class="p">:</span> <span class="n">MergeHow</span> <span class="o">=</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span>
        <span class="n">lsuffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">rsuffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">sort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">validate</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.concat</span> <span class="kn">import</span> <span class="n">concat</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.merge</span> <span class="kn">import</span> <span class="n">merge</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Other Series must have a name&quot;</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">({</span><span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">other</span><span class="p">})</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;cross&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">merge</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span>
                    <span class="n">other</span><span class="p">,</span>
                    <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
                    <span class="n">on</span><span class="o">=</span><span class="n">on</span><span class="p">,</span>
                    <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="n">lsuffix</span><span class="p">,</span> <span class="n">rsuffix</span><span class="p">),</span>
                    <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span>
                    <span class="n">validate</span><span class="o">=</span><span class="n">validate</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">merge</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">other</span><span class="p">,</span>
                <span class="n">left_on</span><span class="o">=</span><span class="n">on</span><span class="p">,</span>
                <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
                <span class="n">left_index</span><span class="o">=</span><span class="n">on</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="n">lsuffix</span><span class="p">,</span> <span class="n">rsuffix</span><span class="p">),</span>
                <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span>
                <span class="n">validate</span><span class="o">=</span><span class="n">validate</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">on</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Joining multiple DataFrames only supported for joining on index&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">rsuffix</span> <span class="ow">or</span> <span class="n">lsuffix</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Suffixes not supported when joining multiple DataFrames&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Mypy thinks the RHS is a</span>
            <span class="c1"># &quot;Union[DataFrame, Series, Iterable[Union[DataFrame, Series]]]&quot; whereas</span>
            <span class="c1"># the LHS is an &quot;Iterable[DataFrame]&quot;, but in reality both types are</span>
            <span class="c1"># &quot;Iterable[Union[DataFrame, Series]]&quot; due to the if statements</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="p">[</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;DataFrame | Series&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

            <span class="n">can_concat</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_unique</span> <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">)</span>

            <span class="c1"># join indexes only using concat</span>
            <span class="k">if</span> <span class="n">can_concat</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">how</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span><span class="p">:</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="n">concat</span><span class="p">(</span>
                        <span class="n">frames</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span> <span class="n">verify_integrity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span>
                    <span class="p">)</span>
                    <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">concat</span><span class="p">(</span>
                        <span class="n">frames</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="n">how</span><span class="p">,</span> <span class="n">verify_integrity</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span>
                    <span class="p">)</span>

            <span class="n">joined</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">frames</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">joined</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span>
                    <span class="n">joined</span><span class="p">,</span>
                    <span class="n">frame</span><span class="p">,</span>
                    <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
                    <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">validate</span><span class="o">=</span><span class="n">validate</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="n">joined</span>

    <span class="nd">@Substitution</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="nd">@Appender</span><span class="p">(</span><span class="n">_merge_doc</span><span class="p">,</span> <span class="n">indents</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">right</span><span class="p">:</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Series</span><span class="p">,</span>
        <span class="n">how</span><span class="p">:</span> <span class="n">MergeHow</span> <span class="o">=</span> <span class="s2">&quot;inner&quot;</span><span class="p">,</span>
        <span class="n">on</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">left_on</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">right_on</span><span class="p">:</span> <span class="n">IndexLabel</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">left_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">right_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">sort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">suffixes</span><span class="p">:</span> <span class="n">Suffixes</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;_x&quot;</span><span class="p">,</span> <span class="s2">&quot;_y&quot;</span><span class="p">),</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">indicator</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">validate</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.merge</span> <span class="kn">import</span> <span class="n">merge</span>

        <span class="k">return</span> <span class="n">merge</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">right</span><span class="p">,</span>
            <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
            <span class="n">on</span><span class="o">=</span><span class="n">on</span><span class="p">,</span>
            <span class="n">left_on</span><span class="o">=</span><span class="n">left_on</span><span class="p">,</span>
            <span class="n">right_on</span><span class="o">=</span><span class="n">right_on</span><span class="p">,</span>
            <span class="n">left_index</span><span class="o">=</span><span class="n">left_index</span><span class="p">,</span>
            <span class="n">right_index</span><span class="o">=</span><span class="n">right_index</span><span class="p">,</span>
            <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span>
            <span class="n">suffixes</span><span class="o">=</span><span class="n">suffixes</span><span class="p">,</span>
            <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
            <span class="n">indicator</span><span class="o">=</span><span class="n">indicator</span><span class="p">,</span>
            <span class="n">validate</span><span class="o">=</span><span class="n">validate</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">round</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">decimals</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="n">IndexLabel</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">Series</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Round a DataFrame to a variable number of decimal places.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        decimals : int, dict, Series</span>
<span class="sd">            Number of decimal places to round each column to. If an int is</span>
<span class="sd">            given, round each column to the same number of places.</span>
<span class="sd">            Otherwise dict and Series round to variable numbers of places.</span>
<span class="sd">            Column names should be in the keys if `decimals` is a</span>
<span class="sd">            dict-like, or in the index if `decimals` is a Series. Any</span>
<span class="sd">            columns not included in `decimals` will be left as is. Elements</span>
<span class="sd">            of `decimals` which are not columns of the input will be</span>
<span class="sd">            ignored.</span>
<span class="sd">        *args</span>
<span class="sd">            Additional keywords have no effect but might be accepted for</span>
<span class="sd">            compatibility with numpy.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Additional keywords have no effect but might be accepted for</span>
<span class="sd">            compatibility with numpy.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            A DataFrame with the affected columns rounded to the specified</span>
<span class="sd">            number of decimal places.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.around : Round a numpy array to the given number of decimals.</span>
<span class="sd">        Series.round : Round a Series to the given number of decimals.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([(.21, .32), (.01, .67), (.66, .03), (.21, .18)],</span>
<span class="sd">        ...                   columns=[&#39;dogs&#39;, &#39;cats&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">            dogs  cats</span>
<span class="sd">        0  0.21  0.32</span>
<span class="sd">        1  0.01  0.67</span>
<span class="sd">        2  0.66  0.03</span>
<span class="sd">        3  0.21  0.18</span>

<span class="sd">        By providing an integer each column is rounded to the same number</span>
<span class="sd">        of decimal places</span>

<span class="sd">        &gt;&gt;&gt; df.round(1)</span>
<span class="sd">            dogs  cats</span>
<span class="sd">        0   0.2   0.3</span>
<span class="sd">        1   0.0   0.7</span>
<span class="sd">        2   0.7   0.0</span>
<span class="sd">        3   0.2   0.2</span>

<span class="sd">        With a dict, the number of places for specific columns can be</span>
<span class="sd">        specified with the column names as key and the number of decimal</span>
<span class="sd">        places as value</span>

<span class="sd">        &gt;&gt;&gt; df.round({&#39;dogs&#39;: 1, &#39;cats&#39;: 0})</span>
<span class="sd">            dogs  cats</span>
<span class="sd">        0   0.2   0.0</span>
<span class="sd">        1   0.0   1.0</span>
<span class="sd">        2   0.7   0.0</span>
<span class="sd">        3   0.2   0.0</span>

<span class="sd">        Using a Series, the number of places for specific columns can be</span>
<span class="sd">        specified with the column names as index and the number of</span>
<span class="sd">        decimal places as value</span>

<span class="sd">        &gt;&gt;&gt; decimals = pd.Series([0, 1], index=[&#39;cats&#39;, &#39;dogs&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df.round(decimals)</span>
<span class="sd">            dogs  cats</span>
<span class="sd">        0   0.2   0.0</span>
<span class="sd">        1   0.0   1.0</span>
<span class="sd">        2   0.7   0.0</span>
<span class="sd">        3   0.2   0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pandas.core.reshape.concat</span> <span class="kn">import</span> <span class="n">concat</span>

        <span class="k">def</span> <span class="nf">_dict_round</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">decimals</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">vals</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">_series_round</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">decimals</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">vals</span>

        <span class="k">def</span> <span class="nf">_series_round</span><span class="p">(</span><span class="n">ser</span><span class="p">:</span> <span class="n">Series</span><span class="p">,</span> <span class="n">decimals</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="n">ser</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">or</span> <span class="n">is_float_dtype</span><span class="p">(</span><span class="n">ser</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">ser</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ser</span>

        <span class="n">nv</span><span class="o">.</span><span class="n">validate_round</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decimals</span><span class="p">,</span> <span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">Series</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decimals</span><span class="p">,</span> <span class="n">Series</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">decimals</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Index of decimals must be unique&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_dict_like</span><span class="p">(</span><span class="n">decimals</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
                <span class="n">is_integer</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">decimals</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Values in decimals must be integers&quot;</span><span class="p">)</span>
            <span class="n">new_cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_dict_round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decimals</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">is_integer</span><span class="p">(</span><span class="n">decimals</span><span class="p">):</span>
            <span class="c1"># Dispatch to Block.round</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="o">=</span><span class="n">decimals</span><span class="p">,</span> <span class="n">using_cow</span><span class="o">=</span><span class="n">using_copy_on_write</span><span class="p">()),</span>
            <span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;round&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;decimals must be an integer, a dict-like or a Series&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">new_cols</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_cols</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                <span class="n">concat</span><span class="p">(</span><span class="n">new_cols</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
            <span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;round&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Statistical methods, etc.</span>

    <span class="k">def</span> <span class="nf">corr</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">CorrelationMethod</span> <span class="o">=</span> <span class="s2">&quot;pearson&quot;</span><span class="p">,</span>
        <span class="n">min_periods</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute pairwise correlation of columns, excluding NA/null values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : {&#39;pearson&#39;, &#39;kendall&#39;, &#39;spearman&#39;} or callable</span>
<span class="sd">            Method of correlation:</span>

<span class="sd">            * pearson : standard correlation coefficient</span>
<span class="sd">            * kendall : Kendall Tau correlation coefficient</span>
<span class="sd">            * spearman : Spearman rank correlation</span>
<span class="sd">            * callable: callable with input two 1d ndarrays</span>
<span class="sd">                and returning a float. Note that the returned matrix from corr</span>
<span class="sd">                will have 1 along the diagonals and will be symmetric</span>
<span class="sd">                regardless of the callable&#39;s behavior.</span>
<span class="sd">        min_periods : int, optional</span>
<span class="sd">            Minimum number of observations required per pair of columns</span>
<span class="sd">            to have a valid result. Currently only available for Pearson</span>
<span class="sd">            and Spearman correlation.</span>
<span class="sd">        numeric_only : bool, default False</span>
<span class="sd">            Include only `float`, `int` or `boolean` data.</span>

<span class="sd">            .. versionadded:: 1.5.0</span>

<span class="sd">            .. versionchanged:: 2.0.0</span>
<span class="sd">                The default value of ``numeric_only`` is now ``False``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            Correlation matrix.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.corrwith : Compute pairwise correlation with another</span>
<span class="sd">            DataFrame or Series.</span>
<span class="sd">        Series.corr : Compute the correlation between two Series.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Pearson, Kendall and Spearman correlation are currently computed using pairwise complete observations.</span>

<span class="sd">        * `Pearson correlation coefficient &lt;https://en.wikipedia.org/wiki/Pearson_correlation_coefficient&gt;`_</span>
<span class="sd">        * `Kendall rank correlation coefficient &lt;https://en.wikipedia.org/wiki/Kendall_rank_correlation_coefficient&gt;`_</span>
<span class="sd">        * `Spearman&#39;s rank correlation coefficient &lt;https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient&gt;`_</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; def histogram_intersection(a, b):</span>
<span class="sd">        ...     v = np.minimum(a, b).sum().round(decimals=1)</span>
<span class="sd">        ...     return v</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([(.2, .3), (.0, .6), (.6, .0), (.2, .1)],</span>
<span class="sd">        ...                   columns=[&#39;dogs&#39;, &#39;cats&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df.corr(method=histogram_intersection)</span>
<span class="sd">              dogs  cats</span>
<span class="sd">        dogs   1.0   0.3</span>
<span class="sd">        cats   0.3   1.0</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([(1, 1), (2, np.nan), (np.nan, 3), (4, 4)],</span>
<span class="sd">        ...                   columns=[&#39;dogs&#39;, &#39;cats&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df.corr(min_periods=3)</span>
<span class="sd">              dogs  cats</span>
<span class="sd">        dogs   1.0   NaN</span>
<span class="sd">        cats   NaN   1.0</span>
<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa:E501</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span> <span class="k">if</span> <span class="n">numeric_only</span> <span class="k">else</span> <span class="bp">self</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">cols</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">na_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;pearson&quot;</span><span class="p">:</span>
            <span class="n">correl</span> <span class="o">=</span> <span class="n">libalgos</span><span class="o">.</span><span class="n">nancorr</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">minp</span><span class="o">=</span><span class="n">min_periods</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;spearman&quot;</span><span class="p">:</span>
            <span class="n">correl</span> <span class="o">=</span> <span class="n">libalgos</span><span class="o">.</span><span class="n">nancorr_spearman</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">minp</span><span class="o">=</span><span class="n">min_periods</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;kendall&quot;</span> <span class="ow">or</span> <span class="nb">callable</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">min_periods</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">min_periods</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">mat</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">T</span>
            <span class="n">corrf</span> <span class="o">=</span> <span class="n">nanops</span><span class="o">.</span><span class="n">get_corr_func</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
            <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
            <span class="n">correl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">K</span><span class="p">,</span> <span class="n">K</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ac</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">bc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="n">valid</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">valid</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">min_periods</span><span class="p">:</span>
                        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                        <span class="n">c</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">valid</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
                        <span class="n">c</span> <span class="o">=</span> <span class="n">corrf</span><span class="p">(</span><span class="n">ac</span><span class="p">[</span><span class="n">valid</span><span class="p">],</span> <span class="n">bc</span><span class="p">[</span><span class="n">valid</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">c</span> <span class="o">=</span> <span class="n">corrf</span><span class="p">(</span><span class="n">ac</span><span class="p">,</span> <span class="n">bc</span><span class="p">)</span>
                    <span class="n">correl</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
                    <span class="n">correl</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;method must be either &#39;pearson&#39;, &quot;</span>
                <span class="s2">&quot;&#39;spearman&#39;, &#39;kendall&#39;, or a callable, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39; was supplied&quot;</span>
            <span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">correl</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;corr&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">cov</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">min_periods</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ddof</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute pairwise covariance of columns, excluding NA/null values.</span>

<span class="sd">        Compute the pairwise covariance among the series of a DataFrame.</span>
<span class="sd">        The returned data frame is the `covariance matrix</span>
<span class="sd">        &lt;https://en.wikipedia.org/wiki/Covariance_matrix&gt;`__ of the columns</span>
<span class="sd">        of the DataFrame.</span>

<span class="sd">        Both NA and null values are automatically excluded from the</span>
<span class="sd">        calculation. (See the note below about bias from missing values.)</span>
<span class="sd">        A threshold can be set for the minimum number of</span>
<span class="sd">        observations for each value created. Comparisons with observations</span>
<span class="sd">        below this threshold will be returned as ``NaN``.</span>

<span class="sd">        This method is generally used for the analysis of time series data to</span>
<span class="sd">        understand the relationship between different measures</span>
<span class="sd">        across time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        min_periods : int, optional</span>
<span class="sd">            Minimum number of observations required per pair of columns</span>
<span class="sd">            to have a valid result.</span>

<span class="sd">        ddof : int, default 1</span>
<span class="sd">            Delta degrees of freedom.  The divisor used in calculations</span>
<span class="sd">            is ``N - ddof``, where ``N`` represents the number of elements.</span>

<span class="sd">            .. versionadded:: 1.1.0</span>

<span class="sd">        numeric_only : bool, default False</span>
<span class="sd">            Include only `float`, `int` or `boolean` data.</span>

<span class="sd">            .. versionadded:: 1.5.0</span>

<span class="sd">            .. versionchanged:: 2.0.0</span>
<span class="sd">                The default value of ``numeric_only`` is now ``False``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            The covariance matrix of the series of the DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.cov : Compute covariance with another Series.</span>
<span class="sd">        core.window.ewm.ExponentialMovingWindow.cov : Exponential weighted sample</span>
<span class="sd">            covariance.</span>
<span class="sd">        core.window.expanding.Expanding.cov : Expanding sample covariance.</span>
<span class="sd">        core.window.rolling.Rolling.cov : Rolling sample covariance.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Returns the covariance matrix of the DataFrame&#39;s time series.</span>
<span class="sd">        The covariance is normalized by N-ddof.</span>

<span class="sd">        For DataFrames that have Series that are missing data (assuming that</span>
<span class="sd">        data is `missing at random</span>
<span class="sd">        &lt;https://en.wikipedia.org/wiki/Missing_data#Missing_at_random&gt;`__)</span>
<span class="sd">        the returned covariance matrix will be an unbiased estimate</span>
<span class="sd">        of the variance and covariance between the member Series.</span>

<span class="sd">        However, for many applications this estimate may not be acceptable</span>
<span class="sd">        because the estimate covariance matrix is not guaranteed to be positive</span>
<span class="sd">        semi-definite. This could lead to estimate correlations having</span>
<span class="sd">        absolute values which are greater than one, and/or a non-invertible</span>
<span class="sd">        covariance matrix. See `Estimation of covariance matrices</span>
<span class="sd">        &lt;https://en.wikipedia.org/w/index.php?title=Estimation_of_covariance_</span>
<span class="sd">        matrices&gt;`__ for more details.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([(1, 2), (0, 3), (2, 0), (1, 1)],</span>
<span class="sd">        ...                   columns=[&#39;dogs&#39;, &#39;cats&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df.cov()</span>
<span class="sd">                  dogs      cats</span>
<span class="sd">        dogs  0.666667 -1.000000</span>
<span class="sd">        cats -1.000000  1.666667</span>

<span class="sd">        &gt;&gt;&gt; np.random.seed(42)</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(np.random.randn(1000, 5),</span>
<span class="sd">        ...                   columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df.cov()</span>
<span class="sd">                  a         b         c         d         e</span>
<span class="sd">        a  0.998438 -0.020161  0.059277 -0.008943  0.014144</span>
<span class="sd">        b -0.020161  1.059352 -0.008543 -0.024738  0.009826</span>
<span class="sd">        c  0.059277 -0.008543  1.010670 -0.001486 -0.000271</span>
<span class="sd">        d -0.008943 -0.024738 -0.001486  0.921297 -0.013692</span>
<span class="sd">        e  0.014144  0.009826 -0.000271 -0.013692  0.977795</span>

<span class="sd">        **Minimum number of periods**</span>

<span class="sd">        This method also supports an optional ``min_periods`` keyword</span>
<span class="sd">        that specifies the required minimum number of non-NA observations for</span>
<span class="sd">        each column pair in order to have a valid result:</span>

<span class="sd">        &gt;&gt;&gt; np.random.seed(42)</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(np.random.randn(20, 3),</span>
<span class="sd">        ...                   columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df.loc[df.index[:5], &#39;a&#39;] = np.nan</span>
<span class="sd">        &gt;&gt;&gt; df.loc[df.index[5:10], &#39;b&#39;] = np.nan</span>
<span class="sd">        &gt;&gt;&gt; df.cov(min_periods=12)</span>
<span class="sd">                  a         b         c</span>
<span class="sd">        a  0.316741       NaN -0.150812</span>
<span class="sd">        b       NaN  1.248003  0.191417</span>
<span class="sd">        c -0.150812  0.191417  0.895202</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span> <span class="k">if</span> <span class="n">numeric_only</span> <span class="k">else</span> <span class="bp">self</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">cols</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">na_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">notna</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">min_periods</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">min_periods</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">):</span>
                <span class="n">base_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">base_cov</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">base_cov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">mat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">)</span>
            <span class="n">base_cov</span> <span class="o">=</span> <span class="n">base_cov</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">base_cov</span> <span class="o">=</span> <span class="n">libalgos</span><span class="o">.</span><span class="n">nancorr</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">minp</span><span class="o">=</span><span class="n">min_periods</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">base_cov</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;cov&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">corrwith</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Series</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">drop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">CorrelationMethod</span> <span class="o">=</span> <span class="s2">&quot;pearson&quot;</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute pairwise correlation.</span>

<span class="sd">        Pairwise correlation is computed between rows or columns of</span>
<span class="sd">        DataFrame with rows or columns of Series or DataFrame. DataFrames</span>
<span class="sd">        are first aligned along both axes before computing the</span>
<span class="sd">        correlations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : DataFrame, Series</span>
<span class="sd">            Object with which to compute correlations.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            The axis to use. 0 or &#39;index&#39; to compute row-wise, 1 or &#39;columns&#39; for</span>
<span class="sd">            column-wise.</span>
<span class="sd">        drop : bool, default False</span>
<span class="sd">            Drop missing indices from result.</span>
<span class="sd">        method : {&#39;pearson&#39;, &#39;kendall&#39;, &#39;spearman&#39;} or callable</span>
<span class="sd">            Method of correlation:</span>

<span class="sd">            * pearson : standard correlation coefficient</span>
<span class="sd">            * kendall : Kendall Tau correlation coefficient</span>
<span class="sd">            * spearman : Spearman rank correlation</span>
<span class="sd">            * callable: callable with input two 1d ndarrays</span>
<span class="sd">                and returning a float.</span>

<span class="sd">        numeric_only : bool, default False</span>
<span class="sd">            Include only `float`, `int` or `boolean` data.</span>

<span class="sd">            .. versionadded:: 1.5.0</span>

<span class="sd">            .. versionchanged:: 2.0.0</span>
<span class="sd">                The default value of ``numeric_only`` is now ``False``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>
<span class="sd">            Pairwise correlations.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.corr : Compute pairwise correlation of columns.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; index = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</span>
<span class="sd">        &gt;&gt;&gt; columns = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]</span>
<span class="sd">        &gt;&gt;&gt; df1 = pd.DataFrame(np.arange(20).reshape(5, 4), index=index, columns=columns)</span>
<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame(np.arange(16).reshape(4, 4), index=index[:4], columns=columns)</span>
<span class="sd">        &gt;&gt;&gt; df1.corrwith(df2)</span>
<span class="sd">        one      1.0</span>
<span class="sd">        two      1.0</span>
<span class="sd">        three    1.0</span>
<span class="sd">        four     1.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; df2.corrwith(df1, axis=1)</span>
<span class="sd">        a    1.0</span>
<span class="sd">        b    1.0</span>
<span class="sd">        c    1.0</span>
<span class="sd">        d    1.0</span>
<span class="sd">        e    NaN</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa:E501</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">this</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span> <span class="k">if</span> <span class="n">numeric_only</span> <span class="k">else</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">this</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">other</span><span class="o">.</span><span class="n">corr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">numeric_only</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">T</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;pearson&quot;</span><span class="p">:</span>
            <span class="c1"># mask missing values</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span> <span class="o">*</span> <span class="mi">0</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">right</span> <span class="o">+</span> <span class="n">left</span> <span class="o">*</span> <span class="mi">0</span>

            <span class="c1"># demeaned data</span>
            <span class="n">ldem</span> <span class="o">=</span> <span class="n">left</span> <span class="o">-</span> <span class="n">left</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span><span class="p">)</span>
            <span class="n">rdem</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">right</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span><span class="p">)</span>

            <span class="n">num</span> <span class="o">=</span> <span class="p">(</span><span class="n">ldem</span> <span class="o">*</span> <span class="n">rdem</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">dom</span> <span class="o">=</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="o">*</span> <span class="n">left</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span><span class="p">)</span>
                <span class="o">*</span> <span class="n">right</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="n">correl</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="n">dom</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;kendall&quot;</span><span class="p">,</span> <span class="s2">&quot;spearman&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="nb">callable</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">c</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">nanops</span><span class="o">.</span><span class="n">nancorr</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>

            <span class="n">correl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span>
                <span class="nb">map</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">T</span><span class="p">)),</span>
                <span class="n">index</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
                <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid method </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> was passed, &quot;</span>
                <span class="s2">&quot;valid methods are: &#39;pearson&#39;, &#39;kendall&#39;, &quot;</span>
                <span class="s2">&quot;&#39;spearman&#39;, or callable&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">drop</span><span class="p">:</span>
            <span class="c1"># Find non-matching labels along the given axis</span>
            <span class="c1"># and append missing correlations (GH 22375)</span>
            <span class="n">raxis</span><span class="p">:</span> <span class="n">AxisInt</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">result_index</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">raxis</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">raxis</span><span class="p">))</span>
            <span class="n">idx_diff</span> <span class="o">=</span> <span class="n">result_index</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">correl</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">correl</span> <span class="o">=</span> <span class="n">correl</span><span class="o">.</span><span class="n">_append</span><span class="p">(</span>
                    <span class="n">Series</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_diff</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="n">idx_diff</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">correl</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># ndarray-like stats methods</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count non-NA cells for each column or row.</span>

<span class="sd">        The values `None`, `NaN`, `NaT`, and optionally `numpy.inf` (depending</span>
<span class="sd">        on `pandas.options.mode.use_inf_as_na`) are considered NA.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            If 0 or &#39;index&#39; counts are generated for each column.</span>
<span class="sd">            If 1 or &#39;columns&#39; counts are generated for each row.</span>
<span class="sd">        numeric_only : bool, default False</span>
<span class="sd">            Include only `float`, `int` or `boolean` data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            For each column/row the number of non-NA/null entries.</span>
<span class="sd">            If `level` is specified returns a `DataFrame`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.count: Number of non-NA elements in a Series.</span>
<span class="sd">        DataFrame.value_counts: Count unique combinations of columns.</span>
<span class="sd">        DataFrame.shape: Number of DataFrame rows and columns (including NA</span>
<span class="sd">            elements).</span>
<span class="sd">        DataFrame.isna: Boolean same-sized DataFrame showing places of NA</span>
<span class="sd">            elements.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Constructing DataFrame from a dictionary:</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&quot;Person&quot;:</span>
<span class="sd">        ...                    [&quot;John&quot;, &quot;Myla&quot;, &quot;Lewis&quot;, &quot;John&quot;, &quot;Myla&quot;],</span>
<span class="sd">        ...                    &quot;Age&quot;: [24., np.nan, 21., 33, 26],</span>
<span class="sd">        ...                    &quot;Single&quot;: [False, True, True, True, False]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           Person   Age  Single</span>
<span class="sd">        0    John  24.0   False</span>
<span class="sd">        1    Myla   NaN    True</span>
<span class="sd">        2   Lewis  21.0    True</span>
<span class="sd">        3    John  33.0    True</span>
<span class="sd">        4    Myla  26.0   False</span>

<span class="sd">        Notice the uncounted NA values:</span>

<span class="sd">        &gt;&gt;&gt; df.count()</span>
<span class="sd">        Person    5</span>
<span class="sd">        Age       4</span>
<span class="sd">        Single    5</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        Counts for each **row**:</span>

<span class="sd">        &gt;&gt;&gt; df.count(axis=&#39;columns&#39;)</span>
<span class="sd">        0    3</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        3    3</span>
<span class="sd">        4    3</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">numeric_only</span><span class="p">:</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="c1"># GH #423</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">frame</span><span class="o">.</span><span class="n">_get_agg_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">frame</span><span class="o">.</span><span class="n">_is_mixed_type</span> <span class="ow">or</span> <span class="n">frame</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">any_extension_types</span><span class="p">:</span>
                <span class="c1"># the or any_extension_types is really only hit for single-</span>
                <span class="c1"># column frames with an extension array</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># GH13407</span>
                <span class="n">series_counts</span> <span class="o">=</span> <span class="n">notna</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
                <span class="n">counts</span> <span class="o">=</span> <span class="n">series_counts</span><span class="o">.</span><span class="n">_values</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span>
                    <span class="n">counts</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">frame</span><span class="o">.</span><span class="n">_get_agg_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;count&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reduce</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">op</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">filter_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwds</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">assert</span> <span class="n">filter_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">filter_type</span>
        <span class="n">out_dtype</span> <span class="o">=</span> <span class="s2">&quot;bool&quot;</span> <span class="k">if</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="s2">&quot;bool&quot;</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">values</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># We only use this in the case that operates on self.values</span>
            <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">blk_func</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">ExtensionArray</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_1d_only_ea_dtype</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="p">,</span> <span class="n">ArrayManager</span>
                <span class="p">):</span>
                    <span class="k">return</span> <span class="n">values</span><span class="o">.</span><span class="n">_reduce</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">values</span><span class="o">.</span><span class="n">_reduce</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_get_data</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">filter_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># GH#25101, GH#24434</span>
                <span class="k">assert</span> <span class="n">filter_type</span> <span class="o">==</span> <span class="s2">&quot;bool&quot;</span>
                <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_bool_data</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">data</span>

        <span class="c1"># Case with EAs see GH#35881</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">numeric_only</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">_get_data</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Taking a transpose would result in no columns, losing the dtype.</span>
                <span class="c1"># In the empty case, reducing along axis 0 or 1 gives the same</span>
                <span class="c1"># result dtype, so reduce with axis=0 and ignore values</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">_reduce</span><span class="p">(</span>
                    <span class="n">op</span><span class="p">,</span>
                    <span class="n">name</span><span class="p">,</span>
                    <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span>
                    <span class="n">numeric_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">filter_type</span><span class="o">=</span><span class="n">filter_type</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwds</span><span class="p">,</span>
                <span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">result</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span>
                <span class="k">return</span> <span class="n">result</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># After possibly _get_data and transposing, we are now in the</span>
        <span class="c1">#  simple case where we can use BlockManager.reduce</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">blk_func</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">out_dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">out_dtype</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">get_dtypes</span><span class="p">()</span> <span class="o">==</span> <span class="nb">object</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="s2">&quot;prod&quot;</span><span class="p">):</span>
            <span class="c1"># Even if we are object dtype, follow numpy and return</span>
            <span class="c1">#  float64, see test_apply_funcs_over_empty</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_reduce_axis1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Special case for _reduce to try to avoid a potentially-expensive transpose.</span>

<span class="sd">        Apply the reduction block-wise along axis=1 and then reduce the resulting</span>
<span class="sd">        1D arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">ufunc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;any&quot;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="c1"># error: Incompatible types in assignment</span>
            <span class="c1"># (expression has type &quot;_UFunc_Nin2_Nout1[Literal[&#39;logical_or&#39;],</span>
            <span class="c1"># Literal[20], Literal[False]]&quot;, variable has type</span>
            <span class="c1"># &quot;_UFunc_Nin2_Nout1[Literal[&#39;logical_and&#39;], Literal[20],</span>
            <span class="c1"># Literal[True]]&quot;)</span>
            <span class="n">ufunc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span>  <span class="c1"># type: ignore[assignment]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">arrays</span><span class="p">:</span>
            <span class="n">middle</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">ufunc</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">middle</span><span class="p">)</span>

        <span class="n">res_ser</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res_ser</span>

    <span class="k">def</span> <span class="nf">nunique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dropna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count number of distinct elements in specified axis.</span>

<span class="sd">        Return Series with number of distinct elements. Can ignore NaN</span>
<span class="sd">        values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            The axis to use. 0 or &#39;index&#39; for row-wise, 1 or &#39;columns&#39; for</span>
<span class="sd">            column-wise.</span>
<span class="sd">        dropna : bool, default True</span>
<span class="sd">            Don&#39;t include NaN in the counts.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.nunique: Method nunique for Series.</span>
<span class="sd">        DataFrame.count: Count non-NA cells for each column or row.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [4, 5, 6], &#39;B&#39;: [4, 1, 1]})</span>
<span class="sd">        &gt;&gt;&gt; df.nunique()</span>
<span class="sd">        A    3</span>
<span class="sd">        B    2</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; df.nunique(axis=1)</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    2</span>
<span class="sd">        dtype: int64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">Series</span><span class="o">.</span><span class="n">nunique</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dropna</span><span class="o">=</span><span class="n">dropna</span><span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;idxmin&quot;</span><span class="p">],</span> <span class="n">numeric_only_default</span><span class="o">=</span><span class="s2">&quot;False&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">idxmin</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numeric_only</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_reduce</span><span class="p">(</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">,</span> <span class="s2">&quot;argmin&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_values</span>

        <span class="c1"># indices will always be np.ndarray since axis is not None and</span>
        <span class="c1"># values is a 2d array for DataFrame</span>
        <span class="c1"># error: Item &quot;int&quot; of &quot;Union[int, Any]&quot; has no attribute &quot;__iter__&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>  <span class="c1"># for mypy</span>

        <span class="n">index</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
        <span class="n">final_result</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">_get_agg_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">final_result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;idxmin&quot;</span><span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">_shared_docs</span><span class="p">[</span><span class="s2">&quot;idxmax&quot;</span><span class="p">],</span> <span class="n">numeric_only_default</span><span class="o">=</span><span class="s2">&quot;False&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">idxmax</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">skipna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">numeric_only</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_reduce</span><span class="p">(</span>
            <span class="n">nanops</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">,</span> <span class="s2">&quot;argmax&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="n">skipna</span><span class="p">,</span> <span class="n">numeric_only</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">_values</span>

        <span class="c1"># indices will always be np.ndarray since axis is not None and</span>
        <span class="c1"># values is a 2d array for DataFrame</span>
        <span class="c1"># error: Item &quot;int&quot; of &quot;Union[int, Any]&quot; has no attribute &quot;__iter__&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>  <span class="c1"># for mypy</span>

        <span class="n">index</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_get_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
        <span class="n">final_result</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_constructor_sliced</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">_get_agg_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">final_result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;idxmax&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_agg_axis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis_num</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Index</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Let&#39;s be explicit about this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis_num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">elif</span> <span class="n">axis_num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Axis must be 0 or 1 (got </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">axis_num</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mode</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dropna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the mode(s) of each element along the selected axis.</span>

<span class="sd">        The mode of a set of values is the value that appears most often.</span>
<span class="sd">        It can be multiple values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            The axis to iterate over while searching for the mode:</span>

<span class="sd">            * 0 or &#39;index&#39; : get mode of each column</span>
<span class="sd">            * 1 or &#39;columns&#39; : get mode of each row.</span>

<span class="sd">        numeric_only : bool, default False</span>
<span class="sd">            If True, only apply to numeric columns.</span>
<span class="sd">        dropna : bool, default True</span>
<span class="sd">            Don&#39;t consider counts of NaN/NaT.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            The modes of each column or row.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.mode : Return the highest frequency value in a Series.</span>
<span class="sd">        Series.value_counts : Return the counts of values in a Series.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame([(&#39;bird&#39;, 2, 2),</span>
<span class="sd">        ...                    (&#39;mammal&#39;, 4, np.nan),</span>
<span class="sd">        ...                    (&#39;arthropod&#39;, 8, 0),</span>
<span class="sd">        ...                    (&#39;bird&#39;, 2, np.nan)],</span>
<span class="sd">        ...                   index=(&#39;falcon&#39;, &#39;horse&#39;, &#39;spider&#39;, &#39;ostrich&#39;),</span>
<span class="sd">        ...                   columns=(&#39;species&#39;, &#39;legs&#39;, &#39;wings&#39;))</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                   species  legs  wings</span>
<span class="sd">        falcon        bird     2    2.0</span>
<span class="sd">        horse       mammal     4    NaN</span>
<span class="sd">        spider   arthropod     8    0.0</span>
<span class="sd">        ostrich       bird     2    NaN</span>

<span class="sd">        By default, missing values are not considered, and the mode of wings</span>
<span class="sd">        are both 0 and 2. Because the resulting DataFrame has two rows,</span>
<span class="sd">        the second row of ``species`` and ``legs`` contains ``NaN``.</span>

<span class="sd">        &gt;&gt;&gt; df.mode()</span>
<span class="sd">          species  legs  wings</span>
<span class="sd">        0    bird   2.0    0.0</span>
<span class="sd">        1     NaN   NaN    2.0</span>

<span class="sd">        Setting ``dropna=False`` ``NaN`` values are considered and they can be</span>
<span class="sd">        the mode (like for wings).</span>

<span class="sd">        &gt;&gt;&gt; df.mode(dropna=False)</span>
<span class="sd">          species  legs  wings</span>
<span class="sd">        0    bird     2    NaN</span>

<span class="sd">        Setting ``numeric_only=True``, only the mode of numeric columns is</span>
<span class="sd">        computed, and columns of other types are ignored.</span>

<span class="sd">        &gt;&gt;&gt; df.mode(numeric_only=True)</span>
<span class="sd">           legs  wings</span>
<span class="sd">        0   2.0    0.0</span>
<span class="sd">        1   NaN    2.0</span>

<span class="sd">        To compute the mode over columns and not rows, use the axis parameter:</span>

<span class="sd">        &gt;&gt;&gt; df.mode(axis=&#39;columns&#39;, numeric_only=True)</span>
<span class="sd">                   0    1</span>
<span class="sd">        falcon   2.0  NaN</span>
<span class="sd">        horse    4.0  NaN</span>
<span class="sd">        spider   0.0  8.0</span>
<span class="sd">        ostrich  2.0  NaN</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">numeric_only</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">mode</span><span class="p">(</span><span class="n">dropna</span><span class="o">=</span><span class="n">dropna</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="c1"># Ensure index is type stable (should always use int index)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">default_index</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">quantile</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">interpolation</span><span class="p">:</span> <span class="n">QuantileInterpolation</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">quantile</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">AnyArrayLike</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">interpolation</span><span class="p">:</span> <span class="n">QuantileInterpolation</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">quantile</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">AnyArrayLike</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">interpolation</span><span class="p">:</span> <span class="n">QuantileInterpolation</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">quantile</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">AnyArrayLike</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">numeric_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">interpolation</span><span class="p">:</span> <span class="n">QuantileInterpolation</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;single&quot;</span><span class="p">,</span> <span class="s2">&quot;table&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;single&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return values at the given quantile over requested axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q : float or array-like, default 0.5 (50% quantile)</span>
<span class="sd">            Value between 0 &lt;= q &lt;= 1, the quantile(s) to compute.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            Equals 0 or &#39;index&#39; for row-wise, 1 or &#39;columns&#39; for column-wise.</span>
<span class="sd">        numeric_only : bool, default False</span>
<span class="sd">            Include only `float`, `int` or `boolean` data.</span>

<span class="sd">            .. versionchanged:: 2.0.0</span>
<span class="sd">                The default value of ``numeric_only`` is now ``False``.</span>

<span class="sd">        interpolation : {&#39;linear&#39;, &#39;lower&#39;, &#39;higher&#39;, &#39;midpoint&#39;, &#39;nearest&#39;}</span>
<span class="sd">            This optional parameter specifies the interpolation method to use,</span>
<span class="sd">            when the desired quantile lies between two data points `i` and `j`:</span>

<span class="sd">            * linear: `i + (j - i) * fraction`, where `fraction` is the</span>
<span class="sd">              fractional part of the index surrounded by `i` and `j`.</span>
<span class="sd">            * lower: `i`.</span>
<span class="sd">            * higher: `j`.</span>
<span class="sd">            * nearest: `i` or `j` whichever is nearest.</span>
<span class="sd">            * midpoint: (`i` + `j`) / 2.</span>
<span class="sd">        method : {&#39;single&#39;, &#39;table&#39;}, default &#39;single&#39;</span>
<span class="sd">            Whether to compute quantiles per-column (&#39;single&#39;) or over all columns</span>
<span class="sd">            (&#39;table&#39;). When &#39;table&#39;, the only allowed interpolation methods are</span>
<span class="sd">            &#39;nearest&#39;, &#39;lower&#39;, and &#39;higher&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>

<span class="sd">            If ``q`` is an array, a DataFrame will be returned where the</span>
<span class="sd">              index is ``q``, the columns are the columns of self, and the</span>
<span class="sd">              values are the quantiles.</span>
<span class="sd">            If ``q`` is a float, a Series will be returned where the</span>
<span class="sd">              index is the columns of self and the values are the quantiles.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        core.window.rolling.Rolling.quantile: Rolling quantile.</span>
<span class="sd">        numpy.percentile: Numpy function to compute the percentile.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame(np.array([[1, 1], [2, 10], [3, 100], [4, 100]]),</span>
<span class="sd">        ...                   columns=[&#39;a&#39;, &#39;b&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df.quantile(.1)</span>
<span class="sd">        a    1.3</span>
<span class="sd">        b    3.7</span>
<span class="sd">        Name: 0.1, dtype: float64</span>
<span class="sd">        &gt;&gt;&gt; df.quantile([.1, .5])</span>
<span class="sd">               a     b</span>
<span class="sd">        0.1  1.3   3.7</span>
<span class="sd">        0.5  2.5  55.0</span>

<span class="sd">        Specifying `method=&#39;table&#39;` will compute the quantile over all columns.</span>

<span class="sd">        &gt;&gt;&gt; df.quantile(.1, method=&quot;table&quot;, interpolation=&quot;nearest&quot;)</span>
<span class="sd">        a    1</span>
<span class="sd">        b    1</span>
<span class="sd">        Name: 0.1, dtype: int64</span>
<span class="sd">        &gt;&gt;&gt; df.quantile([.1, .5], method=&quot;table&quot;, interpolation=&quot;nearest&quot;)</span>
<span class="sd">             a    b</span>
<span class="sd">        0.1  1    1</span>
<span class="sd">        0.5  3  100</span>

<span class="sd">        Specifying `numeric_only=False` will also compute the quantile of</span>
<span class="sd">        datetime and timedelta data.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;A&#39;: [1, 2],</span>
<span class="sd">        ...                    &#39;B&#39;: [pd.Timestamp(&#39;2010&#39;),</span>
<span class="sd">        ...                          pd.Timestamp(&#39;2011&#39;)],</span>
<span class="sd">        ...                    &#39;C&#39;: [pd.Timedelta(&#39;1 days&#39;),</span>
<span class="sd">        ...                          pd.Timedelta(&#39;2 days&#39;)]})</span>
<span class="sd">        &gt;&gt;&gt; df.quantile(0.5, numeric_only=False)</span>
<span class="sd">        A                    1.5</span>
<span class="sd">        B    2010-07-02 12:00:00</span>
<span class="sd">        C        1 days 12:00:00</span>
<span class="sd">        Name: 0.5, dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">validate_percentile</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_number</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
            <span class="c1"># BlockManager.quantile expects listlike, so we wrap and unwrap here</span>
            <span class="c1"># error: List item 0 has incompatible type &quot;Union[float, Union[Union[</span>
            <span class="c1"># ExtensionArray, ndarray[Any, Any]], Index, Series], Sequence[float]]&quot;;</span>
            <span class="c1"># expected &quot;float&quot;</span>
            <span class="n">res_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span>  <span class="c1"># type: ignore[call-overload]</span>
                <span class="p">[</span><span class="n">q</span><span class="p">],</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                <span class="n">numeric_only</span><span class="o">=</span><span class="n">numeric_only</span><span class="p">,</span>
                <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;single&quot;</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res_df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># cannot directly iloc over sparse arrays</span>
                <span class="n">res</span> <span class="o">=</span> <span class="n">res_df</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># GH#41544 try to get an appropriate dtype</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">find_common_type</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_numeric_data</span><span class="p">()</span> <span class="k">if</span> <span class="n">numeric_only</span> <span class="k">else</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">T</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># GH#23925 _get_numeric_data may have dropped all columns</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">Index</span><span class="p">([],</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

            <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># GH#41544 try to get an appropriate dtype</span>
                <span class="n">cdtype</span> <span class="o">=</span> <span class="n">find_common_type</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">needs_i8_conversion</span><span class="p">(</span><span class="n">cdtype</span><span class="p">):</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="n">cdtype</span>

            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">([],</span> <span class="n">index</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>

        <span class="n">valid_method</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;single&quot;</span><span class="p">,</span> <span class="s2">&quot;table&quot;</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_method</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Invalid method: </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">. Method must be in </span><span class="si">{</span><span class="n">valid_method</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;single&quot;</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">qs</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;table&quot;</span><span class="p">:</span>
            <span class="n">valid_interpolation</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">,</span> <span class="s2">&quot;higher&quot;</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">interpolation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_interpolation</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Invalid interpolation: </span><span class="si">{</span><span class="n">interpolation</span><span class="si">}</span><span class="s2">. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Interpolation must be in </span><span class="si">{</span><span class="n">valid_interpolation</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="c1"># handle degenerate case</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="n">find_common_type</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtypes</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">([],</span> <span class="n">index</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

            <span class="n">q_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span>  <span class="c1"># type: ignore[call-overload]</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)),</span> <span class="n">q</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="n">np_percentile_argname</span><span class="p">:</span> <span class="n">interpolation</span><span class="p">}</span>
            <span class="p">)</span>

            <span class="n">by</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">by</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_get_label_or_level_values</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">by</span><span class="p">]</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="n">lexsort_indexer</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">by</span> <span class="o">=</span> <span class="n">by</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_get_label_or_level_values</span><span class="p">(</span><span class="n">by</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
                <span class="n">indexer</span> <span class="o">=</span> <span class="n">nargsort</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indexer</span><span class="p">[</span><span class="n">q_idx</span><span class="p">],</span> <span class="n">verify</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;quantile&quot;</span><span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">NDFrame</span><span class="o">.</span><span class="n">asfreq</span><span class="p">,</span> <span class="o">**</span><span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">asfreq</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="n">Frequency</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">FillnaOptions</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">how</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="n">Hashable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">asfreq</span><span class="p">(</span>
            <span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">,</span>
            <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@doc</span><span class="p">(</span><span class="n">NDFrame</span><span class="o">.</span><span class="n">resample</span><span class="p">,</span> <span class="o">**</span><span class="n">_shared_doc_kwargs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">rule</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">closed</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">convention</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;start&quot;</span><span class="p">,</span>
        <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">on</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">origin</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">TimestampConvertibleTypes</span> <span class="o">=</span> <span class="s2">&quot;start_day&quot;</span><span class="p">,</span>
        <span class="n">offset</span><span class="p">:</span> <span class="n">TimedeltaConvertibleTypes</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">group_keys</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Resampler</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span>
            <span class="n">rule</span><span class="o">=</span><span class="n">rule</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">closed</span><span class="o">=</span><span class="n">closed</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
            <span class="n">convention</span><span class="o">=</span><span class="n">convention</span><span class="p">,</span>
            <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
            <span class="n">on</span><span class="o">=</span><span class="n">on</span><span class="p">,</span>
            <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
            <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
            <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span>
            <span class="n">group_keys</span><span class="o">=</span><span class="n">group_keys</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_timestamp</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">freq</span><span class="p">:</span> <span class="n">Frequency</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">how</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;start&quot;</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cast to DatetimeIndex of timestamps, at *beginning* of period.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : str, default frequency of PeriodIndex</span>
<span class="sd">            Desired frequency.</span>
<span class="sd">        how : {&#39;s&#39;, &#39;e&#39;, &#39;start&#39;, &#39;end&#39;}</span>
<span class="sd">            Convention for converting period to timestamp; start of period</span>
<span class="sd">            vs. end.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            The axis to convert (the index by default).</span>
<span class="sd">        copy : bool, default True</span>
<span class="sd">            If False then underlying input data is not copied.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            The DataFrame has a DatetimeIndex.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.PeriodIndex([&#39;2023&#39;, &#39;2024&#39;], freq=&#39;Y&#39;)</span>
<span class="sd">        &gt;&gt;&gt; d = {&#39;col1&#39;: [1, 2], &#39;col2&#39;: [3, 4]}</span>
<span class="sd">        &gt;&gt;&gt; df1 = pd.DataFrame(data=d, index=idx)</span>
<span class="sd">        &gt;&gt;&gt; df1</span>
<span class="sd">              col1   col2</span>
<span class="sd">        2023     1      3</span>
<span class="sd">        2024	 2      4</span>

<span class="sd">        The resulting timestamps will be at the beginning of the year in this case</span>

<span class="sd">        &gt;&gt;&gt; df1 = df1.to_timestamp()</span>
<span class="sd">        &gt;&gt;&gt; df1</span>
<span class="sd">                    col1   col2</span>
<span class="sd">        2023-01-01     1      3</span>
<span class="sd">        2024-01-01     2      4</span>
<span class="sd">        &gt;&gt;&gt; df1.index</span>
<span class="sd">        DatetimeIndex([&#39;2023-01-01&#39;, &#39;2024-01-01&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)</span>

<span class="sd">        Using `freq` which is the offset that the Timestamps will have</span>

<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame(data=d, index=idx)</span>
<span class="sd">        &gt;&gt;&gt; df2 = df2.to_timestamp(freq=&#39;M&#39;)</span>
<span class="sd">        &gt;&gt;&gt; df2</span>
<span class="sd">                    col1   col2</span>
<span class="sd">        2023-01-31     1      3</span>
<span class="sd">        2024-01-31     2      4</span>
<span class="sd">        &gt;&gt;&gt; df2.index</span>
<span class="sd">        DatetimeIndex([&#39;2023-01-31&#39;, &#39;2024-01-31&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">copy</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">using_copy_on_write</span><span class="p">())</span>

        <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">old_ax</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_ax</span><span class="p">,</span> <span class="n">PeriodIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unsupported Type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">old_ax</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">new_ax</span> <span class="o">=</span> <span class="n">old_ax</span><span class="o">.</span><span class="n">to_timestamp</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="n">new_obj</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">,</span> <span class="n">new_ax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_obj</span>

    <span class="k">def</span> <span class="nf">to_period</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">freq</span><span class="p">:</span> <span class="n">Frequency</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert DataFrame from DatetimeIndex to PeriodIndex.</span>

<span class="sd">        Convert DataFrame from DatetimeIndex to PeriodIndex with desired</span>
<span class="sd">        frequency (inferred from index if not passed).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freq : str, default</span>
<span class="sd">            Frequency of the PeriodIndex.</span>
<span class="sd">        axis : {0 or &#39;index&#39;, 1 or &#39;columns&#39;}, default 0</span>
<span class="sd">            The axis to convert (the index by default).</span>
<span class="sd">        copy : bool, default True</span>
<span class="sd">            If False then underlying input data is not copied.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            The DataFrame has a PeriodIndex.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = pd.to_datetime(</span>
<span class="sd">        ...     [</span>
<span class="sd">        ...         &quot;2001-03-31 00:00:00&quot;,</span>
<span class="sd">        ...         &quot;2002-05-31 00:00:00&quot;,</span>
<span class="sd">        ...         &quot;2003-08-31 00:00:00&quot;,</span>
<span class="sd">        ...     ]</span>
<span class="sd">        ... )</span>

<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        DatetimeIndex([&#39;2001-03-31&#39;, &#39;2002-05-31&#39;, &#39;2003-08-31&#39;],</span>
<span class="sd">        dtype=&#39;datetime64[ns]&#39;, freq=None)</span>

<span class="sd">        &gt;&gt;&gt; idx.to_period(&quot;M&quot;)</span>
<span class="sd">        PeriodIndex([&#39;2001-03&#39;, &#39;2002-05&#39;, &#39;2003-08&#39;], dtype=&#39;period[M]&#39;)</span>

<span class="sd">        For the yearly frequency</span>

<span class="sd">        &gt;&gt;&gt; idx.to_period(&quot;Y&quot;)</span>
<span class="sd">        PeriodIndex([&#39;2001&#39;, &#39;2002&#39;, &#39;2003&#39;], dtype=&#39;period[A-DEC]&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="n">copy</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">using_copy_on_write</span><span class="p">())</span>

        <span class="n">axis_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_axis_name</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">old_ax</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_ax</span><span class="p">,</span> <span class="n">DatetimeIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unsupported Type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">old_ax</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">new_ax</span> <span class="o">=</span> <span class="n">old_ax</span><span class="o">.</span><span class="n">to_period</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="n">new_obj</span><span class="p">,</span> <span class="n">axis_name</span><span class="p">,</span> <span class="n">new_ax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_obj</span>

    <span class="k">def</span> <span class="nf">isin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Series</span> <span class="o">|</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Sequence</span> <span class="o">|</span> <span class="n">Mapping</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether each element in the DataFrame is contained in values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        values : iterable, Series, DataFrame or dict</span>
<span class="sd">            The result will only be true at a location if all the</span>
<span class="sd">            labels match. If `values` is a Series, that&#39;s the index. If</span>
<span class="sd">            `values` is a dict, the keys must be the column names,</span>
<span class="sd">            which must match. If `values` is a DataFrame,</span>
<span class="sd">            then both the index and column labels must match.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            DataFrame of booleans showing whether each element in the DataFrame</span>
<span class="sd">            is contained in values.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.eq: Equality test for DataFrame.</span>
<span class="sd">        Series.isin: Equivalent method on Series.</span>
<span class="sd">        Series.str.contains: Test if pattern or regex is contained within a</span>
<span class="sd">            string of a Series or Index.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;num_legs&#39;: [2, 4], &#39;num_wings&#39;: [2, 0]},</span>
<span class="sd">        ...                   index=[&#39;falcon&#39;, &#39;dog&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                num_legs  num_wings</span>
<span class="sd">        falcon         2          2</span>
<span class="sd">        dog            4          0</span>

<span class="sd">        When ``values`` is a list check whether every value in the DataFrame</span>
<span class="sd">        is present in the list (which animals have 0 or 2 legs or wings)</span>

<span class="sd">        &gt;&gt;&gt; df.isin([0, 2])</span>
<span class="sd">                num_legs  num_wings</span>
<span class="sd">        falcon      True       True</span>
<span class="sd">        dog        False       True</span>

<span class="sd">        To check if ``values`` is *not* in the DataFrame, use the ``~`` operator:</span>

<span class="sd">        &gt;&gt;&gt; ~df.isin([0, 2])</span>
<span class="sd">                num_legs  num_wings</span>
<span class="sd">        falcon     False      False</span>
<span class="sd">        dog         True      False</span>

<span class="sd">        When ``values`` is a dict, we can pass values to check for each</span>
<span class="sd">        column separately:</span>

<span class="sd">        &gt;&gt;&gt; df.isin({&#39;num_wings&#39;: [0, 3]})</span>
<span class="sd">                num_legs  num_wings</span>
<span class="sd">        falcon     False      False</span>
<span class="sd">        dog        False       True</span>

<span class="sd">        When ``values`` is a Series or DataFrame the index and column must</span>
<span class="sd">        match. Note that &#39;falcon&#39; does not match based on the number of legs</span>
<span class="sd">        in other.</span>

<span class="sd">        &gt;&gt;&gt; other = pd.DataFrame({&#39;num_legs&#39;: [8, 3], &#39;num_wings&#39;: [0, 2]},</span>
<span class="sd">        ...                      index=[&#39;spider&#39;, &#39;falcon&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df.isin(other)</span>
<span class="sd">                num_legs  num_wings</span>
<span class="sd">        falcon     False       True</span>
<span class="sd">        dog        False      False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">pandas.core.reshape.concat</span> <span class="kn">import</span> <span class="n">concat</span>

            <span class="n">values</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">concat</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="n">col</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">values</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot compute isin with a duplicate axis.&quot;</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">reindex_like</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">is_unique</span> <span class="ow">and</span> <span class="n">values</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_unique</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot compute isin with a duplicate axis.&quot;</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">values</span><span class="o">.</span><span class="n">reindex_like</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;only list-like or dict-like objects are allowed &quot;</span>
                    <span class="s2">&quot;to be passed to DataFrame.isin(), &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;you passed a &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                <span class="p">)</span>
            <span class="c1"># error: Argument 2 to &quot;isin&quot; has incompatible type &quot;Union[Sequence[Any],</span>
            <span class="c1"># Mapping[Any, Any]]&quot;; expected &quot;Union[Union[ExtensionArray,</span>
            <span class="c1"># ndarray[Any, Any]], Index, Series]&quot;</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span>
                <span class="n">algorithms</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">values</span>  <span class="c1"># type: ignore[arg-type]</span>
                <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span>
                <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;isin&quot;</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Add index and columns</span>
    <span class="n">_AXIS_ORDERS</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">]</span>
    <span class="n">_AXIS_TO_AXIS_NUMBER</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="n">Axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="o">**</span><span class="n">NDFrame</span><span class="o">.</span><span class="n">_AXIS_TO_AXIS_NUMBER</span><span class="p">,</span>
        <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="s2">&quot;columns&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">_AXIS_LEN</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_AXIS_ORDERS</span><span class="p">)</span>
    <span class="n">_info_axis_number</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">_info_axis_name</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;columns&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;columns&quot;</span>

    <span class="n">index</span> <span class="o">=</span> <span class="n">properties</span><span class="o">.</span><span class="n">AxisProperty</span><span class="p">(</span>
        <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The index (row labels) of the DataFrame.&quot;</span>
    <span class="p">)</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="n">properties</span><span class="o">.</span><span class="n">AxisProperty</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The column labels of the DataFrame.&quot;</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Add plotting methods to DataFrame</span>
    <span class="n">plot</span> <span class="o">=</span> <span class="n">CachedAccessor</span><span class="p">(</span><span class="s2">&quot;plot&quot;</span><span class="p">,</span> <span class="n">pandas</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">PlotAccessor</span><span class="p">)</span>
    <span class="n">hist</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">hist_frame</span>
    <span class="n">boxplot</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">plotting</span><span class="o">.</span><span class="n">boxplot_frame</span>
    <span class="n">sparse</span> <span class="o">=</span> <span class="n">CachedAccessor</span><span class="p">(</span><span class="s2">&quot;sparse&quot;</span><span class="p">,</span> <span class="n">SparseFrameAccessor</span><span class="p">)</span>

    <span class="c1"># ----------------------------------------------------------------------</span>
    <span class="c1"># Internal Interface Methods</span>

    <span class="k">def</span> <span class="nf">_to_dict_of_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a dict of dtype -&gt; Constructor Types that</span>
<span class="sd">        each is a homogeneous dtype.</span>

<span class="sd">        Internal ONLY - only works for BlockManager</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mgr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span>
        <span class="c1"># convert to BlockManager if needed -&gt; this way support ArrayManager as well</span>
        <span class="n">mgr</span> <span class="o">=</span> <span class="n">mgr_to_mgr</span><span class="p">(</span><span class="n">mgr</span><span class="p">,</span> <span class="s2">&quot;block&quot;</span><span class="p">)</span>
        <span class="n">mgr</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">BlockManager</span><span class="p">,</span> <span class="n">mgr</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constructor</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">__finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="ow">in</span> <span class="n">mgr</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a Numpy representation of the DataFrame.</span>

<span class="sd">        .. warning::</span>

<span class="sd">           We recommend using :meth:`DataFrame.to_numpy` instead.</span>

<span class="sd">        Only the values in the DataFrame will be returned, the axes labels</span>
<span class="sd">        will be removed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            The values of the DataFrame.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DataFrame.to_numpy : Recommended alternative to this method.</span>
<span class="sd">        DataFrame.index : Retrieve the index labels.</span>
<span class="sd">        DataFrame.columns : Retrieving the column names.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The dtype will be a lower-common-denominator dtype (implicit</span>
<span class="sd">        upcasting); that is to say if the dtypes (even of numeric types)</span>
<span class="sd">        are mixed, the one that accommodates all will be chosen. Use this</span>
<span class="sd">        with care if you are not dealing with the blocks.</span>

<span class="sd">        e.g. If the dtypes are float16 and float32, dtype will be upcast to</span>
<span class="sd">        float32.  If dtypes are int32 and uint8, dtype will be upcast to</span>
<span class="sd">        int32. By :func:`numpy.find_common_type` convention, mixing int64</span>
<span class="sd">        and uint64 will result in a float64 dtype.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        A DataFrame where all columns are the same type (e.g., int64) results</span>
<span class="sd">        in an array of the same type.</span>

<span class="sd">        &gt;&gt;&gt; df = pd.DataFrame({&#39;age&#39;:    [ 3,  29],</span>
<span class="sd">        ...                    &#39;height&#39;: [94, 170],</span>
<span class="sd">        ...                    &#39;weight&#39;: [31, 115]})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           age  height  weight</span>
<span class="sd">        0    3      94      31</span>
<span class="sd">        1   29     170     115</span>
<span class="sd">        &gt;&gt;&gt; df.dtypes</span>
<span class="sd">        age       int64</span>
<span class="sd">        height    int64</span>
<span class="sd">        weight    int64</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &gt;&gt;&gt; df.values</span>
<span class="sd">        array([[  3,  94,  31],</span>
<span class="sd">               [ 29, 170, 115]])</span>

<span class="sd">        A DataFrame with mixed type columns(e.g., str/object, int64, float32)</span>
<span class="sd">        results in an ndarray of the broadest type that accommodates these</span>
<span class="sd">        mixed types (e.g., object).</span>

<span class="sd">        &gt;&gt;&gt; df2 = pd.DataFrame([(&#39;parrot&#39;,   24.0, &#39;second&#39;),</span>
<span class="sd">        ...                     (&#39;lion&#39;,     80.5, 1),</span>
<span class="sd">        ...                     (&#39;monkey&#39;, np.nan, None)],</span>
<span class="sd">        ...                   columns=(&#39;name&#39;, &#39;max_speed&#39;, &#39;rank&#39;))</span>
<span class="sd">        &gt;&gt;&gt; df2.dtypes</span>
<span class="sd">        name          object</span>
<span class="sd">        max_speed    float64</span>
<span class="sd">        rank          object</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &gt;&gt;&gt; df2.values</span>
<span class="sd">        array([[&#39;parrot&#39;, 24.0, &#39;second&#39;],</span>
<span class="sd">               [&#39;lion&#39;, 80.5, 1],</span>
<span class="sd">               [&#39;monkey&#39;, nan, None]], dtype=object)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mgr</span><span class="o">.</span><span class="n">as_array</span><span class="p">()</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">ffill</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">ffill</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">limit</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">ffill</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">ffill</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Axis</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">ffill</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">bfill</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">downcast</span><span class="o">=...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">bfill</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">limit</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">downcast</span><span class="o">=...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">bfill</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Axis</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">downcast</span><span class="o">=...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">bfill</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Axis</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">downcast</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">bfill</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span> <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clip</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">lower</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">upper</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;linear&quot;</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">limit_direction</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">limit_area</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">downcast</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
            <span class="n">limit_direction</span><span class="o">=</span><span class="n">limit_direction</span><span class="p">,</span>
            <span class="n">limit_area</span><span class="o">=</span><span class="n">limit_area</span><span class="p">,</span>
            <span class="n">downcast</span><span class="o">=</span><span class="n">downcast</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">where</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cond</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">where</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cond</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">where</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cond</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">where</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cond</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=</span><span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
            <span class="n">cond</span><span class="p">,</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cond</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cond</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cond</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cond</span><span class="p">,</span>
        <span class="n">other</span><span class="o">=</span><span class="n">lib</span><span class="o">.</span><span class="n">no_default</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Axis</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Level</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span>
            <span class="n">cond</span><span class="p">,</span>
            <span class="n">other</span><span class="p">,</span>
            <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">,</span>
            <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
            <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
        <span class="p">)</span>


<span class="n">DataFrame</span><span class="o">.</span><span class="n">_add_numeric_operations</span><span class="p">()</span>

<span class="n">ops</span><span class="o">.</span><span class="n">add_flex_arithmetic_methods</span><span class="p">(</span><span class="n">DataFrame</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_from_nested_dict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">:</span>
    <span class="n">new_data</span><span class="p">:</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_data</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    <span class="k">return</span> <span class="n">new_data</span>


<span class="k">def</span> <span class="nf">_reindex_for_setitem</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">DataFrame</span> <span class="o">|</span> <span class="n">Series</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="n">Index</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
    <span class="c1"># reindex if necessary</span>

    <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">_values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># GH#4107</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">reindexed_value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">_values</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="c1"># raised in MultiIndex.from_tuples, see test_insert_error_msmgs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">is_unique</span><span class="p">:</span>
            <span class="c1"># duplicate axis</span>
            <span class="k">raise</span> <span class="n">err</span>

        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;incompatible index of inserted column with frame index&quot;</span>
        <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
    <span class="k">return</span> <span class="n">reindexed_value</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Enrico Prataviera, Jacopo Vivian.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>